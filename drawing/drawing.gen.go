package drawing

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	api "github.com/atburke/krpc-go/lib/api"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	spacecenter "github.com/atburke/krpc-go/spacecenter"
	ui "github.com/atburke/krpc-go/ui"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// Line - a line. Created using <see cref="M:Drawing.AddLine" />.
type Line struct {
	service.BaseClass
}

// NewLine creates a new Line.
func NewLine(id uint64, client *krpcgo.KRPCClient) *Line {
	c := &Line{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Polygon - a polygon. Created using <see cref="M:Drawing.AddPolygon" />.
type Polygon struct {
	service.BaseClass
}

// NewPolygon creates a new Polygon.
func NewPolygon(id uint64, client *krpcgo.KRPCClient) *Polygon {
	c := &Polygon{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Text - text. Created using <see cref="M:Drawing.AddText" />.
type Text struct {
	service.BaseClass
}

// NewText creates a new Text.
func NewText(id uint64, client *krpcgo.KRPCClient) *Text {
	c := &Text{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Drawing - provides functionality for drawing objects in the flight scene.
type Drawing struct {
	Client *krpcgo.KRPCClient
}

// NewDrawing creates a new Drawing.
func NewDrawing(client *krpcgo.KRPCClient) *Drawing {
	return &Drawing{Client: client}
}

// AddLine will draw a line in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) AddLine(start api.Tuple3[float64, float64, float64], end api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, visible bool) (Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &api.ProcedureCall{
		Procedure: "AddLine",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(start)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(end)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddLine will draw a line in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) StreamAddLine(start api.Tuple3[float64, float64, float64], end api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, visible bool) (*krpcgo.Stream[Line], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddLine",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(start)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(end)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) Line {
		var value Line
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddDirection will draw a direction vector in the scene, starting from the
// origin of the given reference frame.
//
// Allowed game scenes: any.
func (s *Drawing) AddDirection(direction api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, length float32, visible bool) (Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &api.ProcedureCall{
		Procedure: "AddDirection",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddDirection will draw a direction vector in the scene, starting from
// the origin of the given reference frame.
//
// Allowed game scenes: any.
func (s *Drawing) StreamAddDirection(direction api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, length float32, visible bool) (*krpcgo.Stream[Line], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddDirection",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) Line {
		var value Line
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddDirectionFromCom will draw a direction vector in the scene, from the
// center of mass of the active vessel.
//
// Allowed game scenes: any.
func (s *Drawing) AddDirectionFromCom(direction api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, length float32, visible bool) (Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &api.ProcedureCall{
		Procedure: "AddDirectionFromCom",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddDirectionFromCom will draw a direction vector in the scene, from the
// center of mass of the active vessel.
//
// Allowed game scenes: any.
func (s *Drawing) StreamAddDirectionFromCom(direction api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, length float32, visible bool) (*krpcgo.Stream[Line], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddDirectionFromCom",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) Line {
		var value Line
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddPolygon will draw a polygon in the scene, defined by a list of vertices.
//
// Allowed game scenes: any.
func (s *Drawing) AddPolygon(vertices []api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, visible bool) (Polygon, error) {
	var err error
	var argBytes []byte
	var vv Polygon
	request := &api.ProcedureCall{
		Procedure: "AddPolygon",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(vertices)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddPolygon will draw a polygon in the scene, defined by a list of
// vertices.
//
// Allowed game scenes: any.
func (s *Drawing) StreamAddPolygon(vertices []api.Tuple3[float64, float64, float64], referenceFrame spacecenter.ReferenceFrame, visible bool) (*krpcgo.Stream[Polygon], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddPolygon",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(vertices)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) Polygon {
		var value Polygon
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddText will draw text in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) AddText(text string, referenceFrame spacecenter.ReferenceFrame, position api.Tuple3[float64, float64, float64], rotation api.Tuple4[float64, float64, float64, float64], visible bool) (Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &api.ProcedureCall{
		Procedure: "AddText",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(text)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddText will draw text in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) StreamAddText(text string, referenceFrame spacecenter.ReferenceFrame, position api.Tuple3[float64, float64, float64], rotation api.Tuple4[float64, float64, float64, float64], visible bool) (*krpcgo.Stream[Text], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddText",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(text)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) Text {
		var value Text
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Clear will remove all objects being drawn.
//
// Allowed game scenes: any.
func (s *Drawing) Clear(clientOnly bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Clear",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(clientOnly)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove will remove the object.
//
// Allowed game scenes: any.
func (s *Line) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Start will start position of the line.
//
// Allowed game scenes: any.
func (s *Line) Start() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Line_get_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStart will start position of the line.
//
// Allowed game scenes: any.
func (s *Line) StreamStart() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetStart will start position of the line.
//
// Allowed game scenes: any.
func (s *Line) SetStart(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// End will end position of the line.
//
// Allowed game scenes: any.
func (s *Line) End() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Line_get_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnd will end position of the line.
//
// Allowed game scenes: any.
func (s *Line) StreamEnd() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetEnd will end position of the line.
//
// Allowed game scenes: any.
func (s *Line) SetEnd(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color will set the color
//
// Allowed game scenes: any.
func (s *Line) Color() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Line_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColor will set the color
//
// Allowed game scenes: any.
func (s *Line) StreamColor() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetColor will set the color
//
// Allowed game scenes: any.
func (s *Line) SetColor(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thickness will set the thickness
//
// Allowed game scenes: any.
func (s *Line) Thickness() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Line_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThickness will set the thickness
//
// Allowed game scenes: any.
func (s *Line) StreamThickness() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetThickness will set the thickness
//
// Allowed game scenes: any.
func (s *Line) SetThickness(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Line) ReferenceFrame() (spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Line_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Line) StreamReferenceFrame() (*krpcgo.Stream[spacecenter.ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) spacecenter.ReferenceFrame {
		var value spacecenter.ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Line) SetReferenceFrame(value spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Line_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) StreamVisible() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material will material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Line_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) StreamMaterial() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Line_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove will remove the object.
//
// Allowed game scenes: any.
func (s *Polygon) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Vertices will vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) Vertices() ([]api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv []api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVertices will vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) StreamVertices() (*krpcgo.Stream[[]api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []api.Tuple3[float64, float64, float64] {
		var value []api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetVertices will vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) SetVertices(value []api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color will set the color
//
// Allowed game scenes: any.
func (s *Polygon) Color() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColor will set the color
//
// Allowed game scenes: any.
func (s *Polygon) StreamColor() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetColor will set the color
//
// Allowed game scenes: any.
func (s *Polygon) SetColor(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thickness will set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) Thickness() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThickness will set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) StreamThickness() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetThickness will set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) SetThickness(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Polygon) ReferenceFrame() (spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Polygon) StreamReferenceFrame() (*krpcgo.Stream[spacecenter.ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) spacecenter.ReferenceFrame {
		var value spacecenter.ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Polygon) SetReferenceFrame(value spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) StreamVisible() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material will material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) StreamMaterial() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Polygon_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableFonts will a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) AvailableFonts() ([]string, error) {
	var err error
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Text_static_AvailableFonts",
		Service:   "Drawing",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableFonts will a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) StreamAvailableFonts() (*krpcgo.Stream[[]string], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Text_static_AvailableFonts",
		Service:   "Drawing",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Remove will remove the object.
//
// Allowed game scenes: any.
func (s *Text) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position will position of the text.
//
// Allowed game scenes: any.
func (s *Text) Position() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Text_get_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will position of the text.
//
// Allowed game scenes: any.
func (s *Text) StreamPosition() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPosition will position of the text.
//
// Allowed game scenes: any.
func (s *Text) SetPosition(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Rotation will rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) Rotation() (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Text_get_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) StreamRotation() (*krpcgo.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRotation will rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) SetRotation(value api.Tuple4[float64, float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Content will the text string
//
// Allowed game scenes: any.
func (s *Text) Content() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamContent will the text string
//
// Allowed game scenes: any.
func (s *Text) StreamContent() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetContent will the text string
//
// Allowed game scenes: any.
func (s *Text) SetContent(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Font will name of the font
//
// Allowed game scenes: any.
func (s *Text) Font() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFont will name of the font
//
// Allowed game scenes: any.
func (s *Text) StreamFont() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetFont will name of the font
//
// Allowed game scenes: any.
func (s *Text) SetFont(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Size will font size.
//
// Allowed game scenes: any.
func (s *Text) Size() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSize will font size.
//
// Allowed game scenes: any.
func (s *Text) StreamSize() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSize will font size.
//
// Allowed game scenes: any.
func (s *Text) SetSize(value int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CharacterSize will character size.
//
// Allowed game scenes: any.
func (s *Text) CharacterSize() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Text_get_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCharacterSize will character size.
//
// Allowed game scenes: any.
func (s *Text) StreamCharacterSize() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetCharacterSize will character size.
//
// Allowed game scenes: any.
func (s *Text) SetCharacterSize(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Style will font style.
//
// Allowed game scenes: any.
func (s *Text) Style() (ui.FontStyle, error) {
	var err error
	var argBytes []byte
	var vv ui.FontStyle
	request := &api.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStyle will font style.
//
// Allowed game scenes: any.
func (s *Text) StreamStyle() (*krpcgo.Stream[ui.FontStyle], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.FontStyle {
		var value ui.FontStyle
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetStyle will font style.
//
// Allowed game scenes: any.
func (s *Text) SetStyle(value ui.FontStyle) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Alignment will alignment.
//
// Allowed game scenes: any.
func (s *Text) Alignment() (ui.TextAlignment, error) {
	var err error
	var argBytes []byte
	var vv ui.TextAlignment
	request := &api.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAlignment will alignment.
//
// Allowed game scenes: any.
func (s *Text) StreamAlignment() (*krpcgo.Stream[ui.TextAlignment], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.TextAlignment {
		var value ui.TextAlignment
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAlignment will alignment.
//
// Allowed game scenes: any.
func (s *Text) SetAlignment(value ui.TextAlignment) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LineSpacing will line spacing.
//
// Allowed game scenes: any.
func (s *Text) LineSpacing() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLineSpacing will line spacing.
//
// Allowed game scenes: any.
func (s *Text) StreamLineSpacing() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetLineSpacing will line spacing.
//
// Allowed game scenes: any.
func (s *Text) SetLineSpacing(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Anchor will anchor.
//
// Allowed game scenes: any.
func (s *Text) Anchor() (ui.TextAnchor, error) {
	var err error
	var argBytes []byte
	var vv ui.TextAnchor
	request := &api.ProcedureCall{
		Procedure: "Text_get_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAnchor will anchor.
//
// Allowed game scenes: any.
func (s *Text) StreamAnchor() (*krpcgo.Stream[ui.TextAnchor], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.TextAnchor {
		var value ui.TextAnchor
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAnchor will anchor.
//
// Allowed game scenes: any.
func (s *Text) SetAnchor(value ui.TextAnchor) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color will set the color
//
// Allowed game scenes: any.
func (s *Text) Color() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColor will set the color
//
// Allowed game scenes: any.
func (s *Text) StreamColor() (*krpcgo.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetColor will set the color
//
// Allowed game scenes: any.
func (s *Text) SetColor(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Text) ReferenceFrame() (spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Text_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Text) StreamReferenceFrame() (*krpcgo.Stream[spacecenter.ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) spacecenter.ReferenceFrame {
		var value spacecenter.ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReferenceFrame will reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Text) SetReferenceFrame(value spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) StreamVisible() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetVisible will whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material will material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Text_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) StreamMaterial() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMaterial will material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Text_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

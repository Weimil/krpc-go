package remotetech

import (
	api "github.com/atburke/krpc-go/api"
	client "github.com/atburke/krpc-go/lib/client"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	krpc "github.com/atburke/krpc-go/lib/service/krpc"
	spacecenter "github.com/atburke/krpc-go/lib/service/spacecenter"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

/*
Target is the type of object an antenna is targetting. See <see
cref="M:RemoteTech.Antenna.Target" />.
*/
type Target int32

const (
	// The active vessel.
	Target_ActiveVessel Target = 0
	// A celestial body.
	Target_CelestialBody Target = 1
	// A ground station.
	Target_GroundStation Target = 2
	// A specific vessel.
	Target_Vessel Target = 3
	// No target.
	Target_None Target = 4
)

// Antenna - a RemoteTech antenna. Obtained by calling <see
// cref="M:RemoteTech.Comms.Antennas" /> or <see cref="M:RemoteTech.Antenna" />.
type Antenna struct {
	service.BaseClass
}

// NewAntenna creates a new Antenna.
func NewAntenna(id uint64, client *client.KRPCClient) *Antenna {
	c := &Antenna{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Comms - communications for a vessel.
type Comms struct {
	service.BaseClass
}

// NewComms creates a new Comms.
func NewComms(id uint64, client *client.KRPCClient) *Comms {
	c := &Comms{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// RemoteTech - this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/139167-13-remotetech-v188-2017-09-03/">RemoteTech</a>.
type RemoteTech struct {
	Client *client.KRPCClient
}

// NewRemoteTech creates a new RemoteTech.
func NewRemoteTech(client *client.KRPCClient) *RemoteTech {
	return &RemoteTech{Client: client}
}

// Comms will get a communications object, representing the communication
// capability of a particular vessel.
//
// Allowed game scenes: any.
func (s *RemoteTech) Comms(vessel spacecenter.Vessel) (Comms, error) {
	var err error
	var argBytes []byte
	var vv Comms
	request := &api.ProcedureCall{
		Procedure: "Comms",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamComms will get a communications object, representing the communication
// capability of a particular vessel.
//
// Allowed game scenes: any.
func (s *RemoteTech) StreamComms(vessel spacecenter.Vessel) (*client.Stream[Comms], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Comms {
		var value Comms
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Antenna will get the antenna object for a particular part.
//
// Allowed game scenes: any.
func (s *RemoteTech) Antenna(part spacecenter.Part) (Antenna, error) {
	var err error
	var argBytes []byte
	var vv Antenna
	request := &api.ProcedureCall{
		Procedure: "Antenna",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntenna will get the antenna object for a particular part.
//
// Allowed game scenes: any.
func (s *RemoteTech) StreamAntenna(part spacecenter.Part) (*client.Stream[Antenna], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Antenna {
		var value Antenna
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Available will whether RemoteTech is installed.
//
// Allowed game scenes: any.
func (s *RemoteTech) Available() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_Available",
		Service:   "RemoteTech",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailable will whether RemoteTech is installed.
//
// Allowed game scenes: any.
func (s *RemoteTech) StreamAvailable() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Available",
		Service:   "RemoteTech",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GroundStations will the names of the ground stations.
//
// Allowed game scenes: any.
func (s *RemoteTech) GroundStations() ([]string, error) {
	var err error
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "get_GroundStations",
		Service:   "RemoteTech",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGroundStations will the names of the ground stations.
//
// Allowed game scenes: any.
func (s *RemoteTech) StreamGroundStations() (*client.Stream[[]string], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_GroundStations",
		Service:   "RemoteTech",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will get the part containing this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) Part() (spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Part
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Part",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will get the part containing this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPart() (*client.Stream[spacecenter.Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Part",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) spacecenter.Part {
		var value spacecenter.Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasConnection will whether the antenna has a connection.
//
// Allowed game scenes: any.
func (s *Antenna) HasConnection() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_HasConnection",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasConnection will whether the antenna has a connection.
//
// Allowed game scenes: any.
func (s *Antenna) StreamHasConnection() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_HasConnection",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Target will the object that the antenna is targetting. This property can be
// used to set the target to <see cref="M:RemoteTech.Target.None" /> or <see
// cref="M:RemoteTech.Target.ActiveVessel" />. To set the target to a celestial
// body, ground station or vessel see <see
// cref="M:RemoteTech.Antenna.TargetBody" />, <see
// cref="M:RemoteTech.Antenna.TargetGroundStation" /> and <see
// cref="M:RemoteTech.Antenna.TargetVessel" />.
//
// Allowed game scenes: any.
func (s *Antenna) Target() (Target, error) {
	var err error
	var argBytes []byte
	var vv Target
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Target",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTarget will the object that the antenna is targetting. This property
// can be used to set the target to <see cref="M:RemoteTech.Target.None" /> or
// <see cref="M:RemoteTech.Target.ActiveVessel" />. To set the target to a
// celestial body, ground station or vessel see <see
// cref="M:RemoteTech.Antenna.TargetBody" />, <see
// cref="M:RemoteTech.Antenna.TargetGroundStation" /> and <see
// cref="M:RemoteTech.Antenna.TargetVessel" />.
//
// Allowed game scenes: any.
func (s *Antenna) StreamTarget() (*client.Stream[Target], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Target",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Target {
		var value Target
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTarget will the object that the antenna is targetting. This property can
// be used to set the target to <see cref="M:RemoteTech.Target.None" /> or <see
// cref="M:RemoteTech.Target.ActiveVessel" />. To set the target to a celestial
// body, ground station or vessel see <see
// cref="M:RemoteTech.Antenna.TargetBody" />, <see
// cref="M:RemoteTech.Antenna.TargetGroundStation" /> and <see
// cref="M:RemoteTech.Antenna.TargetVessel" />.
//
// Allowed game scenes: any.
func (s *Antenna) SetTarget(value Target) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_Target",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetBody will the celestial body the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) TargetBody() (spacecenter.CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.CelestialBody
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetBody",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetBody will the celestial body the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) StreamTargetBody() (*client.Stream[spacecenter.CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetBody",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) spacecenter.CelestialBody {
		var value spacecenter.CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetBody will the celestial body the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) SetTargetBody(value spacecenter.CelestialBody) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_TargetBody",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetGroundStation will the ground station the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) TargetGroundStation() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetGroundStation will the ground station the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) StreamTargetGroundStation() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetGroundStation will the ground station the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) SetTargetGroundStation(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_TargetGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetVessel will the vessel the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) TargetVessel() (spacecenter.Vessel, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Vessel
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetVessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetVessel will the vessel the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) StreamTargetVessel() (*client.Stream[spacecenter.Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_TargetVessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) spacecenter.Vessel {
		var value spacecenter.Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetVessel will the vessel the antenna is targetting.
//
// Allowed game scenes: any.
func (s *Antenna) SetTargetVessel(value spacecenter.Vessel) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_TargetVessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SignalDelayToVessel will the signal delay between the this vessel and another
// vessel, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelayToVessel(other spacecenter.Vessel) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_SignalDelayToVessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(other)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalDelayToVessel will the signal delay between the this vessel and
// another vessel, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) StreamSignalDelayToVessel(other spacecenter.Vessel) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_SignalDelayToVessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(other)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Vessel will get the vessel.
//
// Allowed game scenes: any.
func (s *Comms) Vessel() (spacecenter.Vessel, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Vessel
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Vessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVessel will get the vessel.
//
// Allowed game scenes: any.
func (s *Comms) StreamVessel() (*client.Stream[spacecenter.Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Vessel",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) spacecenter.Vessel {
		var value spacecenter.Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasLocalControl will whether the vessel can be controlled locally.
//
// Allowed game scenes: any.
func (s *Comms) HasLocalControl() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasLocalControl",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasLocalControl will whether the vessel can be controlled locally.
//
// Allowed game scenes: any.
func (s *Comms) StreamHasLocalControl() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasLocalControl",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasFlightComputer will whether the vessel has a flight computer on board.
//
// Allowed game scenes: any.
func (s *Comms) HasFlightComputer() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasFlightComputer",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasFlightComputer will whether the vessel has a flight computer on
// board.
//
// Allowed game scenes: any.
func (s *Comms) StreamHasFlightComputer() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasFlightComputer",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasConnection will whether the vessel has any connection.
//
// Allowed game scenes: any.
func (s *Comms) HasConnection() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasConnection",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasConnection will whether the vessel has any connection.
//
// Allowed game scenes: any.
func (s *Comms) StreamHasConnection() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasConnection",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasConnectionToGroundStation will whether the vessel has a connection to a
// ground station.
//
// Allowed game scenes: any.
func (s *Comms) HasConnectionToGroundStation() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasConnectionToGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasConnectionToGroundStation will whether the vessel has a connection
// to a ground station.
//
// Allowed game scenes: any.
func (s *Comms) StreamHasConnectionToGroundStation() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_HasConnectionToGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SignalDelay will the shortest signal delay to the vessel, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelay() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalDelay will the shortest signal delay to the vessel, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) StreamSignalDelay() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SignalDelayToGroundStation will the signal delay between the vessel and the
// closest ground station, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelayToGroundStation() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelayToGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalDelayToGroundStation will the signal delay between the vessel and
// the closest ground station, in seconds.
//
// Allowed game scenes: any.
func (s *Comms) StreamSignalDelayToGroundStation() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelayToGroundStation",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Antennas will the antennas for this vessel.
//
// Allowed game scenes: any.
func (s *Comms) Antennas() ([]Antenna, error) {
	var err error
	var argBytes []byte
	var vv []Antenna
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Antennas",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntennas will the antennas for this vessel.
//
// Allowed game scenes: any.
func (s *Comms) StreamAntennas() (*client.Stream[[]Antenna], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Antennas",
		Service:   "RemoteTech",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Antenna {
		var value []Antenna
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

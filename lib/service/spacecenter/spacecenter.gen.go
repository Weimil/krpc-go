package spacecenter

import (
	api "github.com/atburke/krpc-go/api"
	client "github.com/atburke/krpc-go/lib/client"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	krpc "github.com/atburke/krpc-go/lib/service/krpc"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// CameraMode is see <see cref="M:SpaceCenter.Camera.Mode" />.
type CameraMode int32

const (
	// The camera is showing the active vessel, in "auto" mode.
	CameraMode_Automatic CameraMode = 0
	// The camera is showing the active vessel, in "free" mode.
	CameraMode_Free CameraMode = 1
	// The camera is showing the active vessel, in "chase" mode.
	CameraMode_Chase CameraMode = 2
	// The camera is showing the active vessel, in "locked" mode.
	CameraMode_Locked CameraMode = 3
	// The camera is showing the active vessel, in "orbital" mode.
	CameraMode_Orbital CameraMode = 4
	// The Intra-Vehicular Activity view is being shown.
	CameraMode_IVA CameraMode = 5
	// The map view is being shown.
	CameraMode_Map CameraMode = 6
)

/*
CommLinkType is the type of a communication link. See <see
cref="M:SpaceCenter.CommLink.Type" />.
*/
type CommLinkType int32

const (
	// Link is to a base station on Kerbin.
	CommLinkType_Home CommLinkType = 0
	// Link is to a control source, for example a manned spacecraft.
	CommLinkType_Control CommLinkType = 1
	// Link is to a relay satellite.
	CommLinkType_Relay CommLinkType = 2
)

/*
ContractState is the state of a contract. See <see
cref="M:SpaceCenter.Contract.State" />.
*/
type ContractState int32

const (
	// The contract is active.
	ContractState_Active ContractState = 0
	// The contract has been canceled.
	ContractState_Canceled ContractState = 1
	// The contract has been completed.
	ContractState_Completed ContractState = 2
	// The deadline for the contract has expired.
	ContractState_DeadlineExpired ContractState = 3
	// The contract has been declined.
	ContractState_Declined ContractState = 4
	// The contract has been failed.
	ContractState_Failed ContractState = 5
	// The contract has been generated.
	ContractState_Generated ContractState = 6
	// The contract has been offered to the player.
	ContractState_Offered ContractState = 7
	// The contract was offered to the player, but the offer expired.
	ContractState_OfferExpired ContractState = 8
	// The contract has been withdrawn.
	ContractState_Withdrawn ContractState = 9
)

// ControlInputMode is see <see cref="M:SpaceCenter.Control.InputMode" />.
type ControlInputMode int32

const (
	// Control inputs are added to the vessels current control inputs.
	ControlInputMode_Additive ControlInputMode = 0
	// Control inputs (when they are non-zero) override the vessels current control
	// inputs.
	ControlInputMode_Override ControlInputMode = 1
)

/*
ControlSource is the control source of a vessel. See <see
cref="M:SpaceCenter.Control.Source" />.
*/
type ControlSource int32

const (
	// Vessel is controlled by a Kerbal.
	ControlSource_Kerbal ControlSource = 0
	// Vessel is controlled by a probe core.
	ControlSource_Probe ControlSource = 1
	// Vessel is not controlled.
	ControlSource_None ControlSource = 2
)

/*
ControlState is the control state of a vessel. See <see
cref="M:SpaceCenter.Control.State" />.
*/
type ControlState int32

const (
	// Full controllable.
	ControlState_Full ControlState = 0
	// Partially controllable.
	ControlState_Partial ControlState = 1
	// Not controllable.
	ControlState_None ControlState = 2
)

/*
CrewMemberType is the type of a crew member. See <see
cref="M:SpaceCenter.CrewMember.Type" />.
*/
type CrewMemberType int32

const (
	// An applicant for crew.
	CrewMemberType_Applicant CrewMemberType = 0
	// Rocket crew.
	CrewMemberType_Crew CrewMemberType = 1
	// A tourist.
	CrewMemberType_Tourist CrewMemberType = 2
	// An unowned crew member.
	CrewMemberType_Unowned CrewMemberType = 3
)

// GameMode is the game mode. Returned by <see cref="T:SpaceCenter.GameMode" />
type GameMode int32

const (
	// Sandbox mode.
	GameMode_Sandbox GameMode = 0
	// Career mode.
	GameMode_Career GameMode = 1
	// Science career mode.
	GameMode_Science GameMode = 2
	// Science sandbox mode.
	GameMode_ScienceSandbox GameMode = 3
	// Mission mode.
	GameMode_Mission GameMode = 4
	// Mission builder mode.
	GameMode_MissionBuilder GameMode = 5
	// Scenario mode.
	GameMode_Scenario GameMode = 6
	// Scenario mode that cannot be resumed.
	GameMode_ScenarioNonResumable GameMode = 7
)

/*
AntennaState is the state of an antenna. See <see
cref="M:SpaceCenter.Antenna.State" />.
*/
type AntennaState int32

const (
	// Antenna is fully deployed.
	AntennaState_Deployed AntennaState = 0
	// Antenna is fully retracted.
	AntennaState_Retracted AntennaState = 1
	// Antenna is being deployed.
	AntennaState_Deploying AntennaState = 2
	// Antenna is being retracted.
	AntennaState_Retracting AntennaState = 3
	// Antenna is broken.
	AntennaState_Broken AntennaState = 4
)

/*
CargoBayState is the state of a cargo bay. See <see
cref="M:SpaceCenter.CargoBay.State" />.
*/
type CargoBayState int32

const (
	// Cargo bay is fully open.
	CargoBayState_Open CargoBayState = 0
	// Cargo bay closed and locked.
	CargoBayState_Closed CargoBayState = 1
	// Cargo bay is opening.
	CargoBayState_Opening CargoBayState = 2
	// Cargo bay is closing.
	CargoBayState_Closing CargoBayState = 3
)

/*
DockingPortState is the state of a docking port. See <see
cref="M:SpaceCenter.DockingPort.State" />.
*/
type DockingPortState int32

const (
	// The docking port is ready to dock to another docking port.
	DockingPortState_Ready DockingPortState = 0
	// The docking port is docked to another docking port, or docked to another part
	// (from the VAB/SPH).
	DockingPortState_Docked DockingPortState = 1
	// The docking port is very close to another docking port, but has not docked.
	// It is using magnetic force to acquire a solid dock.
	DockingPortState_Docking DockingPortState = 2
	// The docking port has just been undocked from another docking port, and is
	// disabled until it moves away by a sufficient distance (<see
	// cref="M:SpaceCenter.DockingPort.ReengageDistance" />).
	DockingPortState_Undocking DockingPortState = 3
	// The docking port has a shield, and the shield is closed.
	DockingPortState_Shielded DockingPortState = 4
	// The docking ports shield is currently opening/closing.
	DockingPortState_Moving DockingPortState = 5
)

/*
LegState is the state of a landing leg. See <see
cref="M:SpaceCenter.Leg.State" />.
*/
type LegState int32

const (
	// Landing leg is fully deployed.
	LegState_Deployed LegState = 0
	// Landing leg is fully retracted.
	LegState_Retracted LegState = 1
	// Landing leg is being deployed.
	LegState_Deploying LegState = 2
	// Landing leg is being retracted.
	LegState_Retracting LegState = 3
	// Landing leg is broken.
	LegState_Broken LegState = 4
)

/*
MotorState is the state of the motor on a powered wheel. See <see
cref="M:SpaceCenter.Wheel.MotorState" />.
*/
type MotorState int32

const (
	// The motor is idle.
	MotorState_Idle MotorState = 0
	// The motor is running.
	MotorState_Running MotorState = 1
	// The motor is disabled.
	MotorState_Disabled MotorState = 2
	// The motor is inoperable.
	MotorState_Inoperable MotorState = 3
	// The motor does not have enough resources to run.
	MotorState_NotEnoughResources MotorState = 4
)

/*
ParachuteState is the state of a parachute. See <see
cref="M:SpaceCenter.Parachute.State" />.
*/
type ParachuteState int32

const (
	// The parachute is safely tucked away inside its housing.
	ParachuteState_Stowed ParachuteState = 0
	// The parachute is armed for deployment. (RealChutes only)
	ParachuteState_Armed ParachuteState = 1
	// The parachute is still stowed, but ready to semi-deploy. (Stock parachutes
	// only)
	ParachuteState_Active ParachuteState = 2
	// The parachute has been deployed and is providing some drag, but is not fully
	// deployed yet. (Stock parachutes only)
	ParachuteState_SemiDeployed ParachuteState = 3
	// The parachute is fully deployed.
	ParachuteState_Deployed ParachuteState = 4
	// The parachute has been cut.
	ParachuteState_Cut ParachuteState = 5
)

/*
RadiatorState is the state of a radiator. <see
cref="T:SpaceCenter.RadiatorState" />
*/
type RadiatorState int32

const (
	// Radiator is fully extended.
	RadiatorState_Extended RadiatorState = 0
	// Radiator is fully retracted.
	RadiatorState_Retracted RadiatorState = 1
	// Radiator is being extended.
	RadiatorState_Extending RadiatorState = 2
	// Radiator is being retracted.
	RadiatorState_Retracting RadiatorState = 3
	// Radiator is being broken.
	RadiatorState_Broken RadiatorState = 4
)

/*
ResourceConverterState is the state of a resource converter. See <see
cref="M:SpaceCenter.ResourceConverter.State" />.
*/
type ResourceConverterState int32

const (
	// Converter is running.
	ResourceConverterState_Running ResourceConverterState = 0
	// Converter is idle.
	ResourceConverterState_Idle ResourceConverterState = 1
	// Converter is missing a required resource.
	ResourceConverterState_MissingResource ResourceConverterState = 2
	// No available storage for output resource.
	ResourceConverterState_StorageFull ResourceConverterState = 3
	// At preset resource capacity.
	ResourceConverterState_Capacity ResourceConverterState = 4
	// Unknown state. Possible with modified resource converters. In this case,
	// check <see cref="M:SpaceCenter.ResourceConverter.StatusInfo" /> for more
	// information.
	ResourceConverterState_Unknown ResourceConverterState = 5
)

/*
ResourceHarvesterState is the state of a resource harvester. See <see
cref="M:SpaceCenter.ResourceHarvester.State" />.
*/
type ResourceHarvesterState int32

const (
	// The drill is deploying.
	ResourceHarvesterState_Deploying ResourceHarvesterState = 0
	// The drill is deployed and ready.
	ResourceHarvesterState_Deployed ResourceHarvesterState = 1
	// The drill is retracting.
	ResourceHarvesterState_Retracting ResourceHarvesterState = 2
	// The drill is retracted.
	ResourceHarvesterState_Retracted ResourceHarvesterState = 3
	// The drill is running.
	ResourceHarvesterState_Active ResourceHarvesterState = 4
)

/*
SolarPanelState is the state of a solar panel. See <see
cref="M:SpaceCenter.SolarPanel.State" />.
*/
type SolarPanelState int32

const (
	// Solar panel is fully extended.
	SolarPanelState_Extended SolarPanelState = 0
	// Solar panel is fully retracted.
	SolarPanelState_Retracted SolarPanelState = 1
	// Solar panel is being extended.
	SolarPanelState_Extending SolarPanelState = 2
	// Solar panel is being retracted.
	SolarPanelState_Retracting SolarPanelState = 3
	// Solar panel is broken.
	SolarPanelState_Broken SolarPanelState = 4
)

/*
WheelState is the state of a wheel. See <see cref="M:SpaceCenter.Wheel.State"
/>.
*/
type WheelState int32

const (
	// Wheel is fully deployed.
	WheelState_Deployed WheelState = 0
	// Wheel is fully retracted.
	WheelState_Retracted WheelState = 1
	// Wheel is being deployed.
	WheelState_Deploying WheelState = 2
	// Wheel is being retracted.
	WheelState_Retracting WheelState = 3
	// Wheel is broken.
	WheelState_Broken WheelState = 4
)

/*
ResourceFlowMode is the way in which a resource flows between parts. See <see
cref="M:SpaceCenter.Resources.FlowMode" />.
*/
type ResourceFlowMode int32

const (
	// The resource flows to any part in the vessel. For example, electric charge.
	ResourceFlowMode_Vessel ResourceFlowMode = 0
	// The resource flows from parts in the first stage, followed by the second, and
	// so on. For example, mono-propellant.
	ResourceFlowMode_Stage ResourceFlowMode = 1
	// The resource flows between adjacent parts within the vessel. For example,
	// liquid fuel or oxidizer.
	ResourceFlowMode_Adjacent ResourceFlowMode = 2
	// The resource does not flow. For example, solid fuel.
	ResourceFlowMode_None ResourceFlowMode = 3
)

/*
SASMode is the behavior of the SAS auto-pilot. See <see
cref="M:SpaceCenter.AutoPilot.SASMode" />.
*/
type SASMode int32

const (
	// Stability assist mode. Dampen out any rotation.
	SASMode_StabilityAssist SASMode = 0
	// Point in the burn direction of the next maneuver node.
	SASMode_Maneuver SASMode = 1
	// Point in the prograde direction.
	SASMode_Prograde SASMode = 2
	// Point in the retrograde direction.
	SASMode_Retrograde SASMode = 3
	// Point in the orbit normal direction.
	SASMode_Normal SASMode = 4
	// Point in the orbit anti-normal direction.
	SASMode_AntiNormal SASMode = 5
	// Point in the orbit radial direction.
	SASMode_Radial SASMode = 6
	// Point in the orbit anti-radial direction.
	SASMode_AntiRadial SASMode = 7
	// Point in the direction of the current target.
	SASMode_Target SASMode = 8
	// Point away from the current target.
	SASMode_AntiTarget SASMode = 9
)

/*
SpeedMode is the mode of the speed reported in the navball. See <see
cref="M:SpaceCenter.Control.SpeedMode" />.
*/
type SpeedMode int32

const (
	// Speed is relative to the vessel's orbit.
	SpeedMode_Orbit SpeedMode = 0
	// Speed is relative to the surface of the body being orbited.
	SpeedMode_Surface SpeedMode = 1
	// Speed is relative to the current target.
	SpeedMode_Target SpeedMode = 2
)

/*
VesselSituation is the situation a vessel is in. See <see
cref="M:SpaceCenter.Vessel.Situation" />.
*/
type VesselSituation int32

const (
	// Vessel is awaiting launch.
	VesselSituation_PreLaunch VesselSituation = 0
	// Vessel is orbiting a body.
	VesselSituation_Orbiting VesselSituation = 1
	// Vessel is on a sub-orbital trajectory.
	VesselSituation_SubOrbital VesselSituation = 2
	// Escaping.
	VesselSituation_Escaping VesselSituation = 3
	// Vessel is flying through an atmosphere.
	VesselSituation_Flying VesselSituation = 4
	// Vessel is landed on the surface of a body.
	VesselSituation_Landed VesselSituation = 5
	// Vessel has splashed down in an ocean.
	VesselSituation_Splashed VesselSituation = 6
	// Vessel is docked to another.
	VesselSituation_Docked VesselSituation = 7
)

/*
VesselType is the type of a vessel. See <see cref="M:SpaceCenter.Vessel.Type"
/>.
*/
type VesselType int32

const (
	// Base.
	VesselType_Base VesselType = 0
	// Debris.
	VesselType_Debris VesselType = 1
	// Lander.
	VesselType_Lander VesselType = 2
	// Plane.
	VesselType_Plane VesselType = 3
	// Probe.
	VesselType_Probe VesselType = 4
	// Relay.
	VesselType_Relay VesselType = 5
	// Rover.
	VesselType_Rover VesselType = 6
	// Ship.
	VesselType_Ship VesselType = 7
	// Station.
	VesselType_Station VesselType = 8
)

/*
WarpMode is the time warp mode. Returned by <see
cref="T:SpaceCenter.WarpMode" />
*/
type WarpMode int32

const (
	// Time warp is active, and in regular "on-rails" mode.
	WarpMode_Rails WarpMode = 0
	// Time warp is active, and in physical time warp mode.
	WarpMode_Physics WarpMode = 1
	// Time warp is not active.
	WarpMode_None WarpMode = 2
)

// AutoPilot - provides basic auto-piloting utilities for a vessel. Created by
// calling <see cref="M:SpaceCenter.Vessel.AutoPilot" />.
type AutoPilot struct {
	service.BaseClass
}

// NewAutoPilot creates a new AutoPilot.
func NewAutoPilot(id uint64, client *client.KRPCClient) *AutoPilot {
	c := &AutoPilot{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Camera - controls the game's camera. Obtained by calling <see
// cref="M:SpaceCenter.Camera" />.
type Camera struct {
	service.BaseClass
}

// NewCamera creates a new Camera.
func NewCamera(id uint64, client *client.KRPCClient) *Camera {
	c := &Camera{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// CelestialBody - represents a celestial body (such as a planet or moon). See
// <see cref="M:SpaceCenter.Bodies" />.
type CelestialBody struct {
	service.BaseClass
}

// NewCelestialBody creates a new CelestialBody.
func NewCelestialBody(id uint64, client *client.KRPCClient) *CelestialBody {
	c := &CelestialBody{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// CommLink - represents a communication node in the network. For example, a
// vessel or the KSC.
type CommLink struct {
	service.BaseClass
}

// NewCommLink creates a new CommLink.
func NewCommLink(id uint64, client *client.KRPCClient) *CommLink {
	c := &CommLink{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// CommNode - represents a communication node in the network. For example, a
// vessel or the KSC.
type CommNode struct {
	service.BaseClass
}

// NewCommNode creates a new CommNode.
func NewCommNode(id uint64, client *client.KRPCClient) *CommNode {
	c := &CommNode{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Comms - used to interact with CommNet for a given vessel. Obtained by calling
// <see cref="M:SpaceCenter.Vessel.Comms" />.
type Comms struct {
	service.BaseClass
}

// NewComms creates a new Comms.
func NewComms(id uint64, client *client.KRPCClient) *Comms {
	c := &Comms{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Contract - a contract. Can be accessed using <see
// cref="M:SpaceCenter.ContractManager" />.
type Contract struct {
	service.BaseClass
}

// NewContract creates a new Contract.
func NewContract(id uint64, client *client.KRPCClient) *Contract {
	c := &Contract{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ContractManager - contracts manager. Obtained by calling <see
// cref="M:SpaceCenter.ContractManager" />.
type ContractManager struct {
	service.BaseClass
}

// NewContractManager creates a new ContractManager.
func NewContractManager(id uint64, client *client.KRPCClient) *ContractManager {
	c := &ContractManager{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ContractParameter - a contract parameter. See <see
// cref="M:SpaceCenter.Contract.Parameters" />.
type ContractParameter struct {
	service.BaseClass
}

// NewContractParameter creates a new ContractParameter.
func NewContractParameter(id uint64, client *client.KRPCClient) *ContractParameter {
	c := &ContractParameter{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Control - used to manipulate the controls of a vessel. This includes
// adjusting the throttle, enabling/disabling systems such as SAS and RCS, or
// altering the direction in which the vessel is pointing. Obtained by calling
// <see cref="M:SpaceCenter.Vessel.Control" />.
type Control struct {
	service.BaseClass
}

// NewControl creates a new Control.
func NewControl(id uint64, client *client.KRPCClient) *Control {
	c := &Control{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// CrewMember - represents crew in a vessel. Can be obtained using <see
// cref="M:SpaceCenter.Vessel.Crew" />.
type CrewMember struct {
	service.BaseClass
}

// NewCrewMember creates a new CrewMember.
func NewCrewMember(id uint64, client *client.KRPCClient) *CrewMember {
	c := &CrewMember{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Flight - used to get flight telemetry for a vessel, by calling <see
// cref="M:SpaceCenter.Vessel.Flight" />. All of the information returned by
// this class is given in the reference frame passed to that method. Obtained by
// calling <see cref="M:SpaceCenter.Vessel.Flight" />.
type Flight struct {
	service.BaseClass
}

// NewFlight creates a new Flight.
func NewFlight(id uint64, client *client.KRPCClient) *Flight {
	c := &Flight{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Node - represents a maneuver node. Can be created using <see
// cref="M:SpaceCenter.Control.AddNode" />.
type Node struct {
	service.BaseClass
}

// NewNode creates a new Node.
func NewNode(id uint64, client *client.KRPCClient) *Node {
	c := &Node{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Orbit - describes an orbit. For example, the orbit of a vessel, obtained by
// calling <see cref="M:SpaceCenter.Vessel.Orbit" />, or a celestial body,
// obtained by calling <see cref="M:SpaceCenter.CelestialBody.Orbit" />.
type Orbit struct {
	service.BaseClass
}

// NewOrbit creates a new Orbit.
func NewOrbit(id uint64, client *client.KRPCClient) *Orbit {
	c := &Orbit{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Antenna - an antenna. Obtained by calling <see
// cref="M:SpaceCenter.Part.Antenna" />.
type Antenna struct {
	service.BaseClass
}

// NewAntenna creates a new Antenna.
func NewAntenna(id uint64, client *client.KRPCClient) *Antenna {
	c := &Antenna{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// CargoBay - a cargo bay. Obtained by calling <see
// cref="M:SpaceCenter.Part.CargoBay" />.
type CargoBay struct {
	service.BaseClass
}

// NewCargoBay creates a new CargoBay.
func NewCargoBay(id uint64, client *client.KRPCClient) *CargoBay {
	c := &CargoBay{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ControlSurface - an aerodynamic control surface. Obtained by calling <see
// cref="M:SpaceCenter.Part.ControlSurface" />.
type ControlSurface struct {
	service.BaseClass
}

// NewControlSurface creates a new ControlSurface.
func NewControlSurface(id uint64, client *client.KRPCClient) *ControlSurface {
	c := &ControlSurface{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Decoupler - a decoupler. Obtained by calling <see
// cref="M:SpaceCenter.Part.Decoupler" />
type Decoupler struct {
	service.BaseClass
}

// NewDecoupler creates a new Decoupler.
func NewDecoupler(id uint64, client *client.KRPCClient) *Decoupler {
	c := &Decoupler{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// DockingPort - a docking port. Obtained by calling <see
// cref="M:SpaceCenter.Part.DockingPort" />
type DockingPort struct {
	service.BaseClass
}

// NewDockingPort creates a new DockingPort.
func NewDockingPort(id uint64, client *client.KRPCClient) *DockingPort {
	c := &DockingPort{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Engine - an engine, including ones of various types. For example liquid
// fuelled gimballed engines, solid rocket boosters and jet engines. Obtained by
// calling <see cref="M:SpaceCenter.Part.Engine" />.
type Engine struct {
	service.BaseClass
}

// NewEngine creates a new Engine.
func NewEngine(id uint64, client *client.KRPCClient) *Engine {
	c := &Engine{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Experiment - obtained by calling <see cref="M:SpaceCenter.Part.Experiment"
// />.
type Experiment struct {
	service.BaseClass
}

// NewExperiment creates a new Experiment.
func NewExperiment(id uint64, client *client.KRPCClient) *Experiment {
	c := &Experiment{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Fairing - a fairing. Obtained by calling <see
// cref="M:SpaceCenter.Part.Fairing" />. Supports both stock fairings, and those
// from the ProceduralFairings mod.
type Fairing struct {
	service.BaseClass
}

// NewFairing creates a new Fairing.
func NewFairing(id uint64, client *client.KRPCClient) *Fairing {
	c := &Fairing{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Force - obtained by calling <see cref="M:SpaceCenter.Part.AddForce" />.
type Force struct {
	service.BaseClass
}

// NewForce creates a new Force.
func NewForce(id uint64, client *client.KRPCClient) *Force {
	c := &Force{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Intake - an air intake. Obtained by calling <see
// cref="M:SpaceCenter.Part.Intake" />.
type Intake struct {
	service.BaseClass
}

// NewIntake creates a new Intake.
func NewIntake(id uint64, client *client.KRPCClient) *Intake {
	c := &Intake{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// LaunchClamp - a launch clamp. Obtained by calling <see
// cref="M:SpaceCenter.Part.LaunchClamp" />.
type LaunchClamp struct {
	service.BaseClass
}

// NewLaunchClamp creates a new LaunchClamp.
func NewLaunchClamp(id uint64, client *client.KRPCClient) *LaunchClamp {
	c := &LaunchClamp{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Leg - a landing leg. Obtained by calling <see cref="M:SpaceCenter.Part.Leg"
// />.
type Leg struct {
	service.BaseClass
}

// NewLeg creates a new Leg.
func NewLeg(id uint64, client *client.KRPCClient) *Leg {
	c := &Leg{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Light - a light. Obtained by calling <see cref="M:SpaceCenter.Part.Light" />.
type Light struct {
	service.BaseClass
}

// NewLight creates a new Light.
func NewLight(id uint64, client *client.KRPCClient) *Light {
	c := &Light{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Module - this can be used to interact with a specific part module. This
// includes part modules in stock KSP, and those added by mods.  In KSP, each
// part has zero or more <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation#MODULES">PartModules</a>
// associated with it. Each one contains some of the functionality of the part.
// For example, an engine has a "ModuleEngines" part module that contains all
// the functionality of an engine.
type Module struct {
	service.BaseClass
}

// NewModule creates a new Module.
func NewModule(id uint64, client *client.KRPCClient) *Module {
	c := &Module{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Parachute - a parachute. Obtained by calling <see
// cref="M:SpaceCenter.Part.Parachute" />.
type Parachute struct {
	service.BaseClass
}

// NewParachute creates a new Parachute.
func NewParachute(id uint64, client *client.KRPCClient) *Parachute {
	c := &Parachute{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Part - represents an individual part. Vessels are made up of multiple parts.
// Instances of this class can be obtained by several methods in <see
// cref="T:SpaceCenter.Parts" />.
type Part struct {
	service.BaseClass
}

// NewPart creates a new Part.
func NewPart(id uint64, client *client.KRPCClient) *Part {
	c := &Part{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Parts - instances of this class are used to interact with the parts of a
// vessel. An instance can be obtained by calling <see
// cref="M:SpaceCenter.Vessel.Parts" />.
type Parts struct {
	service.BaseClass
}

// NewParts creates a new Parts.
func NewParts(id uint64, client *client.KRPCClient) *Parts {
	c := &Parts{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Propellant - a propellant for an engine. Obtains by calling <see
// cref="M:SpaceCenter.Engine.Propellants" />.
type Propellant struct {
	service.BaseClass
}

// NewPropellant creates a new Propellant.
func NewPropellant(id uint64, client *client.KRPCClient) *Propellant {
	c := &Propellant{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// RCS - an RCS block or thruster. Obtained by calling <see
// cref="M:SpaceCenter.Part.RCS" />.
type RCS struct {
	service.BaseClass
}

// NewRCS creates a new RCS.
func NewRCS(id uint64, client *client.KRPCClient) *RCS {
	c := &RCS{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Radiator - a radiator. Obtained by calling <see
// cref="M:SpaceCenter.Part.Radiator" />.
type Radiator struct {
	service.BaseClass
}

// NewRadiator creates a new Radiator.
func NewRadiator(id uint64, client *client.KRPCClient) *Radiator {
	c := &Radiator{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ReactionWheel - a reaction wheel. Obtained by calling <see
// cref="M:SpaceCenter.Part.ReactionWheel" />.
type ReactionWheel struct {
	service.BaseClass
}

// NewReactionWheel creates a new ReactionWheel.
func NewReactionWheel(id uint64, client *client.KRPCClient) *ReactionWheel {
	c := &ReactionWheel{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ResourceConverter - a resource converter. Obtained by calling <see
// cref="M:SpaceCenter.Part.ResourceConverter" />.
type ResourceConverter struct {
	service.BaseClass
}

// NewResourceConverter creates a new ResourceConverter.
func NewResourceConverter(id uint64, client *client.KRPCClient) *ResourceConverter {
	c := &ResourceConverter{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ResourceHarvester - a resource harvester (drill). Obtained by calling <see
// cref="M:SpaceCenter.Part.ResourceHarvester" />.
type ResourceHarvester struct {
	service.BaseClass
}

// NewResourceHarvester creates a new ResourceHarvester.
func NewResourceHarvester(id uint64, client *client.KRPCClient) *ResourceHarvester {
	c := &ResourceHarvester{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// RoboticController - a robotic controller. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticController" />.
type RoboticController struct {
	service.BaseClass
}

// NewRoboticController creates a new RoboticController.
func NewRoboticController(id uint64, client *client.KRPCClient) *RoboticController {
	c := &RoboticController{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ScienceData - obtained by calling <see cref="M:SpaceCenter.Experiment.Data"
// />.
type ScienceData struct {
	service.BaseClass
}

// NewScienceData creates a new ScienceData.
func NewScienceData(id uint64, client *client.KRPCClient) *ScienceData {
	c := &ScienceData{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ScienceSubject - obtained by calling <see
// cref="M:SpaceCenter.Experiment.ScienceSubject" />.
type ScienceSubject struct {
	service.BaseClass
}

// NewScienceSubject creates a new ScienceSubject.
func NewScienceSubject(id uint64, client *client.KRPCClient) *ScienceSubject {
	c := &ScienceSubject{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Sensor - a sensor, such as a thermometer. Obtained by calling <see
// cref="M:SpaceCenter.Part.Sensor" />.
type Sensor struct {
	service.BaseClass
}

// NewSensor creates a new Sensor.
func NewSensor(id uint64, client *client.KRPCClient) *Sensor {
	c := &Sensor{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// SolarPanel - a solar panel. Obtained by calling <see
// cref="M:SpaceCenter.Part.SolarPanel" />.
type SolarPanel struct {
	service.BaseClass
}

// NewSolarPanel creates a new SolarPanel.
func NewSolarPanel(id uint64, client *client.KRPCClient) *SolarPanel {
	c := &SolarPanel{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Thruster - the component of an <see cref="T:SpaceCenter.Engine" /> or <see
// cref="T:SpaceCenter.RCS" /> part that generates thrust. Can obtained by
// calling <see cref="M:SpaceCenter.Engine.Thrusters" /> or <see
// cref="M:SpaceCenter.RCS.Thrusters" />.
type Thruster struct {
	service.BaseClass
}

// NewThruster creates a new Thruster.
func NewThruster(id uint64, client *client.KRPCClient) *Thruster {
	c := &Thruster{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Wheel - a wheel. Includes landing gear and rover wheels. Obtained by calling
// <see cref="M:SpaceCenter.Part.Wheel" />. Can be used to control the motors,
// steering and deployment of wheels, among other things.
type Wheel struct {
	service.BaseClass
}

// NewWheel creates a new Wheel.
func NewWheel(id uint64, client *client.KRPCClient) *Wheel {
	c := &Wheel{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ReferenceFrame - represents a reference frame for positions, rotations and
// velocities. Contains: <list type="bullet"><item><description>The position of
// the origin.</description></item><item><description>The directions of the x, y
// and z axes.</description></item><item><description>The linear velocity of the
// frame.</description></item><item><description>The angular velocity of the
// frame.</description></item></list>
type ReferenceFrame struct {
	service.BaseClass
}

// NewReferenceFrame creates a new ReferenceFrame.
func NewReferenceFrame(id uint64, client *client.KRPCClient) *ReferenceFrame {
	c := &ReferenceFrame{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Resource - an individual resource stored within a part. Created using methods
// in the <see cref="T:SpaceCenter.Resources" /> class.
type Resource struct {
	service.BaseClass
}

// NewResource creates a new Resource.
func NewResource(id uint64, client *client.KRPCClient) *Resource {
	c := &Resource{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ResourceTransfer - transfer resources between parts.
type ResourceTransfer struct {
	service.BaseClass
}

// NewResourceTransfer creates a new ResourceTransfer.
func NewResourceTransfer(id uint64, client *client.KRPCClient) *ResourceTransfer {
	c := &ResourceTransfer{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Resources - represents the collection of resources stored in a vessel, stage
// or part. Created by calling <see cref="M:SpaceCenter.Vessel.Resources" />,
// <see cref="M:SpaceCenter.Vessel.ResourcesInDecoupleStage" /> or <see
// cref="M:SpaceCenter.Part.Resources" />.
type Resources struct {
	service.BaseClass
}

// NewResources creates a new Resources.
func NewResources(id uint64, client *client.KRPCClient) *Resources {
	c := &Resources{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Vessel - these objects are used to interact with vessels in KSP. This
// includes getting orbital and flight data, manipulating control inputs and
// managing resources. Created using <see cref="M:SpaceCenter.ActiveVessel" />
// or <see cref="M:SpaceCenter.Vessels" />.
type Vessel struct {
	service.BaseClass
}

// NewVessel creates a new Vessel.
func NewVessel(id uint64, client *client.KRPCClient) *Vessel {
	c := &Vessel{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Waypoint - represents a waypoint. Can be created using <see
// cref="M:SpaceCenter.WaypointManager.AddWaypoint" />.
type Waypoint struct {
	service.BaseClass
}

// NewWaypoint creates a new Waypoint.
func NewWaypoint(id uint64, client *client.KRPCClient) *Waypoint {
	c := &Waypoint{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// WaypointManager - waypoints are the location markers you can see on the map
// view showing you where contracts are targeted for. With this structure, you
// can obtain coordinate data for the locations of these waypoints. Obtained by
// calling <see cref="M:SpaceCenter.WaypointManager" />.
type WaypointManager struct {
	service.BaseClass
}

// NewWaypointManager creates a new WaypointManager.
func NewWaypointManager(id uint64, client *client.KRPCClient) *WaypointManager {
	c := &WaypointManager{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// SpaceCenter - provides functionality to interact with Kerbal Space Program.
// This includes controlling the active vessel, managing its resources, planning
// maneuver nodes and auto-piloting.
type SpaceCenter struct {
	Client *client.KRPCClient
}

// NewSpaceCenter creates a new SpaceCenter.
func NewSpaceCenter(client *client.KRPCClient) *SpaceCenter {
	return &SpaceCenter{Client: client}
}

// ClearTarget will clears the current target.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ClearTarget() error {
	var err error
	request := &api.ProcedureCall{
		Procedure: "ClearTarget",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchableVessels will returns a list of vessels from the given <paramref
// name="craftDirectory" /> that can be launched.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchableVessels(craftDirectory string) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "LaunchableVessels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLaunchableVessels will returns a list of vessels from the given
// <paramref name="craftDirectory" /> that can be launched.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamLaunchableVessels(craftDirectory string) (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchableVessels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LaunchVessel will launch a vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVessel(craftDirectory string, name string, launchSite string, recover bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(launchSite)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchVesselFromVAB will launch a new vessel from the VAB onto the launchpad.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVesselFromVAB(name string, recover bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchVesselFromVAB",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchVesselFromSPH will launch a new vessel from the SPH onto the runway.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVesselFromSPH(name string, recover bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchVesselFromSPH",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Save will save the game with a given name. This will create a save file
// called name.sfs in the folder of the current save game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Save(name string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Save",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Load will load the game with the given name. This will create a load a save
// file called name.sfs from the folder of the current save game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Load(name string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Load",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Quicksave will save a quicksave.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Quicksave() error {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Quicksave",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Quickload will load a quicksave.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Quickload() error {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Quickload",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanRailsWarpAt will returns true if regular "on-rails" time warp can be used,
// at the specified warp <paramref name="factor" />. The maximum time warp rate
// is limited by various things, including how close the active vessel is to a
// planet. See <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the
// KSP wiki</a> for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CanRailsWarpAt(factor int32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CanRailsWarpAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(factor)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanRailsWarpAt will returns true if regular "on-rails" time warp can be
// used, at the specified warp <paramref name="factor" />. The maximum time warp
// rate is limited by various things, including how close the active vessel is
// to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamCanRailsWarpAt(factor int32) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CanRailsWarpAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(factor)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WarpTo will uses time acceleration to warp forward to a time in the future,
// specified by universal time <paramref name="ut" />. This call blocks until
// the desired time is reached. Uses regular "on-rails" or physical time warp as
// appropriate. For example, physical time warp is used when the active vessel
// is traveling through an atmosphere. When using regular "on-rails" time warp,
// the warp rate is limited by <paramref name="maxRailsRate" />, and when using
// physical time warp, the warp rate is limited by <paramref
// name="maxPhysicsRate" />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpTo(ut float64, maxRailsRate float32, maxPhysicsRate float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WarpTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxRailsRate)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxPhysicsRate)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TransformPosition will converts a position from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformPosition(position api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "TransformPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTransformPosition will converts a position from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTransformPosition(position api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "TransformPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TransformDirection will converts a direction from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformDirection(direction api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "TransformDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTransformDirection will converts a direction from one reference frame
// to another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTransformDirection(direction api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "TransformDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TransformRotation will converts a rotation from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformRotation(rotation api.Tuple4[float64, float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "TransformRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTransformRotation will converts a rotation from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTransformRotation(rotation api.Tuple4[float64, float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "TransformRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TransformVelocity will converts a velocity (acting at the specified position)
// from one reference frame to another. The position is required to take the
// relative angular velocity of the reference frames into account.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformVelocity(position api.Tuple3[float64, float64, float64], velocity api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "TransformVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTransformVelocity will converts a velocity (acting at the specified
// position) from one reference frame to another. The position is required to
// take the relative angular velocity of the reference frames into account.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTransformVelocity(position api.Tuple3[float64, float64, float64], velocity api.Tuple3[float64, float64, float64], from ReferenceFrame, to ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "TransformVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RaycastDistance will cast a ray from a given position in a given direction,
// and return the distance to the hit point. If no hit occurs, returns infinity.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RaycastDistance(position api.Tuple3[float64, float64, float64], direction api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "RaycastDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRaycastDistance will cast a ray from a given position in a given
// direction, and return the distance to the hit point. If no hit occurs,
// returns infinity.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamRaycastDistance(position api.Tuple3[float64, float64, float64], direction api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RaycastDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RaycastPart will cast a ray from a given position in a given direction, and
// return the part that it hits. If no hit occurs, returns nil.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RaycastPart(position api.Tuple3[float64, float64, float64], direction api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "RaycastPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRaycastPart will cast a ray from a given position in a given direction,
// and return the part that it hits. If no hit occurs, returns nil.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamRaycastPart(position api.Tuple3[float64, float64, float64], direction api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RaycastPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GameMode will the current mode the game is in.
//
// Allowed game scenes: any.
func (s *SpaceCenter) GameMode() (GameMode, error) {
	var err error
	var vv GameMode
	request := &api.ProcedureCall{
		Procedure: "get_GameMode",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGameMode will the current mode the game is in.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamGameMode() (*client.Stream[GameMode], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_GameMode",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) GameMode {
		var value GameMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Science will the current amount of science.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Science() (float32, error) {
	var err error
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "get_Science",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScience will the current amount of science.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamScience() (*client.Stream[float32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Science",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Funds will the current amount of funds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Funds() (float64, error) {
	var err error
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "get_Funds",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFunds will the current amount of funds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamFunds() (*client.Stream[float64], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Funds",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Reputation will the current amount of reputation.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Reputation() (float32, error) {
	var err error
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "get_Reputation",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReputation will the current amount of reputation.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamReputation() (*client.Stream[float32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Reputation",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ActiveVessel will the currently active vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ActiveVessel() (Vessel, error) {
	var err error
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "get_ActiveVessel",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActiveVessel will the currently active vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamActiveVessel() (*client.Stream[Vessel], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_ActiveVessel",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActiveVessel will the currently active vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetActiveVessel(value Vessel) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_ActiveVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Vessels will a list of all the vessels in the game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Vessels() ([]Vessel, error) {
	var err error
	var vv []Vessel
	request := &api.ProcedureCall{
		Procedure: "get_Vessels",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVessels will a list of all the vessels in the game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamVessels() (*client.Stream[[]Vessel], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Vessels",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Vessel {
		var value []Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Bodies will a dictionary of all celestial bodies (planets, moons, etc.) in
// the game, keyed by the name of the body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Bodies() (map[string]CelestialBody, error) {
	var err error
	var vv map[string]CelestialBody
	request := &api.ProcedureCall{
		Procedure: "get_Bodies",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBodies will a dictionary of all celestial bodies (planets, moons, etc.)
// in the game, keyed by the name of the body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamBodies() (*client.Stream[map[string]CelestialBody], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Bodies",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]CelestialBody {
		var value map[string]CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TargetBody will the currently targeted celestial body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetBody() (CelestialBody, error) {
	var err error
	var vv CelestialBody
	request := &api.ProcedureCall{
		Procedure: "get_TargetBody",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetBody will the currently targeted celestial body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTargetBody() (*client.Stream[CelestialBody], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_TargetBody",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CelestialBody {
		var value CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetBody will the currently targeted celestial body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetBody(value CelestialBody) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_TargetBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetVessel will the currently targeted vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetVessel() (Vessel, error) {
	var err error
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "get_TargetVessel",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetVessel will the currently targeted vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTargetVessel() (*client.Stream[Vessel], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_TargetVessel",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetVessel will the currently targeted vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetVessel(value Vessel) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_TargetVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetDockingPort will the currently targeted docking port.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetDockingPort() (DockingPort, error) {
	var err error
	var vv DockingPort
	request := &api.ProcedureCall{
		Procedure: "get_TargetDockingPort",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetDockingPort will the currently targeted docking port.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamTargetDockingPort() (*client.Stream[DockingPort], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_TargetDockingPort",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) DockingPort {
		var value DockingPort
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetDockingPort will the currently targeted docking port.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetDockingPort(value DockingPort) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_TargetDockingPort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WaypointManager will the waypoint manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WaypointManager() (WaypointManager, error) {
	var err error
	var vv WaypointManager
	request := &api.ProcedureCall{
		Procedure: "get_WaypointManager",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWaypointManager will the waypoint manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamWaypointManager() (*client.Stream[WaypointManager], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_WaypointManager",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) WaypointManager {
		var value WaypointManager
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ContractManager will the contract manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ContractManager() (ContractManager, error) {
	var err error
	var vv ContractManager
	request := &api.ProcedureCall{
		Procedure: "get_ContractManager",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamContractManager will the contract manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamContractManager() (*client.Stream[ContractManager], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_ContractManager",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ContractManager {
		var value ContractManager
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Camera will an object that can be used to control the camera.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Camera() (Camera, error) {
	var err error
	var vv Camera
	request := &api.ProcedureCall{
		Procedure: "get_Camera",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCamera will an object that can be used to control the camera.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamCamera() (*client.Stream[Camera], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Camera",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Camera {
		var value Camera
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// UIVisible will whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UIVisible() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_UIVisible",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUIVisible will whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamUIVisible() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_UIVisible",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetUIVisible will whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetUIVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_UIVisible",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Navball will whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Navball() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_Navball",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNavball will whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamNavball() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Navball",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetNavball will whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetNavball(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_Navball",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// UT will the current universal time in seconds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UT() (float64, error) {
	var err error
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "get_UT",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUT will the current universal time in seconds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamUT() (*client.Stream[float64], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_UT",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// G will the value of the <a
// href="https://en.wikipedia.org/wiki/Gravitational_constant"> gravitational
// constant</a> G in <math>N(m/kg)^2</math>.
//
// Allowed game scenes: any.
func (s *SpaceCenter) G() (float64, error) {
	var err error
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "get_G",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamG will the value of the <a
// href="https://en.wikipedia.org/wiki/Gravitational_constant"> gravitational
// constant</a> G in <math>N(m/kg)^2</math>.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamG() (*client.Stream[float64], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_G",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WarpMode will the current time warp mode. Returns <see
// cref="M:SpaceCenter.WarpMode.None" /> if time warp is not active, <see
// cref="M:SpaceCenter.WarpMode.Rails" /> if regular "on-rails" time warp is
// active, or <see cref="M:SpaceCenter.WarpMode.Physics" /> if physical time
// warp is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpMode() (WarpMode, error) {
	var err error
	var vv WarpMode
	request := &api.ProcedureCall{
		Procedure: "get_WarpMode",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWarpMode will the current time warp mode. Returns <see
// cref="M:SpaceCenter.WarpMode.None" /> if time warp is not active, <see
// cref="M:SpaceCenter.WarpMode.Rails" /> if regular "on-rails" time warp is
// active, or <see cref="M:SpaceCenter.WarpMode.Physics" /> if physical time
// warp is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamWarpMode() (*client.Stream[WarpMode], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_WarpMode",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) WarpMode {
		var value WarpMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WarpRate will the current warp rate. This is the rate at which time is
// passing for either on-rails or physical time warp. For example, a value of 10
// means time is passing 10x faster than normal. Returns 1 if time warp is not
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpRate() (float32, error) {
	var err error
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "get_WarpRate",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWarpRate will the current warp rate. This is the rate at which time is
// passing for either on-rails or physical time warp. For example, a value of 10
// means time is passing 10x faster than normal. Returns 1 if time warp is not
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamWarpRate() (*client.Stream[float32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_WarpRate",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WarpFactor will the current warp factor. This is the index of the rate at
// which time is passing for either regular "on-rails" or physical time warp.
// Returns 0 if time warp is not active. When in on-rails time warp, this is
// equal to <see cref="M:SpaceCenter.RailsWarpFactor" />, and in physics time
// warp, this is equal to <see cref="M:SpaceCenter.PhysicsWarpFactor" />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpFactor() (float32, error) {
	var err error
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "get_WarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWarpFactor will the current warp factor. This is the index of the rate
// at which time is passing for either regular "on-rails" or physical time warp.
// Returns 0 if time warp is not active. When in on-rails time warp, this is
// equal to <see cref="M:SpaceCenter.RailsWarpFactor" />, and in physics time
// warp, this is equal to <see cref="M:SpaceCenter.PhysicsWarpFactor" />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamWarpFactor() (*client.Stream[float32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_WarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RailsWarpFactor will the time warp rate, using regular "on-rails" time warp.
// A value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if
// physical time warp is active.  If requested time warp factor cannot be set,
// it will be set to the next lowest possible value. For example, if the vessel
// is too close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RailsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "get_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRailsWarpFactor will the time warp rate, using regular "on-rails" time
// warp. A value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if
// physical time warp is active.  If requested time warp factor cannot be set,
// it will be set to the next lowest possible value. For example, if the vessel
// is too close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamRailsWarpFactor() (*client.Stream[int32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRailsWarpFactor will the time warp rate, using regular "on-rails" time
// warp. A value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if
// physical time warp is active.  If requested time warp factor cannot be set,
// it will be set to the next lowest possible value. For example, if the vessel
// is too close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetRailsWarpFactor(value int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PhysicsWarpFactor will the physical time warp rate. A value between 0 and 3
// inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time warp is
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) PhysicsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "get_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPhysicsWarpFactor will the physical time warp rate. A value between 0
// and 3 inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time
// warp is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamPhysicsWarpFactor() (*client.Stream[int32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPhysicsWarpFactor will the physical time warp rate. A value between 0 and
// 3 inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time warp
// is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetPhysicsWarpFactor(value int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MaximumRailsWarpFactor will the current maximum regular "on-rails" warp
// factor that can be set. A value between 0 and 7 inclusive. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) MaximumRailsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "get_MaximumRailsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaximumRailsWarpFactor will the current maximum regular "on-rails" warp
// factor that can be set. A value between 0 and 7 inclusive. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamMaximumRailsWarpFactor() (*client.Stream[int32], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_MaximumRailsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FARAvailable will whether <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram
// Aerospace Research</a> is installed.
//
// Allowed game scenes: any.
func (s *SpaceCenter) FARAvailable() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_FARAvailable",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFARAvailable will whether <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram
// Aerospace Research</a> is installed.
//
// Allowed game scenes: any.
func (s *SpaceCenter) StreamFARAvailable() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_FARAvailable",
		Service:   "SpaceCenter",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Engage will engage the auto-pilot.
//
// Allowed game scenes: any.
func (s *AutoPilot) Engage() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_Engage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Disengage will disengage the auto-pilot.
//
// Allowed game scenes: any.
func (s *AutoPilot) Disengage() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_Disengage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Wait will blocks until the vessel is pointing in the target direction and has
// the target roll (if set). Throws an exception if the auto-pilot has not been
// engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) Wait() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_Wait",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetPitchAndHeading will set target pitch and heading angles.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetPitchAndHeading(pitch float32, heading float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_TargetPitchAndHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pitch)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(heading)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Error will the error, in degrees, between the direction the ship has been
// asked to point in and the direction it is pointing in. Throws an exception if
// the auto-pilot has not been engaged and SAS is not enabled or is in stability
// assist mode.
//
// Allowed game scenes: any.
func (s *AutoPilot) Error() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_Error",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamError will the error, in degrees, between the direction the ship has
// been asked to point in and the direction it is pointing in. Throws an
// exception if the auto-pilot has not been engaged and SAS is not enabled or is
// in stability assist mode.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamError() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_Error",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PitchError will the error, in degrees, between the vessels current and target
// pitch. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_PitchError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitchError will the error, in degrees, between the vessels current and
// target pitch. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamPitchError() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_PitchError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HeadingError will the error, in degrees, between the vessels current and
// target heading. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) HeadingError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_HeadingError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHeadingError will the error, in degrees, between the vessels current
// and target heading. Throws an exception if the auto-pilot has not been
// engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamHeadingError() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_HeadingError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RollError will the error, in degrees, between the vessels current and target
// roll. Throws an exception if the auto-pilot has not been engaged or no target
// roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRollError will the error, in degrees, between the vessels current and
// target roll. Throws an exception if the auto-pilot has not been engaged or no
// target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamRollError() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferenceFrame will the reference frame for the target direction (<see
// cref="M:SpaceCenter.AutoPilot.TargetDirection" />).
//
// Allowed game scenes: any.
func (s *AutoPilot) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame for the target direction (<see
// cref="M:SpaceCenter.AutoPilot.TargetDirection" />).
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReferenceFrame will the reference frame for the target direction (<see
// cref="M:SpaceCenter.AutoPilot.TargetDirection" />).
//
// Allowed game scenes: any.
func (s *AutoPilot) SetReferenceFrame(value ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetPitch will the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetPitch will the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamTargetPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetPitch will the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetHeading will the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetHeading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetHeading will the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamTargetHeading() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetHeading will the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetHeading(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetRoll will the target roll, in degrees. NaN if no target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetRoll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetRoll will the target roll, in degrees. NaN if no target roll is
// set.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamTargetRoll() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetRoll will the target roll, in degrees. NaN if no target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetRoll(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetDirection will direction vector corresponding to the target pitch and
// heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetDirection() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTargetDirection will direction vector corresponding to the target pitch
// and heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamTargetDirection() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTargetDirection will direction vector corresponding to the target pitch
// and heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetDirection(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *AutoPilot) SAS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamSAS() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetSAS(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SASMode will the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) SASMode() (SASMode, error) {
	var err error
	var argBytes []byte
	var vv SASMode
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSASMode will the current <see cref="T:SpaceCenter.SASMode" />. These
// modes are equivalent to the mode buttons to the left of the navball that
// appear when SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamSASMode() (*client.Stream[SASMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) SASMode {
		var value SASMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSASMode will the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetSASMode(value SASMode) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollThreshold will the threshold at which the autopilot will try to match the
// target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollThreshold() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRollThreshold will the threshold at which the autopilot will try to
// match the target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamRollThreshold() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRollThreshold will the threshold at which the autopilot will try to match
// the target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetRollThreshold(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// StoppingTime will the maximum amount of time that the vessel should need to
// come to a complete stop. This determines the maximum angular velocity of the
// vessel. A vector of three stopping times, in seconds, one for each of the
// pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StoppingTime() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStoppingTime will the maximum amount of time that the vessel should
// need to come to a complete stop. This determines the maximum angular velocity
// of the vessel. A vector of three stopping times, in seconds, one for each of
// the pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamStoppingTime() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetStoppingTime will the maximum amount of time that the vessel should need
// to come to a complete stop. This determines the maximum angular velocity of
// the vessel. A vector of three stopping times, in seconds, one for each of the
// pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetStoppingTime(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DecelerationTime will the time the vessel should take to come to a stop
// pointing in the target direction. This determines the angular acceleration
// used to decelerate the vessel. A vector of three times, in seconds, one for
// each of the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) DecelerationTime() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecelerationTime will the time the vessel should take to come to a stop
// pointing in the target direction. This determines the angular acceleration
// used to decelerate the vessel. A vector of three times, in seconds, one for
// each of the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamDecelerationTime() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDecelerationTime will the time the vessel should take to come to a stop
// pointing in the target direction. This determines the angular acceleration
// used to decelerate the vessel. A vector of three times, in seconds, one for
// each of the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetDecelerationTime(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AttenuationAngle will the angle at which the autopilot considers the vessel
// to be pointing close to the target. This determines the midpoint of the
// target velocity attenuation function. A vector of three angles, in degrees,
// one for each of the pitch, roll and yaw axes. Defaults to 1° for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) AttenuationAngle() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAttenuationAngle will the angle at which the autopilot considers the
// vessel to be pointing close to the target. This determines the midpoint of
// the target velocity attenuation function. A vector of three angles, in
// degrees, one for each of the pitch, roll and yaw axes. Defaults to 1° for
// each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamAttenuationAngle() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAttenuationAngle will the angle at which the autopilot considers the
// vessel to be pointing close to the target. This determines the midpoint of
// the target velocity attenuation function. A vector of three angles, in
// degrees, one for each of the pitch, roll and yaw axes. Defaults to 1° for
// each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetAttenuationAngle(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AutoTune will whether the rotation rate controllers PID parameters should be
// automatically tuned using the vessels moment of inertia and available torque.
// Defaults to true. See <see cref="M:SpaceCenter.AutoPilot.TimeToPeak" /> and
// <see cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) AutoTune() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAutoTune will whether the rotation rate controllers PID parameters
// should be automatically tuned using the vessels moment of inertia and
// available torque. Defaults to true. See <see
// cref="M:SpaceCenter.AutoPilot.TimeToPeak" /> and <see
// cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamAutoTune() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAutoTune will whether the rotation rate controllers PID parameters should
// be automatically tuned using the vessels moment of inertia and available
// torque. Defaults to true. See <see cref="M:SpaceCenter.AutoPilot.TimeToPeak"
// /> and <see cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetAutoTune(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TimeToPeak will the target time to peak used to autotune the PID controllers.
// A vector of three times, in seconds, for each of the pitch, roll and yaw
// axes. Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) TimeToPeak() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeToPeak will the target time to peak used to autotune the PID
// controllers. A vector of three times, in seconds, for each of the pitch, roll
// and yaw axes. Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamTimeToPeak() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTimeToPeak will the target time to peak used to autotune the PID
// controllers. A vector of three times, in seconds, for each of the pitch, roll
// and yaw axes. Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTimeToPeak(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Overshoot will the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) Overshoot() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOvershoot will the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamOvershoot() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetOvershoot will the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetOvershoot(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PitchPIDGains will gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchPIDGains() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitchPIDGains will gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamPitchPIDGains() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPitchPIDGains will gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetPitchPIDGains(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollPIDGains will gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollPIDGains() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRollPIDGains will gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamRollPIDGains() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRollPIDGains will gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetRollPIDGains(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawPIDGains will gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) YawPIDGains() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamYawPIDGains will gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) StreamYawPIDGains() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_get_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetYawPIDGains will gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetYawPIDGains(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AutoPilot_set_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Mode will the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) Mode() (CameraMode, error) {
	var err error
	var argBytes []byte
	var vv CameraMode
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMode will the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) StreamMode() (*client.Stream[CameraMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CameraMode {
		var value CameraMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMode will the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) SetMode(value CameraMode) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Pitch will the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitch" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitch" />
//
// Allowed game scenes: any.
func (s *Camera) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitch will the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitch" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitch" />
//
// Allowed game scenes: any.
func (s *Camera) StreamPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPitch will the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitch" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitch" />
//
// Allowed game scenes: any.
func (s *Camera) SetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Heading will the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) Heading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHeading will the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) StreamHeading() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetHeading will the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) SetHeading(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Distance will the distance from the camera to the subject, in meters. A value
// between <see cref="M:SpaceCenter.Camera.MinDistance" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistance" />.
//
// Allowed game scenes: any.
func (s *Camera) Distance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDistance will the distance from the camera to the subject, in meters. A
// value between <see cref="M:SpaceCenter.Camera.MinDistance" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistance" />.
//
// Allowed game scenes: any.
func (s *Camera) StreamDistance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDistance will the distance from the camera to the subject, in meters. A
// value between <see cref="M:SpaceCenter.Camera.MinDistance" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistance" />.
//
// Allowed game scenes: any.
func (s *Camera) SetDistance(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MinPitch will the minimum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MinPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MinPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMinPitch will the minimum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) StreamMinPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MinPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxPitch will the maximum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MaxPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MaxPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxPitch will the maximum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) StreamMaxPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MaxPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MinDistance will minimum distance from the camera to the subject, in meters.
//
// Allowed game scenes: any.
func (s *Camera) MinDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MinDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMinDistance will minimum distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) StreamMinDistance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MinDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxDistance will maximum distance from the camera to the subject, in meters.
//
// Allowed game scenes: any.
func (s *Camera) MaxDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MaxDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxDistance will maximum distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) StreamMaxDistance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_MaxDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DefaultDistance will default distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) DefaultDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Camera_get_DefaultDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDefaultDistance will default distance from the camera to the subject,
// in meters.
//
// Allowed game scenes: any.
func (s *Camera) StreamDefaultDistance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_DefaultDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FocussedBody will in map mode, the celestial body that the camera is focussed
// on. Returns nil if the camera is not focussed on a celestial body. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedBody() (CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFocussedBody will in map mode, the celestial body that the camera is
// focussed on. Returns nil if the camera is not focussed on a celestial body.
// Returns an error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) StreamFocussedBody() (*client.Stream[CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CelestialBody {
		var value CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetFocussedBody will in map mode, the celestial body that the camera is
// focussed on. Returns nil if the camera is not focussed on a celestial body.
// Returns an error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedBody(value CelestialBody) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_FocussedBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// FocussedVessel will in map mode, the vessel that the camera is focussed on.
// Returns nil if the camera is not focussed on a vessel. Returns an error is
// the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedVessel() (Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFocussedVessel will in map mode, the vessel that the camera is focussed
// on. Returns nil if the camera is not focussed on a vessel. Returns an error
// is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) StreamFocussedVessel() (*client.Stream[Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetFocussedVessel will in map mode, the vessel that the camera is focussed
// on. Returns nil if the camera is not focussed on a vessel. Returns an error
// is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedVessel(value Vessel) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_FocussedVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// FocussedNode will in map mode, the maneuver node that the camera is focussed
// on. Returns nil if the camera is not focussed on a maneuver node. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedNode() (Node, error) {
	var err error
	var argBytes []byte
	var vv Node
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFocussedNode will in map mode, the maneuver node that the camera is
// focussed on. Returns nil if the camera is not focussed on a maneuver node.
// Returns an error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) StreamFocussedNode() (*client.Stream[Node], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_get_FocussedNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Node {
		var value Node
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetFocussedNode will in map mode, the maneuver node that the camera is
// focussed on. Returns nil if the camera is not focussed on a maneuver node.
// Returns an error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedNode(value Node) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Camera_set_FocussedNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceHeight will the height of the surface relative to mean sea level, in
// meters, at the given position. When over water this is equal to 0.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceHeight(latitude float64, longitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_SurfaceHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceHeight will the height of the surface relative to mean sea
// level, in meters, at the given position. When over water this is equal to 0.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSurfaceHeight(latitude float64, longitude float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_SurfaceHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BedrockHeight will the height of the surface relative to mean sea level, in
// meters, at the given position. When over water, this is the height of the
// sea-bed and is therefore  negative value.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockHeight(latitude float64, longitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BedrockHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBedrockHeight will the height of the surface relative to mean sea
// level, in meters, at the given position. When over water, this is the height
// of the sea-bed and is therefore  negative value.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamBedrockHeight(latitude float64, longitude float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BedrockHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MSLPosition will the position at mean sea level at the given latitude and
// longitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) MSLPosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_MSLPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMSLPosition will the position at mean sea level at the given latitude
// and longitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamMSLPosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_MSLPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SurfacePosition will the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position of the surface of the water.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfacePosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_SurfacePosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfacePosition will the position of the surface at the given latitude
// and longitude, in the given reference frame. When over water, this is the
// position of the surface of the water.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSurfacePosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_SurfacePosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BedrockPosition will the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position at the bottom of the sea-bed.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockPosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BedrockPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBedrockPosition will the position of the surface at the given latitude
// and longitude, in the given reference frame. When over water, this is the
// position at the bottom of the sea-bed.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamBedrockPosition(latitude float64, longitude float64, referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BedrockPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PositionAtAltitude will the position at the given latitude, longitude and
// altitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) PositionAtAltitude(latitude float64, longitude float64, altitude float64, referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_PositionAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPositionAtAltitude will the position at the given latitude, longitude
// and altitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamPositionAtAltitude(latitude float64, longitude float64, altitude float64, referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_PositionAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LatitudeAtPosition will the latitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LatitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_LatitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLatitudeAtPosition will the latitude of the given position, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamLatitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_LatitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LongitudeAtPosition will the longitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LongitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_LongitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLongitudeAtPosition will the longitude of the given position, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamLongitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_LongitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AltitudeAtPosition will the altitude, in meters, of the given position in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AltitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AltitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAltitudeAtPosition will the altitude, in meters, of the given position
// in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamAltitudeAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AltitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AtmosphericDensityAtPosition will the atmospheric density at the given
// position, in <math>kg/m^3</math>, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphericDensityAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AtmosphericDensityAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAtmosphericDensityAtPosition will the atmospheric density at the given
// position, in <math>kg/m^3</math>, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamAtmosphericDensityAtPosition(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AtmosphericDensityAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TemperatureAt will the temperature on the body at the given position, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) TemperatureAt(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_TemperatureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTemperatureAt will the temperature on the body at the given position,
// in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamTemperatureAt(position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_TemperatureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DensityAt will gets the air density, in <math>kg/m^3</math>, for the
// specified altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) DensityAt(altitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_DensityAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDensityAt will gets the air density, in <math>kg/m^3</math>, for the
// specified altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamDensityAt(altitude float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_DensityAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PressureAt will gets the air pressure, in Pascals, for the specified altitude
// above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) PressureAt(altitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_PressureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPressureAt will gets the air pressure, in Pascals, for the specified
// altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamPressureAt(altitude float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_PressureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BiomeAt will the biome at the given latitude and longitude, in degrees.
//
// Allowed game scenes: any.
func (s *CelestialBody) BiomeAt(latitude float64, longitude float64) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BiomeAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBiomeAt will the biome at the given latitude and longitude, in degrees.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamBiomeAt(latitude float64, longitude float64) (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_BiomeAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Position will the position of the center of the body, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Position(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position of the center of the body, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Velocity will the linear velocity of the body, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Velocity(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVelocity will the linear velocity of the body, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamVelocity(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rotation will the rotation of the body, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Rotation(referenceFrame ReferenceFrame) (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will the rotation of the body, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamRotation(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction in which the north pole of the celestial body is
// pointing, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Direction(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction in which the north pole of the celestial
// body is pointing, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AngularVelocity will the angular velocity of the body in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AngularVelocity(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAngularVelocity will the angular velocity of the body in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamAngularVelocity(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the name of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Satellites will a list of celestial bodies that are in orbit around this
// celestial body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Satellites() ([]CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv []CelestialBody
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Satellites",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSatellites will a list of celestial bodies that are in orbit around
// this celestial body.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSatellites() (*client.Stream[[]CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Satellites",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []CelestialBody {
		var value []CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Mass will the mass of the body, in kilograms.
//
// Allowed game scenes: any.
func (s *CelestialBody) Mass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMass will the mass of the body, in kilograms.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GravitationalParameter will the <a
// href="https://en.wikipedia.org/wiki/Standard_gravitational_parameter">standard
// gravitational parameter</a> of the body in <math>m^3s^{-2}</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) GravitationalParameter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_GravitationalParameter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGravitationalParameter will the <a
// href="https://en.wikipedia.org/wiki/Standard_gravitational_parameter">standard
// gravitational parameter</a> of the body in <math>m^3s^{-2}</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamGravitationalParameter() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_GravitationalParameter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SurfaceGravity will the acceleration due to gravity at sea level (mean
// altitude) on the body, in <math>m/s^2</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceGravity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SurfaceGravity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceGravity will the acceleration due to gravity at sea level (mean
// altitude) on the body, in <math>m/s^2</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSurfaceGravity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SurfaceGravity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RotationalPeriod will the sidereal rotational period of the body, in seconds.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalPeriod() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalPeriod",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotationalPeriod will the sidereal rotational period of the body, in
// seconds.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamRotationalPeriod() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalPeriod",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RotationalSpeed will the rotational speed of the body, in radians per second.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotationalSpeed will the rotational speed of the body, in radians per
// second.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamRotationalSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RotationAngle will the current rotation angle of the body, in radians. A
// value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationAngle() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotationAngle will the current rotation angle of the body, in radians.
// A value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamRotationAngle() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_RotationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InitialRotation will the initial rotation angle of the body (at UT 0), in
// radians. A value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) InitialRotation() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_InitialRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInitialRotation will the initial rotation angle of the body (at UT 0),
// in radians. A value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamInitialRotation() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_InitialRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// EquatorialRadius will the equatorial radius of the body, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) EquatorialRadius() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_EquatorialRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEquatorialRadius will the equatorial radius of the body, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamEquatorialRadius() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_EquatorialRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SphereOfInfluence will the radius of the sphere of influence of the body, in
// meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) SphereOfInfluence() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SphereOfInfluence",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSphereOfInfluence will the radius of the sphere of influence of the
// body, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSphereOfInfluence() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SphereOfInfluence",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Orbit will the orbit of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Orbit() (Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbit will the orbit of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamOrbit() (*client.Stream[Orbit], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Orbit {
		var value Orbit
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasAtmosphere will true if the body has an atmosphere.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphere() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphere",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasAtmosphere will true if the body has an atmosphere.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamHasAtmosphere() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphere",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AtmosphereDepth will the depth of the atmosphere, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphereDepth() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_AtmosphereDepth",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAtmosphereDepth will the depth of the atmosphere, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamAtmosphereDepth() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_AtmosphereDepth",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasAtmosphericOxygen will true if there is oxygen in the atmosphere, required
// for air-breathing engines.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphericOxygen() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphericOxygen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasAtmosphericOxygen will true if there is oxygen in the atmosphere,
// required for air-breathing engines.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamHasAtmosphericOxygen() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphericOxygen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Biomes will the biomes present on this body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Biomes() (map[string]struct{}, error) {
	var err error
	var argBytes []byte
	var vv map[string]struct{}
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Biomes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBiomes will the biomes present on this body.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamBiomes() (*client.Stream[map[string]struct{}], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_Biomes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]struct{} {
		var value map[string]struct{}
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FlyingHighAltitudeThreshold will the altitude, in meters, above which a
// vessel is considered to be flying "high" when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) FlyingHighAltitudeThreshold() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_FlyingHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFlyingHighAltitudeThreshold will the altitude, in meters, above which a
// vessel is considered to be flying "high" when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamFlyingHighAltitudeThreshold() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_FlyingHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SpaceHighAltitudeThreshold will the altitude, in meters, above which a vessel
// is considered to be in "high" space when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) SpaceHighAltitudeThreshold() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SpaceHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpaceHighAltitudeThreshold will the altitude, in meters, above which a
// vessel is considered to be in "high" space when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamSpaceHighAltitudeThreshold() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_SpaceHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferenceFrame will the reference frame that is fixed relative to the
// celestial body. <list type="bullet"><item><description>The origin is at the
// center of the body. </description></item><item><description>The axes rotate
// with the body.</description></item><item><description>The x-axis points from
// the center of the body towards the intersection of the prime meridian and
// equator (the position at 0° longitude, 0°
// latitude).</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points from the
// center of the body towards the equator at 90°E
// longitude.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame that is fixed relative to the
// celestial body. <list type="bullet"><item><description>The origin is at the
// center of the body. </description></item><item><description>The axes rotate
// with the body.</description></item><item><description>The x-axis points from
// the center of the body towards the intersection of the prime meridian and
// equator (the position at 0° longitude, 0°
// latitude).</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points from the
// center of the body towards the equator at 90°E
// longitude.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// NonRotatingReferenceFrame will the reference frame that is fixed relative to
// this celestial body, and orientated in a fixed direction (it does not rotate
// with the body). <list type="bullet"><item><description>The origin is at the
// center of the body.</description></item><item><description>The axes do not
// rotate.</description></item><item><description>The x-axis points in an
// arbitrary direction through the
// equator.</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points in an
// arbitrary direction through the equator.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) NonRotatingReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_NonRotatingReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNonRotatingReferenceFrame will the reference frame that is fixed
// relative to this celestial body, and orientated in a fixed direction (it does
// not rotate with the body). <list type="bullet"><item><description>The origin
// is at the center of the body.</description></item><item><description>The axes
// do not rotate.</description></item><item><description>The x-axis points in an
// arbitrary direction through the
// equator.</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points in an
// arbitrary direction through the equator.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamNonRotatingReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_NonRotatingReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrbitalReferenceFrame will the reference frame that is fixed relative to this
// celestial body, but orientated with the body's orbital prograde/normal/radial
// directions. <list type="bullet"><item><description>The origin is at the
// center of the body. </description></item><item><description>The axes rotate
// with the orbital prograde/normal/radial
// directions.</description></item><item><description>The x-axis points in the
// orbital anti-radial direction. </description></item><item><description>The
// y-axis points in the orbital prograde direction.
// </description></item><item><description>The z-axis points in the orbital
// normal direction. </description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) OrbitalReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbitalReferenceFrame will the reference frame that is fixed relative
// to this celestial body, but orientated with the body's orbital
// prograde/normal/radial directions. <list type="bullet"><item><description>The
// origin is at the center of the body.
// </description></item><item><description>The axes rotate with the orbital
// prograde/normal/radial directions.</description></item><item><description>The
// x-axis points in the orbital anti-radial direction.
// </description></item><item><description>The y-axis points in the orbital
// prograde direction. </description></item><item><description>The z-axis points
// in the orbital normal direction. </description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) StreamOrbitalReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CelestialBody_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Type will the type of link.
//
// Allowed game scenes: any.
func (s *CommLink) Type() (CommLinkType, error) {
	var err error
	var argBytes []byte
	var vv CommLinkType
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamType will the type of link.
//
// Allowed game scenes: any.
func (s *CommLink) StreamType() (*client.Stream[CommLinkType], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CommLinkType {
		var value CommLinkType
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SignalStrength will signal strength of the link.
//
// Allowed game scenes: any.
func (s *CommLink) SignalStrength() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalStrength will signal strength of the link.
//
// Allowed game scenes: any.
func (s *CommLink) StreamSignalStrength() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Start will start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) Start() (CommNode, error) {
	var err error
	var argBytes []byte
	var vv CommNode
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStart will start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) StreamStart() (*client.Stream[CommNode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CommNode {
		var value CommNode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// End will start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) End() (CommNode, error) {
	var err error
	var argBytes []byte
	var vv CommNode
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_End",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnd will start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) StreamEnd() (*client.Stream[CommNode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommLink_get_End",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CommNode {
		var value CommNode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will name of the communication node.
//
// Allowed game scenes: any.
func (s *CommNode) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will name of the communication node.
//
// Allowed game scenes: any.
func (s *CommNode) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsHome will whether the communication node is on Kerbin.
//
// Allowed game scenes: any.
func (s *CommNode) IsHome() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsHome will whether the communication node is on Kerbin.
//
// Allowed game scenes: any.
func (s *CommNode) StreamIsHome() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsControlPoint will whether the communication node is a control point, for
// example a manned vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsControlPoint() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsControlPoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsControlPoint will whether the communication node is a control point,
// for example a manned vessel.
//
// Allowed game scenes: any.
func (s *CommNode) StreamIsControlPoint() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsControlPoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsVessel will whether the communication node is a vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsVessel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsVessel will whether the communication node is a vessel.
//
// Allowed game scenes: any.
func (s *CommNode) StreamIsVessel() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_IsVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Vessel will the vessel for this communication node.
//
// Allowed game scenes: any.
func (s *CommNode) Vessel() (Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVessel will the vessel for this communication node.
//
// Allowed game scenes: any.
func (s *CommNode) StreamVessel() (*client.Stream[Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CommNode_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanCommunicate will whether the vessel can communicate with KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanCommunicate() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_CanCommunicate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanCommunicate will whether the vessel can communicate with KSC.
//
// Allowed game scenes: any.
func (s *Comms) StreamCanCommunicate() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_CanCommunicate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanTransmitScience will whether the vessel can transmit science data to KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanTransmitScience() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Comms_get_CanTransmitScience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanTransmitScience will whether the vessel can transmit science data to
// KSC.
//
// Allowed game scenes: any.
func (s *Comms) StreamCanTransmitScience() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_CanTransmitScience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SignalStrength will signal strength to KSC.
//
// Allowed game scenes: any.
func (s *Comms) SignalStrength() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalStrength will signal strength to KSC.
//
// Allowed game scenes: any.
func (s *Comms) StreamSignalStrength() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SignalDelay will signal delay to KSC in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelay() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSignalDelay will signal delay to KSC in seconds.
//
// Allowed game scenes: any.
func (s *Comms) StreamSignalDelay() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Power will the combined power of all active antennae on the vessel.
//
// Allowed game scenes: any.
func (s *Comms) Power() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPower will the combined power of all active antennae on the vessel.
//
// Allowed game scenes: any.
func (s *Comms) StreamPower() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ControlPath will the communication path used to control the vessel.
//
// Allowed game scenes: any.
func (s *Comms) ControlPath() ([]CommLink, error) {
	var err error
	var argBytes []byte
	var vv []CommLink
	request := &api.ProcedureCall{
		Procedure: "Comms_get_ControlPath",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamControlPath will the communication path used to control the vessel.
//
// Allowed game scenes: any.
func (s *Comms) StreamControlPath() (*client.Stream[[]CommLink], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Comms_get_ControlPath",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []CommLink {
		var value []CommLink
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Cancel will cancel an active contract.
//
// Allowed game scenes: any.
func (s *Contract) Cancel() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_Cancel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Accept will accept an offered contract.
//
// Allowed game scenes: any.
func (s *Contract) Accept() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_Accept",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Decline will decline an offered contract.
//
// Allowed game scenes: any.
func (s *Contract) Decline() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_Decline",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type will type of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Type() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamType will type of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamType() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Title will title of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTitle will title of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamTitle() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Description will description of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Description() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDescription will description of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamDescription() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Notes will notes for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Notes() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNotes will notes for the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamNotes() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Synopsis will synopsis for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Synopsis() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Synopsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSynopsis will synopsis for the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamSynopsis() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Synopsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Keywords will keywords for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Keywords() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Keywords",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamKeywords will keywords for the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamKeywords() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Keywords",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will state of the contract.
//
// Allowed game scenes: any.
func (s *Contract) State() (ContractState, error) {
	var err error
	var argBytes []byte
	var vv ContractState
	request := &api.ProcedureCall{
		Procedure: "Contract_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will state of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamState() (*client.Stream[ContractState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ContractState {
		var value ContractState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the contract is active.
//
// Allowed game scenes: any.
func (s *Contract) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the contract is active.
//
// Allowed game scenes: any.
func (s *Contract) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Failed will whether the contract has been failed.
//
// Allowed game scenes: any.
func (s *Contract) Failed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFailed will whether the contract has been failed.
//
// Allowed game scenes: any.
func (s *Contract) StreamFailed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Seen will whether the contract has been seen.
//
// Allowed game scenes: any.
func (s *Contract) Seen() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Seen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSeen will whether the contract has been seen.
//
// Allowed game scenes: any.
func (s *Contract) StreamSeen() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Seen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Read will whether the contract has been read.
//
// Allowed game scenes: any.
func (s *Contract) Read() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Read",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRead will whether the contract has been read.
//
// Allowed game scenes: any.
func (s *Contract) StreamRead() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Read",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanBeCanceled will whether the contract can be canceled.
//
// Allowed game scenes: any.
func (s *Contract) CanBeCanceled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeCanceled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanBeCanceled will whether the contract can be canceled.
//
// Allowed game scenes: any.
func (s *Contract) StreamCanBeCanceled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeCanceled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanBeDeclined will whether the contract can be declined.
//
// Allowed game scenes: any.
func (s *Contract) CanBeDeclined() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeDeclined",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanBeDeclined will whether the contract can be declined.
//
// Allowed game scenes: any.
func (s *Contract) StreamCanBeDeclined() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeDeclined",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanBeFailed will whether the contract can be failed.
//
// Allowed game scenes: any.
func (s *Contract) CanBeFailed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeFailed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanBeFailed will whether the contract can be failed.
//
// Allowed game scenes: any.
func (s *Contract) StreamCanBeFailed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_CanBeFailed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FundsAdvance will funds received when accepting the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsAdvance() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsAdvance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFundsAdvance will funds received when accepting the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamFundsAdvance() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsAdvance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FundsCompletion will funds received on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFundsCompletion will funds received on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamFundsCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FundsFailure will funds lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) FundsFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFundsFailure will funds lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) StreamFundsFailure() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReputationCompletion will reputation gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ReputationCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReputationCompletion will reputation gained on completion of the
// contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamReputationCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReputationFailure will reputation lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) ReputationFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReputationFailure will reputation lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) StreamReputationFailure() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScienceCompletion will science gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ScienceCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScienceCompletion will science gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamScienceCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parameters will parameters for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Parameters() ([]ContractParameter, error) {
	var err error
	var argBytes []byte
	var vv []ContractParameter
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Parameters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParameters will parameters for the contract.
//
// Allowed game scenes: any.
func (s *Contract) StreamParameters() (*client.Stream[[]ContractParameter], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Contract_get_Parameters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ContractParameter {
		var value []ContractParameter
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Types will a list of all contract types.
//
// Allowed game scenes: any.
func (s *ContractManager) Types() (map[string]struct{}, error) {
	var err error
	var argBytes []byte
	var vv map[string]struct{}
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_Types",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTypes will a list of all contract types.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamTypes() (*client.Stream[map[string]struct{}], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_Types",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]struct{} {
		var value map[string]struct{}
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AllContracts will a list of all contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) AllContracts() ([]Contract, error) {
	var err error
	var argBytes []byte
	var vv []Contract
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_AllContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAllContracts will a list of all contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamAllContracts() (*client.Stream[[]Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_AllContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Contract {
		var value []Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ActiveContracts will a list of all active contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) ActiveContracts() ([]Contract, error) {
	var err error
	var argBytes []byte
	var vv []Contract
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_ActiveContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActiveContracts will a list of all active contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamActiveContracts() (*client.Stream[[]Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_ActiveContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Contract {
		var value []Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OfferedContracts will a list of all offered, but unaccepted, contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) OfferedContracts() ([]Contract, error) {
	var err error
	var argBytes []byte
	var vv []Contract
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_OfferedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOfferedContracts will a list of all offered, but unaccepted, contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamOfferedContracts() (*client.Stream[[]Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_OfferedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Contract {
		var value []Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CompletedContracts will a list of all completed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) CompletedContracts() ([]Contract, error) {
	var err error
	var argBytes []byte
	var vv []Contract
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_CompletedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCompletedContracts will a list of all completed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamCompletedContracts() (*client.Stream[[]Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_CompletedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Contract {
		var value []Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FailedContracts will a list of all failed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) FailedContracts() ([]Contract, error) {
	var err error
	var argBytes []byte
	var vv []Contract
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_FailedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFailedContracts will a list of all failed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) StreamFailedContracts() (*client.Stream[[]Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractManager_get_FailedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Contract {
		var value []Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Title will title of the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTitle will title of the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamTitle() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Notes will notes for the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) Notes() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNotes will notes for the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamNotes() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Children will child contract parameters.
//
// Allowed game scenes: any.
func (s *ContractParameter) Children() ([]ContractParameter, error) {
	var err error
	var argBytes []byte
	var vv []ContractParameter
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamChildren will child contract parameters.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamChildren() (*client.Stream[[]ContractParameter], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ContractParameter {
		var value []ContractParameter
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Completed will whether the parameter has been completed.
//
// Allowed game scenes: any.
func (s *ContractParameter) Completed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Completed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCompleted will whether the parameter has been completed.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamCompleted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Completed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Failed will whether the parameter has been failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) Failed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFailed will whether the parameter has been failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamFailed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Optional will whether the contract parameter is optional.
//
// Allowed game scenes: any.
func (s *ContractParameter) Optional() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Optional",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOptional will whether the contract parameter is optional.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamOptional() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_Optional",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FundsCompletion will funds received on completion of the contract parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFundsCompletion will funds received on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamFundsCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FundsFailure will funds lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFundsFailure will funds lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamFundsFailure() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReputationCompletion will reputation gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReputationCompletion will reputation gained on completion of the
// contract parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamReputationCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReputationFailure will reputation lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReputationFailure will reputation lost if the contract parameter is
// failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamReputationFailure() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScienceCompletion will science gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ScienceCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScienceCompletion will science gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) StreamScienceCompletion() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ContractParameter_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ActivateNextStage will activates the next stage. Equivalent to pressing the
// space bar in-game.
//
// Allowed game scenes: any.
func (s *Control) ActivateNextStage() ([]Vessel, error) {
	var err error
	var argBytes []byte
	var vv []Vessel
	request := &api.ProcedureCall{
		Procedure: "Control_ActivateNextStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActivateNextStage will activates the next stage. Equivalent to pressing
// the space bar in-game.
//
// Allowed game scenes: any.
func (s *Control) StreamActivateNextStage() (*client.Stream[[]Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_ActivateNextStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Vessel {
		var value []Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GetActionGroup will returns true if the given action group is enabled.
//
// Allowed game scenes: any.
func (s *Control) GetActionGroup(group uint32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_GetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetActionGroup will returns true if the given action group is enabled.
//
// Allowed game scenes: any.
func (s *Control) StreamGetActionGroup(group uint32) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_GetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActionGroup will sets the state of the given action group.
//
// Allowed game scenes: any.
func (s *Control) SetActionGroup(group uint32, state bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_SetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(state)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ToggleActionGroup will toggles the state of the given action group.
//
// Allowed game scenes: any.
func (s *Control) ToggleActionGroup(group uint32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_ToggleActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AddNode will creates a maneuver node at the given universal time, and returns
// a <see cref="T:SpaceCenter.Node" /> object that can be used to modify it.
// Optionally sets the magnitude of the delta-v for the maneuver node in the
// prograde, normal and radial directions.
//
// Allowed game scenes: any.
func (s *Control) AddNode(ut float64, prograde float32, normal float32, radial float32) (Node, error) {
	var err error
	var argBytes []byte
	var vv Node
	request := &api.ProcedureCall{
		Procedure: "Control_AddNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(prograde)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(normal)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radial)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddNode will creates a maneuver node at the given universal time, and
// returns a <see cref="T:SpaceCenter.Node" /> object that can be used to modify
// it. Optionally sets the magnitude of the delta-v for the maneuver node in the
// prograde, normal and radial directions.
//
// Allowed game scenes: any.
func (s *Control) StreamAddNode(ut float64, prograde float32, normal float32, radial float32) (*client.Stream[Node], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_AddNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(prograde)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(normal)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radial)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Node {
		var value Node
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RemoveNodes will remove all maneuver nodes.
//
// Allowed game scenes: any.
func (s *Control) RemoveNodes() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_RemoveNodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State will the control state of the vessel.
//
// Allowed game scenes: any.
func (s *Control) State() (ControlState, error) {
	var err error
	var argBytes []byte
	var vv ControlState
	request := &api.ProcedureCall{
		Procedure: "Control_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the control state of the vessel.
//
// Allowed game scenes: any.
func (s *Control) StreamState() (*client.Stream[ControlState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ControlState {
		var value ControlState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Source will the source of the vessels control, for example by a kerbal or a
// probe core.
//
// Allowed game scenes: any.
func (s *Control) Source() (ControlSource, error) {
	var err error
	var argBytes []byte
	var vv ControlSource
	request := &api.ProcedureCall{
		Procedure: "Control_get_Source",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSource will the source of the vessels control, for example by a kerbal
// or a probe core.
//
// Allowed game scenes: any.
func (s *Control) StreamSource() (*client.Stream[ControlSource], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Source",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ControlSource {
		var value ControlSource
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *Control) SAS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *Control) StreamSAS() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSAS will the state of SAS.
//
// Allowed game scenes: any.
func (s *Control) SetSAS(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SASMode will the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) SASMode() (SASMode, error) {
	var err error
	var argBytes []byte
	var vv SASMode
	request := &api.ProcedureCall{
		Procedure: "Control_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSASMode will the current <see cref="T:SpaceCenter.SASMode" />. These
// modes are equivalent to the mode buttons to the left of the navball that
// appear when SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) StreamSASMode() (*client.Stream[SASMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) SASMode {
		var value SASMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSASMode will the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) SetSASMode(value SASMode) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SpeedMode will the current <see cref="T:SpaceCenter.SpeedMode" /> of the
// navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) SpeedMode() (SpeedMode, error) {
	var err error
	var argBytes []byte
	var vv SpeedMode
	request := &api.ProcedureCall{
		Procedure: "Control_get_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeedMode will the current <see cref="T:SpaceCenter.SpeedMode" /> of
// the navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) StreamSpeedMode() (*client.Stream[SpeedMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) SpeedMode {
		var value SpeedMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSpeedMode will the current <see cref="T:SpaceCenter.SpeedMode" /> of the
// navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) SetSpeedMode(value SpeedMode) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RCS will the state of RCS.
//
// Allowed game scenes: any.
func (s *Control) RCS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRCS will the state of RCS.
//
// Allowed game scenes: any.
func (s *Control) StreamRCS() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRCS will the state of RCS.
//
// Allowed game scenes: any.
func (s *Control) SetRCS(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReactionWheels will returns whether all reactive wheels on the vessel are
// active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) ReactionWheels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReactionWheels will returns whether all reactive wheels on the vessel
// are active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) StreamReactionWheels() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReactionWheels will returns whether all reactive wheels on the vessel are
// active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) SetReactionWheels(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Gear will the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) Gear() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGear will the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) StreamGear() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetGear will the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) SetGear(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Legs will returns whether all landing legs on the vessel are deployed, and
// sets the deployment state of all landing legs. Does not include wheels (for
// example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Legs() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLegs will returns whether all landing legs on the vessel are deployed,
// and sets the deployment state of all landing legs. Does not include wheels
// (for example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamLegs() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetLegs will returns whether all landing legs on the vessel are deployed, and
// sets the deployment state of all landing legs. Does not include wheels (for
// example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetLegs(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Wheels will returns whether all wheels on the vessel are deployed, and sets
// the deployment state of all wheels. Does not include landing legs. See <see
// cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Wheels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWheels will returns whether all wheels on the vessel are deployed, and
// sets the deployment state of all wheels. Does not include landing legs. See
// <see cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamWheels() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetWheels will returns whether all wheels on the vessel are deployed, and
// sets the deployment state of all wheels. Does not include landing legs. See
// <see cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetWheels(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Lights will the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) Lights() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLights will the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) StreamLights() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetLights will the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) SetLights(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Brakes will the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) Brakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBrakes will the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) StreamBrakes() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetBrakes will the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) SetBrakes(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Antennas will returns whether all antennas on the vessel are deployed, and
// sets the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Antennas() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntennas will returns whether all antennas on the vessel are deployed,
// and sets the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamAntennas() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAntennas will returns whether all antennas on the vessel are deployed, and
// sets the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetAntennas(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CargoBays will returns whether any of the cargo bays on the vessel are open,
// and sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) CargoBays() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCargoBays will returns whether any of the cargo bays on the vessel are
// open, and sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) StreamCargoBays() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetCargoBays will returns whether any of the cargo bays on the vessel are
// open, and sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) SetCargoBays(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Intakes will returns whether all of the air intakes on the vessel are open,
// and sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) Intakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIntakes will returns whether all of the air intakes on the vessel are
// open, and sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) StreamIntakes() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetIntakes will returns whether all of the air intakes on the vessel are
// open, and sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) SetIntakes(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Parachutes will returns whether all parachutes on the vessel are deployed,
// and sets the deployment state of all parachutes. Cannot be set to false. See
// <see cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Parachutes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParachutes will returns whether all parachutes on the vessel are
// deployed, and sets the deployment state of all parachutes. Cannot be set to
// false. See <see cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamParachutes() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetParachutes will returns whether all parachutes on the vessel are deployed,
// and sets the deployment state of all parachutes. Cannot be set to false. See
// <see cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetParachutes(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Radiators will returns whether all radiators on the vessel are deployed, and
// sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Radiators() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiators will returns whether all radiators on the vessel are
// deployed, and sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamRadiators() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRadiators will returns whether all radiators on the vessel are deployed,
// and sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetRadiators(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResourceHarvesters will returns whether all of the resource harvesters on the
// vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvesters() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceHarvesters will returns whether all of the resource harvesters
// on the vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamResourceHarvesters() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetResourceHarvesters will returns whether all of the resource harvesters on
// the vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetResourceHarvesters(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResourceHarvestersActive will returns whether any of the resource harvesters
// on the vessel are active, and sets the active state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Active" />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvestersActive() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceHarvestersActive will returns whether any of the resource
// harvesters on the vessel are active, and sets the active state of all
// resource harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Active"
// />.
//
// Allowed game scenes: any.
func (s *Control) StreamResourceHarvestersActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetResourceHarvestersActive will returns whether any of the resource
// harvesters on the vessel are active, and sets the active state of all
// resource harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Active"
// />.
//
// Allowed game scenes: any.
func (s *Control) SetResourceHarvestersActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SolarPanels will returns whether all solar panels on the vessel are deployed,
// and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SolarPanels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSolarPanels will returns whether all solar panels on the vessel are
// deployed, and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) StreamSolarPanels() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSolarPanels will returns whether all solar panels on the vessel are
// deployed, and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetSolarPanels(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Abort will the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) Abort() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAbort will the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) StreamAbort() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAbort will the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) SetAbort(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Throttle will the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) Throttle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrottle will the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) StreamThrottle() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetThrottle will the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetThrottle(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// InputMode will sets the behavior of the pitch, yaw, roll and translation
// control inputs. When set to additive, these inputs are added to the vessels
// current inputs. This mode is the default. When set to override, these inputs
// (if non-zero) override the vessels inputs. This mode prevents keyboard
// control, or SAS, from interfering with the controls when they are set.
//
// Allowed game scenes: any.
func (s *Control) InputMode() (ControlInputMode, error) {
	var err error
	var argBytes []byte
	var vv ControlInputMode
	request := &api.ProcedureCall{
		Procedure: "Control_get_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInputMode will sets the behavior of the pitch, yaw, roll and
// translation control inputs. When set to additive, these inputs are added to
// the vessels current inputs. This mode is the default. When set to override,
// these inputs (if non-zero) override the vessels inputs. This mode prevents
// keyboard control, or SAS, from interfering with the controls when they are
// set.
//
// Allowed game scenes: any.
func (s *Control) StreamInputMode() (*client.Stream[ControlInputMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ControlInputMode {
		var value ControlInputMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetInputMode will sets the behavior of the pitch, yaw, roll and translation
// control inputs. When set to additive, these inputs are added to the vessels
// current inputs. This mode is the default. When set to override, these inputs
// (if non-zero) override the vessels inputs. This mode prevents keyboard
// control, or SAS, from interfering with the controls when they are set.
//
// Allowed game scenes: any.
func (s *Control) SetInputMode(value ControlInputMode) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Pitch will the state of the pitch control. A value between -1 and 1.
// Equivalent to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitch will the state of the pitch control. A value between -1 and 1.
// Equivalent to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) StreamPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPitch will the state of the pitch control. A value between -1 and 1.
// Equivalent to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) SetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Yaw will the state of the yaw control. A value between -1 and 1. Equivalent
// to the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) Yaw() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamYaw will the state of the yaw control. A value between -1 and 1.
// Equivalent to the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) StreamYaw() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetYaw will the state of the yaw control. A value between -1 and 1.
// Equivalent to the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) SetYaw(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Roll will the state of the roll control. A value between -1 and 1. Equivalent
// to the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) Roll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRoll will the state of the roll control. A value between -1 and 1.
// Equivalent to the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) StreamRoll() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRoll will the state of the roll control. A value between -1 and 1.
// Equivalent to the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) SetRoll(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Forward will the state of the forward translational control. A value between
// -1 and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) Forward() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamForward will the state of the forward translational control. A value
// between -1 and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) StreamForward() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetForward will the state of the forward translational control. A value
// between -1 and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) SetForward(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Up will the state of the up translational control. A value between -1 and 1.
// Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) Up() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUp will the state of the up translational control. A value between -1
// and 1. Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) StreamUp() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetUp will the state of the up translational control. A value between -1 and
// 1. Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) SetUp(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Right will the state of the right translational control. A value between -1
// and 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) Right() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRight will the state of the right translational control. A value
// between -1 and 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) StreamRight() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRight will the state of the right translational control. A value between
// -1 and 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) SetRight(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WheelThrottle will the state of the wheel throttle. A value between -1 and 1.
// A value of 1 rotates the wheels forwards, a value of -1 rotates the wheels
// backwards.
//
// Allowed game scenes: any.
func (s *Control) WheelThrottle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWheelThrottle will the state of the wheel throttle. A value between -1
// and 1. A value of 1 rotates the wheels forwards, a value of -1 rotates the
// wheels backwards.
//
// Allowed game scenes: any.
func (s *Control) StreamWheelThrottle() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetWheelThrottle will the state of the wheel throttle. A value between -1 and
// 1. A value of 1 rotates the wheels forwards, a value of -1 rotates the wheels
// backwards.
//
// Allowed game scenes: any.
func (s *Control) SetWheelThrottle(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WheelSteering will the state of the wheel steering. A value between -1 and 1.
// A value of 1 steers to the left, and a value of -1 steers to the right.
//
// Allowed game scenes: any.
func (s *Control) WheelSteering() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Control_get_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWheelSteering will the state of the wheel steering. A value between -1
// and 1. A value of 1 steers to the left, and a value of -1 steers to the
// right.
//
// Allowed game scenes: any.
func (s *Control) StreamWheelSteering() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetWheelSteering will the state of the wheel steering. A value between -1 and
// 1. A value of 1 steers to the left, and a value of -1 steers to the right.
//
// Allowed game scenes: any.
func (s *Control) SetWheelSteering(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentStage will the current stage of the vessel. Corresponds to the stage
// number in the in-game UI.
//
// Allowed game scenes: any.
func (s *Control) CurrentStage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Control_get_CurrentStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCurrentStage will the current stage of the vessel. Corresponds to the
// stage number in the in-game UI.
//
// Allowed game scenes: any.
func (s *Control) StreamCurrentStage() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_CurrentStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StageLock will whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) StageLock() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Control_get_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStageLock will whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) StreamStageLock() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetStageLock will whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) SetStageLock(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_set_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Nodes will returns a list of all existing maneuver nodes, ordered by time
// from first to last.
//
// Allowed game scenes: any.
func (s *Control) Nodes() ([]Node, error) {
	var err error
	var argBytes []byte
	var vv []Node
	request := &api.ProcedureCall{
		Procedure: "Control_get_Nodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNodes will returns a list of all existing maneuver nodes, ordered by
// time from first to last.
//
// Allowed game scenes: any.
func (s *Control) StreamNodes() (*client.Stream[[]Node], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Control_get_Nodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Node {
		var value []Node
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetName will the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type will the type of crew member.
//
// Allowed game scenes: any.
func (s *CrewMember) Type() (CrewMemberType, error) {
	var err error
	var argBytes []byte
	var vv CrewMemberType
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamType will the type of crew member.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamType() (*client.Stream[CrewMemberType], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CrewMemberType {
		var value CrewMemberType
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OnMission will whether the crew member is on a mission.
//
// Allowed game scenes: any.
func (s *CrewMember) OnMission() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_OnMission",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOnMission will whether the crew member is on a mission.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamOnMission() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_OnMission",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Courage will the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) Courage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCourage will the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamCourage() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetCourage will the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) SetCourage(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stupidity will the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) Stupidity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStupidity will the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamStupidity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetStupidity will the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) SetStupidity(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Experience will the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) Experience() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExperience will the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamExperience() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetExperience will the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) SetExperience(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Badass will whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) Badass() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBadass will whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamBadass() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetBadass will whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) SetBadass(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Veteran will whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) Veteran() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVeteran will whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) StreamVeteran() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_get_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetVeteran will whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) SetVeteran(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CrewMember_set_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SimulateAerodynamicForceAt will simulate and return the total aerodynamic
// forces acting on the vessel, if it where to be traveling with the given
// velocity at the given position in the atmosphere of the given celestial body.
//
// Allowed game scenes: any.
func (s *Flight) SimulateAerodynamicForceAt(body CelestialBody, position api.Tuple3[float64, float64, float64], velocity api.Tuple3[float64, float64, float64]) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_SimulateAerodynamicForceAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSimulateAerodynamicForceAt will simulate and return the total
// aerodynamic forces acting on the vessel, if it where to be traveling with the
// given velocity at the given position in the atmosphere of the given celestial
// body.
//
// Allowed game scenes: any.
func (s *Flight) StreamSimulateAerodynamicForceAt(body CelestialBody, position api.Tuple3[float64, float64, float64], velocity api.Tuple3[float64, float64, float64]) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_SimulateAerodynamicForceAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GForce will the current G force acting on the vessel in <math>g</math>.
//
// Allowed game scenes: any.
func (s *Flight) GForce() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_GForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGForce will the current G force acting on the vessel in <math>g</math>.
//
// Allowed game scenes: any.
func (s *Flight) StreamGForce() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_GForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MeanAltitude will the altitude above sea level, in meters. Measured from the
// center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) MeanAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMeanAltitude will the altitude above sea level, in meters. Measured
// from the center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) StreamMeanAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SurfaceAltitude will the altitude above the surface of the body or sea level,
// whichever is closer, in meters. Measured from the center of mass of the
// vessel.
//
// Allowed game scenes: any.
func (s *Flight) SurfaceAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceAltitude will the altitude above the surface of the body or sea
// level, whichever is closer, in meters. Measured from the center of mass of
// the vessel.
//
// Allowed game scenes: any.
func (s *Flight) StreamSurfaceAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BedrockAltitude will the altitude above the surface of the body, in meters.
// When over water, this is the altitude above the sea floor. Measured from the
// center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) BedrockAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBedrockAltitude will the altitude above the surface of the body, in
// meters. When over water, this is the altitude above the sea floor. Measured
// from the center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) StreamBedrockAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Elevation will the elevation of the terrain under the vessel, in meters. This
// is the height of the terrain above sea level, and is negative when the vessel
// is over the sea.
//
// Allowed game scenes: any.
func (s *Flight) Elevation() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Elevation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamElevation will the elevation of the terrain under the vessel, in
// meters. This is the height of the terrain above sea level, and is negative
// when the vessel is over the sea.
//
// Allowed game scenes: any.
func (s *Flight) StreamElevation() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Elevation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Latitude will the <a
// href="https://en.wikipedia.org/wiki/Latitude">latitude</a> of the vessel for
// the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) Latitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLatitude will the <a
// href="https://en.wikipedia.org/wiki/Latitude">latitude</a> of the vessel for
// the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) StreamLatitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Longitude will the <a
// href="https://en.wikipedia.org/wiki/Longitude">longitude</a> of the vessel
// for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) Longitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLongitude will the <a
// href="https://en.wikipedia.org/wiki/Longitude">longitude</a> of the vessel
// for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) StreamLongitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Velocity will the velocity of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Velocity() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVelocity will the velocity of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamVelocity() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Speed will the speed of the vessel in meters per second, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Speed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeed will the speed of the vessel in meters per second, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamSpeed() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HorizontalSpeed will the horizontal speed of the vessel in meters per second,
// in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) HorizontalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_HorizontalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHorizontalSpeed will the horizontal speed of the vessel in meters per
// second, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamHorizontalSpeed() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_HorizontalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// VerticalSpeed will the vertical speed of the vessel in meters per second, in
// the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) VerticalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Flight_get_VerticalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVerticalSpeed will the vertical speed of the vessel in meters per
// second, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamVerticalSpeed() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_VerticalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CenterOfMass will the position of the center of mass of the vessel, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) CenterOfMass() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCenterOfMass will the position of the center of mass of the vessel, in
// the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) StreamCenterOfMass() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rotation will the rotation of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) Rotation() (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will the rotation of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) StreamRotation() (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction that the vessel is pointing in, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Direction() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction that the vessel is pointing in, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamDirection() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Pitch will the pitch of the vessel relative to the horizon, in degrees. A
// value between -90° and +90°.
//
// Allowed game scenes: any.
func (s *Flight) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitch will the pitch of the vessel relative to the horizon, in degrees.
// A value between -90° and +90°.
//
// Allowed game scenes: any.
func (s *Flight) StreamPitch() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Heading will the heading of the vessel (its angle relative to north), in
// degrees. A value between 0° and 360°.
//
// Allowed game scenes: any.
func (s *Flight) Heading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHeading will the heading of the vessel (its angle relative to north),
// in degrees. A value between 0° and 360°.
//
// Allowed game scenes: any.
func (s *Flight) StreamHeading() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Roll will the roll of the vessel relative to the horizon, in degrees. A value
// between -180° and +180°.
//
// Allowed game scenes: any.
func (s *Flight) Roll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRoll will the roll of the vessel relative to the horizon, in degrees. A
// value between -180° and +180°.
//
// Allowed game scenes: any.
func (s *Flight) StreamRoll() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Prograde will the prograde direction of the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Prograde() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPrograde will the prograde direction of the vessels orbit, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamPrograde() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Retrograde will the retrograde direction of the vessels orbit, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Retrograde() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Retrograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRetrograde will the retrograde direction of the vessels orbit, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamRetrograde() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Retrograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Normal will the direction normal to the vessels orbit, in the reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Normal() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNormal will the direction normal to the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamNormal() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AntiNormal will the direction opposite to the normal of the vessels orbit, in
// the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiNormal() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AntiNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntiNormal will the direction opposite to the normal of the vessels
// orbit, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamAntiNormal() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AntiNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Radial will the radial direction of the vessels orbit, in the reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Radial() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadial will the radial direction of the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamRadial() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AntiRadial will the direction opposite to the radial direction of the vessels
// orbit, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiRadial() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AntiRadial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntiRadial will the direction opposite to the radial direction of the
// vessels orbit, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamAntiRadial() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AntiRadial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AtmosphereDensity will the current density of the atmosphere around the
// vessel, in <math>kg/m^3</math>.
//
// Allowed game scenes: any.
func (s *Flight) AtmosphereDensity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AtmosphereDensity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAtmosphereDensity will the current density of the atmosphere around the
// vessel, in <math>kg/m^3</math>.
//
// Allowed game scenes: any.
func (s *Flight) StreamAtmosphereDensity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AtmosphereDensity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DynamicPressure will the dynamic pressure acting on the vessel, in Pascals.
// This is a measure of the strength of the aerodynamic forces. It is equal to
// <math>\frac{1}{2} . \mbox{air density} . \mbox{velocity}^2</math>. It is
// commonly denoted <math>Q</math>.
//
// Allowed game scenes: any.
func (s *Flight) DynamicPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDynamicPressure will the dynamic pressure acting on the vessel, in
// Pascals. This is a measure of the strength of the aerodynamic forces. It is
// equal to <math>\frac{1}{2} . \mbox{air density} . \mbox{velocity}^2</math>.
// It is commonly denoted <math>Q</math>.
//
// Allowed game scenes: any.
func (s *Flight) StreamDynamicPressure() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StaticPressureAtMSL will the static atmospheric pressure at mean sea level,
// in Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressureAtMSL() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticPressureAtMSL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStaticPressureAtMSL will the static atmospheric pressure at mean sea
// level, in Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StreamStaticPressureAtMSL() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticPressureAtMSL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StaticPressure will the static atmospheric pressure acting on the vessel, in
// Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStaticPressure will the static atmospheric pressure acting on the
// vessel, in Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StreamStaticPressure() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AerodynamicForce will the total aerodynamic forces acting on the vessel, in
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AerodynamicForce() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AerodynamicForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAerodynamicForce will the total aerodynamic forces acting on the
// vessel, in reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) StreamAerodynamicForce() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AerodynamicForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Lift will the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic lift</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) Lift() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Lift",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLift will the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic lift</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) StreamLift() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Lift",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Drag will the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic drag</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) Drag() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Drag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDrag will the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic drag</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) StreamDrag() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Drag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SpeedOfSound will the speed of sound, in the atmosphere around the vessel, in
// <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Flight) SpeedOfSound() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SpeedOfSound",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeedOfSound will the speed of sound, in the atmosphere around the
// vessel, in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Flight) StreamSpeedOfSound() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SpeedOfSound",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Mach will the speed of the vessel, in multiples of the speed of sound.
//
// Allowed game scenes: any.
func (s *Flight) Mach() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Mach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMach will the speed of the vessel, in multiples of the speed of sound.
//
// Allowed game scenes: any.
func (s *Flight) StreamMach() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_Mach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReynoldsNumber will the vessels Reynolds number.
//
// Allowed game scenes: any.
func (s *Flight) ReynoldsNumber() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_ReynoldsNumber",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReynoldsNumber will the vessels Reynolds number.
//
// Allowed game scenes: any.
func (s *Flight) StreamReynoldsNumber() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_ReynoldsNumber",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAirSpeed will the <a
// href="https://en.wikipedia.org/wiki/True_airspeed">true air speed</a> of the
// vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) TrueAirSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TrueAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAirSpeed will the <a
// href="https://en.wikipedia.org/wiki/True_airspeed">true air speed</a> of the
// vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) StreamTrueAirSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TrueAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// EquivalentAirSpeed will the <a
// href="https://en.wikipedia.org/wiki/Equivalent_airspeed">equivalent air
// speed</a> of the vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) EquivalentAirSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_EquivalentAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEquivalentAirSpeed will the <a
// href="https://en.wikipedia.org/wiki/Equivalent_airspeed">equivalent air
// speed</a> of the vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) StreamEquivalentAirSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_EquivalentAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TerminalVelocity will an estimate of the current terminal velocity of the
// vessel, in meters per second. This is the speed at which the drag forces
// cancel out the force of gravity.
//
// Allowed game scenes: any.
func (s *Flight) TerminalVelocity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TerminalVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTerminalVelocity will an estimate of the current terminal velocity of
// the vessel, in meters per second. This is the speed at which the drag forces
// cancel out the force of gravity.
//
// Allowed game scenes: any.
func (s *Flight) StreamTerminalVelocity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TerminalVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AngleOfAttack will the pitch angle between the orientation of the vessel and
// its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) AngleOfAttack() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AngleOfAttack",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAngleOfAttack will the pitch angle between the orientation of the
// vessel and its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) StreamAngleOfAttack() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_AngleOfAttack",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SideslipAngle will the yaw angle between the orientation of the vessel and
// its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) SideslipAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SideslipAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSideslipAngle will the yaw angle between the orientation of the vessel
// and its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) StreamSideslipAngle() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_SideslipAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TotalAirTemperature will the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">total air
// temperature</a> of the atmosphere around the vessel, in Kelvin. This includes
// the <see cref="M:SpaceCenter.Flight.StaticAirTemperature" /> and the vessel's
// kinetic energy.
//
// Allowed game scenes: any.
func (s *Flight) TotalAirTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TotalAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTotalAirTemperature will the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">total air
// temperature</a> of the atmosphere around the vessel, in Kelvin. This includes
// the <see cref="M:SpaceCenter.Flight.StaticAirTemperature" /> and the vessel's
// kinetic energy.
//
// Allowed game scenes: any.
func (s *Flight) StreamTotalAirTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_TotalAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StaticAirTemperature will the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">static (ambient)
// temperature</a> of the atmosphere around the vessel, in Kelvin.
//
// Allowed game scenes: any.
func (s *Flight) StaticAirTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStaticAirTemperature will the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">static (ambient)
// temperature</a> of the atmosphere around the vessel, in Kelvin.
//
// Allowed game scenes: any.
func (s *Flight) StreamStaticAirTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StaticAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StallFraction will the current amount of stall, between 0 and 1. A value
// greater than 0.005 indicates a minor stall and a value greater than 0.5
// indicates a large-scale stall.
//
// Allowed game scenes: any.
func (s *Flight) StallFraction() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StallFraction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStallFraction will the current amount of stall, between 0 and 1. A
// value greater than 0.005 indicates a minor stall and a value greater than 0.5
// indicates a large-scale stall.
//
// Allowed game scenes: any.
func (s *Flight) StreamStallFraction() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_StallFraction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DragCoefficient will the coefficient of drag. This is the amount of drag
// produced by the vessel. It depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) DragCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_DragCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDragCoefficient will the coefficient of drag. This is the amount of
// drag produced by the vessel. It depends on air speed, air density and wing
// area.
//
// Allowed game scenes: any.
func (s *Flight) StreamDragCoefficient() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_DragCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LiftCoefficient will the coefficient of lift. This is the amount of lift
// produced by the vessel, and depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) LiftCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_LiftCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLiftCoefficient will the coefficient of lift. This is the amount of
// lift produced by the vessel, and depends on air speed, air density and wing
// area.
//
// Allowed game scenes: any.
func (s *Flight) StreamLiftCoefficient() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_LiftCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BallisticCoefficient will the <a
// href="https://en.wikipedia.org/wiki/Ballistic_coefficient">ballistic
// coefficient</a>.
//
// Allowed game scenes: any.
func (s *Flight) BallisticCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_BallisticCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBallisticCoefficient will the <a
// href="https://en.wikipedia.org/wiki/Ballistic_coefficient">ballistic
// coefficient</a>.
//
// Allowed game scenes: any.
func (s *Flight) StreamBallisticCoefficient() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_BallisticCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustSpecificFuelConsumption will the thrust specific fuel consumption for
// the jet engines on the vessel. This is a measure of the efficiency of the
// engines, with a lower value indicating a more efficient vessel. This value is
// the number of Newtons of fuel that are burned, per hour, to produce one
// newton of thrust.
//
// Allowed game scenes: any.
func (s *Flight) ThrustSpecificFuelConsumption() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Flight_get_ThrustSpecificFuelConsumption",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustSpecificFuelConsumption will the thrust specific fuel consumption
// for the jet engines on the vessel. This is a measure of the efficiency of the
// engines, with a lower value indicating a more efficient vessel. This value is
// the number of Newtons of fuel that are burned, per hour, to produce one
// newton of thrust.
//
// Allowed game scenes: any.
func (s *Flight) StreamThrustSpecificFuelConsumption() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Flight_get_ThrustSpecificFuelConsumption",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BurnVector will returns the burn vector for the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) BurnVector(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Node_BurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBurnVector will returns the burn vector for the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) StreamBurnVector(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_BurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RemainingBurnVector will returns the remaining burn vector for the maneuver
// node.
//
// Allowed game scenes: any.
func (s *Node) RemainingBurnVector(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Node_RemainingBurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRemainingBurnVector will returns the remaining burn vector for the
// maneuver node.
//
// Allowed game scenes: any.
func (s *Node) StreamRemainingBurnVector(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_RemainingBurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Remove will removes the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position will the position vector of the maneuver node in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Node) Position(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Node_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position vector of the maneuver node in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Node) StreamPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction of the maneuver nodes burn.
//
// Allowed game scenes: any.
func (s *Node) Direction(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Node_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction of the maneuver nodes burn.
//
// Allowed game scenes: any.
func (s *Node) StreamDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Prograde will the magnitude of the maneuver nodes delta-v in the prograde
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Prograde() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPrograde will the magnitude of the maneuver nodes delta-v in the
// prograde direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) StreamPrograde() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPrograde will the magnitude of the maneuver nodes delta-v in the prograde
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetPrograde(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_set_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Normal will the magnitude of the maneuver nodes delta-v in the normal
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Normal() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNormal will the magnitude of the maneuver nodes delta-v in the normal
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) StreamNormal() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetNormal will the magnitude of the maneuver nodes delta-v in the normal
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetNormal(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_set_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Radial will the magnitude of the maneuver nodes delta-v in the radial
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Radial() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadial will the magnitude of the maneuver nodes delta-v in the radial
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) StreamRadial() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRadial will the magnitude of the maneuver nodes delta-v in the radial
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetRadial(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_set_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DeltaV will the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) DeltaV() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeltaV will the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) StreamDeltaV() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeltaV will the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetDeltaV(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_set_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RemainingDeltaV will gets the remaining delta-v of the maneuver node, in
// meters per second. Changes as the node is executed. This is equivalent to the
// delta-v reported in-game.
//
// Allowed game scenes: any.
func (s *Node) RemainingDeltaV() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_RemainingDeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRemainingDeltaV will gets the remaining delta-v of the maneuver node,
// in meters per second. Changes as the node is executed. This is equivalent to
// the delta-v reported in-game.
//
// Allowed game scenes: any.
func (s *Node) StreamRemainingDeltaV() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_RemainingDeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// UT will the universal time at which the maneuver will occur, in seconds.
//
// Allowed game scenes: any.
func (s *Node) UT() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUT will the universal time at which the maneuver will occur, in
// seconds.
//
// Allowed game scenes: any.
func (s *Node) StreamUT() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetUT will the universal time at which the maneuver will occur, in seconds.
//
// Allowed game scenes: any.
func (s *Node) SetUT(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_set_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TimeTo will the time until the maneuver node will be encountered, in seconds.
//
// Allowed game scenes: any.
func (s *Node) TimeTo() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Node_get_TimeTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeTo will the time until the maneuver node will be encountered, in
// seconds.
//
// Allowed game scenes: any.
func (s *Node) StreamTimeTo() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_TimeTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Orbit will the orbit that results from executing the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) Orbit() (Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &api.ProcedureCall{
		Procedure: "Node_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbit will the orbit that results from executing the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) StreamOrbit() (*client.Stream[Orbit], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Orbit {
		var value Orbit
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferenceFrame will the reference frame that is fixed relative to the
// maneuver node's burn. <list type="bullet"><item><description>The origin is at
// the position of the maneuver node.</description></item><item><description>The
// y-axis points in the direction of the
// burn.</description></item><item><description>The x-axis and z-axis point in
// arbitrary but fixed directions.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Node_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame that is fixed relative to the
// maneuver node's burn. <list type="bullet"><item><description>The origin is at
// the position of the maneuver node.</description></item><item><description>The
// y-axis points in the direction of the
// burn.</description></item><item><description>The x-axis and z-axis point in
// arbitrary but fixed directions.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrbitalReferenceFrame will the reference frame that is fixed relative to the
// maneuver node, and orientated with the orbital prograde/normal/radial
// directions of the original orbit at the maneuver node's position. <list
// type="bullet"><item><description>The origin is at the position of the
// maneuver node.</description></item><item><description>The x-axis points in
// the orbital anti-radial direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The y-axis points
// in the orbital prograde direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The z-axis points
// in the orbital normal direction of the original orbit, at the position of the
// maneuver node.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) OrbitalReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Node_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbitalReferenceFrame will the reference frame that is fixed relative
// to the maneuver node, and orientated with the orbital prograde/normal/radial
// directions of the original orbit at the maneuver node's position. <list
// type="bullet"><item><description>The origin is at the position of the
// maneuver node.</description></item><item><description>The x-axis points in
// the orbital anti-radial direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The y-axis points
// in the orbital prograde direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The z-axis points
// in the orbital normal direction of the original orbit, at the position of the
// maneuver node.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) StreamOrbitalReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Node_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferencePlaneNormal will the direction that is normal to the orbits
// reference plane, in the given reference frame. The reference plane is the
// plane from which the orbits inclination is measured.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneNormal() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferencePlaneNormal will the direction that is normal to the orbits
// reference plane, in the given reference frame. The reference plane is the
// plane from which the orbits inclination is measured.
//
// Allowed game scenes: any.
func (s *Orbit) StreamReferencePlaneNormal() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferencePlaneDirection will the direction from which the orbits longitude of
// ascending node is measured, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneDirection() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferencePlaneDirection will the direction from which the orbits
// longitude of ascending node is measured, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) StreamReferencePlaneDirection() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MeanAnomalyAtUT will the mean anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_MeanAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMeanAnomalyAtUT will the mean anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) StreamMeanAnomalyAtUT(ut float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_MeanAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RadiusAtTrueAnomaly will the orbital radius at the point in the orbit given
// by the true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAtTrueAnomaly(trueAnomaly float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_RadiusAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiusAtTrueAnomaly will the orbital radius at the point in the orbit
// given by the true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) StreamRadiusAtTrueAnomaly(trueAnomaly float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_RadiusAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAnomalyAtRadius will the true anomaly at the given orbital radius.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtRadius(radius float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radius)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAnomalyAtRadius will the true anomaly at the given orbital radius.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTrueAnomalyAtRadius(radius float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radius)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAnomalyAtUT will the true anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAnomalyAtUT will the true anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTrueAnomalyAtUT(ut float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// UTAtTrueAnomaly will the universal time, in seconds, corresponding to the
// given true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) UTAtTrueAnomaly(trueAnomaly float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_UTAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUTAtTrueAnomaly will the universal time, in seconds, corresponding to
// the given true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) StreamUTAtTrueAnomaly(trueAnomaly float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_UTAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// EccentricAnomalyAtUT will the eccentric anomaly at the given universal time.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_EccentricAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEccentricAnomalyAtUT will the eccentric anomaly at the given universal
// time.
//
// Allowed game scenes: any.
func (s *Orbit) StreamEccentricAnomalyAtUT(ut float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_EccentricAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrbitalSpeedAt will the orbital speed at the given time, in meters per
// second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeedAt(time float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_OrbitalSpeedAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbitalSpeedAt will the orbital speed at the given time, in meters per
// second.
//
// Allowed game scenes: any.
func (s *Orbit) StreamOrbitalSpeedAt(time float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_OrbitalSpeedAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RadiusAt will the orbital radius at the given time, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAt(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_RadiusAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiusAt will the orbital radius at the given time, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) StreamRadiusAt(ut float64) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_RadiusAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PositionAt will the position at a given time, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *Orbit) PositionAt(ut float64, referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Orbit_PositionAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPositionAt will the position at a given time, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) StreamPositionAt(ut float64, referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_PositionAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TimeOfClosestApproach will estimates and returns the time at closest approach
// to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TimeOfClosestApproach(target Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_TimeOfClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeOfClosestApproach will estimates and returns the time at closest
// approach to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTimeOfClosestApproach(target Orbit) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_TimeOfClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DistanceAtClosestApproach will estimates and returns the distance at closest
// approach to a target orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) DistanceAtClosestApproach(target Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_DistanceAtClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDistanceAtClosestApproach will estimates and returns the distance at
// closest approach to a target orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) StreamDistanceAtClosestApproach(target Orbit) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_DistanceAtClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ListClosestApproaches will returns the times at closest approach and
// corresponding distances, to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) ListClosestApproaches(target Orbit, orbits int32) ([][]float64, error) {
	var err error
	var argBytes []byte
	var vv [][]float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_ListClosestApproaches",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(orbits)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamListClosestApproaches will returns the times at closest approach and
// corresponding distances, to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) StreamListClosestApproaches(target Orbit, orbits int32) (*client.Stream[[][]float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_ListClosestApproaches",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(orbits)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) [][]float64 {
		var value [][]float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAnomalyAtAN will the true anomaly of the ascending node with the given
// target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtAN(target Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtAN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAnomalyAtAN will the true anomaly of the ascending node with the
// given target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTrueAnomalyAtAN(target Orbit) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtAN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAnomalyAtDN will the true anomaly of the descending node with the given
// target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtDN(target Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtDN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAnomalyAtDN will the true anomaly of the descending node with the
// given target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTrueAnomalyAtDN(target Orbit) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtDN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RelativeInclination will relative inclination of this orbit and the target
// orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) RelativeInclination(target Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_RelativeInclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRelativeInclination will relative inclination of this orbit and the
// target orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) StreamRelativeInclination(target Orbit) (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_RelativeInclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Body will the celestial body (e.g. planet or moon) around which the object is
// orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) Body() (CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBody will the celestial body (e.g. planet or moon) around which the
// object is orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) StreamBody() (*client.Stream[CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CelestialBody {
		var value CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Apoapsis will gets the apoapsis of the orbit, in meters, from the center of
// mass of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) Apoapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Apoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamApoapsis will gets the apoapsis of the orbit, in meters, from the
// center of mass of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) StreamApoapsis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Apoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Periapsis will the periapsis of the orbit, in meters, from the center of mass
// of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) Periapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Periapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPeriapsis will the periapsis of the orbit, in meters, from the center
// of mass of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) StreamPeriapsis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Periapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ApoapsisAltitude will the apoapsis of the orbit, in meters, above the sea
// level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) ApoapsisAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_ApoapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamApoapsisAltitude will the apoapsis of the orbit, in meters, above the
// sea level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) StreamApoapsisAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_ApoapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PeriapsisAltitude will the periapsis of the orbit, in meters, above the sea
// level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) PeriapsisAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_PeriapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPeriapsisAltitude will the periapsis of the orbit, in meters, above the
// sea level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) StreamPeriapsisAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_PeriapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SemiMajorAxis will the semi-major axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMajorAxis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_SemiMajorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSemiMajorAxis will the semi-major axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) StreamSemiMajorAxis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_SemiMajorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SemiMinorAxis will the semi-minor axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMinorAxis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_SemiMinorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSemiMinorAxis will the semi-minor axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) StreamSemiMinorAxis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_SemiMinorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Radius will the current radius of the orbit, in meters. This is the distance
// between the center of mass of the object in orbit, and the center of mass of
// the body around which it is orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) Radius() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadius will the current radius of the orbit, in meters. This is the
// distance between the center of mass of the object in orbit, and the center of
// mass of the body around which it is orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) StreamRadius() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Speed will the current orbital speed of the object in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) Speed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeed will the current orbital speed of the object in meters per
// second.
//
// Allowed game scenes: any.
func (s *Orbit) StreamSpeed() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Period will the orbital period, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) Period() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Period",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPeriod will the orbital period, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) StreamPeriod() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Period",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TimeToApoapsis will the time until the object reaches apoapsis, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToApoapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToApoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeToApoapsis will the time until the object reaches apoapsis, in
// seconds.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTimeToApoapsis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToApoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TimeToPeriapsis will the time until the object reaches periapsis, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToPeriapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeToPeriapsis will the time until the object reaches periapsis, in
// seconds.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTimeToPeriapsis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Eccentricity will the <a
// href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a> of
// the orbit.
//
// Allowed game scenes: any.
func (s *Orbit) Eccentricity() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Eccentricity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEccentricity will the <a
// href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a> of
// the orbit.
//
// Allowed game scenes: any.
func (s *Orbit) StreamEccentricity() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Eccentricity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Inclination will the <a
// href="https://en.wikipedia.org/wiki/Orbital_inclination">inclination</a> of
// the orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) Inclination() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Inclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInclination will the <a
// href="https://en.wikipedia.org/wiki/Orbital_inclination">inclination</a> of
// the orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) StreamInclination() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Inclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LongitudeOfAscendingNode will the <a
// href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">longitude
// of the ascending node</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) LongitudeOfAscendingNode() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_LongitudeOfAscendingNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLongitudeOfAscendingNode will the <a
// href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">longitude
// of the ascending node</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) StreamLongitudeOfAscendingNode() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_LongitudeOfAscendingNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ArgumentOfPeriapsis will the <a
// href="https://en.wikipedia.org/wiki/Argument_of_periapsis">argument of
// periapsis</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) ArgumentOfPeriapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_ArgumentOfPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamArgumentOfPeriapsis will the <a
// href="https://en.wikipedia.org/wiki/Argument_of_periapsis">argument of
// periapsis</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) StreamArgumentOfPeriapsis() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_ArgumentOfPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MeanAnomalyAtEpoch will the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtEpoch() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomalyAtEpoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMeanAnomalyAtEpoch will the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>.
//
// Allowed game scenes: any.
func (s *Orbit) StreamMeanAnomalyAtEpoch() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomalyAtEpoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Epoch will the time since the epoch (the point at which the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>
// was measured, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) Epoch() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Epoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEpoch will the time since the epoch (the point at which the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>
// was measured, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) StreamEpoch() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_Epoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MeanAnomaly will the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMeanAnomaly will the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) StreamMeanAnomaly() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// EccentricAnomaly will the <a
// href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_EccentricAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEccentricAnomaly will the <a
// href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) StreamEccentricAnomaly() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_EccentricAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TrueAnomaly will the <a
// href="https://en.wikipedia.org/wiki/True_anomaly">true anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTrueAnomaly will the <a
// href="https://en.wikipedia.org/wiki/True_anomaly">true anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTrueAnomaly() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// NextOrbit will if the object is going to change sphere of influence in the
// future, returns the new orbit after the change. Otherwise returns nil.
//
// Allowed game scenes: any.
func (s *Orbit) NextOrbit() (Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_NextOrbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNextOrbit will if the object is going to change sphere of influence in
// the future, returns the new orbit after the change. Otherwise returns nil.
//
// Allowed game scenes: any.
func (s *Orbit) StreamNextOrbit() (*client.Stream[Orbit], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_NextOrbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Orbit {
		var value Orbit
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TimeToSOIChange will the time until the object changes sphere of influence,
// in seconds. Returns NaN if the object is not going to change sphere of
// influence.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToSOIChange() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToSOIChange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTimeToSOIChange will the time until the object changes sphere of
// influence, in seconds. Returns NaN if the object is not going to change
// sphere of influence.
//
// Allowed game scenes: any.
func (s *Orbit) StreamTimeToSOIChange() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_TimeToSOIChange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrbitalSpeed will the current orbital speed in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_OrbitalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbitalSpeed will the current orbital speed in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) StreamOrbitalSpeed() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Orbit_get_OrbitalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Transmit will transmit data.
//
// Allowed game scenes: any.
func (s *Antenna) Transmit() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_Transmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Cancel will cancel current transmission of data.
//
// Allowed game scenes: any.
func (s *Antenna) Cancel() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_Cancel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the current state of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) State() (AntennaState, error) {
	var err error
	var argBytes []byte
	var vv AntennaState
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StreamState() (*client.Stream[AntennaState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) AntennaState {
		var value AntennaState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployable will whether the antenna is deployable.
//
// Allowed game scenes: any.
func (s *Antenna) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployable will whether the antenna is deployable.
//
// Allowed game scenes: any.
func (s *Antenna) StreamDeployable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanTransmit will whether data can be transmitted by this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) CanTransmit() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_CanTransmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanTransmit will whether data can be transmitted by this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StreamCanTransmit() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_CanTransmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AllowPartial will whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) AllowPartial() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAllowPartial will whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) StreamAllowPartial() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAllowPartial will whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) SetAllowPartial(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_set_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Power will the power of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) Power() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPower will the power of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPower() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Combinable will whether the antenna can be combined with other antennae on
// the vessel to boost the power.
//
// Allowed game scenes: any.
func (s *Antenna) Combinable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Combinable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCombinable will whether the antenna can be combined with other antennae
// on the vessel to boost the power.
//
// Allowed game scenes: any.
func (s *Antenna) StreamCombinable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_Combinable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CombinableExponent will exponent used to calculate the combined power of
// multiple antennae on a vessel.
//
// Allowed game scenes: any.
func (s *Antenna) CombinableExponent() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_CombinableExponent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCombinableExponent will exponent used to calculate the combined power
// of multiple antennae on a vessel.
//
// Allowed game scenes: any.
func (s *Antenna) StreamCombinableExponent() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_CombinableExponent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PacketInterval will interval between sending packets in seconds.
//
// Allowed game scenes: any.
func (s *Antenna) PacketInterval() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketInterval",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPacketInterval will interval between sending packets in seconds.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPacketInterval() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketInterval",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PacketSize will amount of data sent per packet in Mits.
//
// Allowed game scenes: any.
func (s *Antenna) PacketSize() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketSize",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPacketSize will amount of data sent per packet in Mits.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPacketSize() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketSize",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PacketResourceCost will units of electric charge consumed per packet sent.
//
// Allowed game scenes: any.
func (s *Antenna) PacketResourceCost() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketResourceCost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPacketResourceCost will units of electric charge consumed per packet
// sent.
//
// Allowed game scenes: any.
func (s *Antenna) StreamPacketResourceCost() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Antenna_get_PacketResourceCost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the state of the cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) State() (CargoBayState, error) {
	var err error
	var argBytes []byte
	var vv CargoBayState
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the state of the cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) StreamState() (*client.Stream[CargoBayState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CargoBayState {
		var value CargoBayState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Open will whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) Open() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOpen will whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) StreamOpen() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CargoBay_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetOpen will whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) SetOpen(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "CargoBay_set_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this control surface.
//
// Allowed game scenes: any.
func (s *ControlSurface) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this control surface.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PitchEnabled will whether the control surface has pitch control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) PitchEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitchEnabled will whether the control surface has pitch control
// enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamPitchEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPitchEnabled will whether the control surface has pitch control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetPitchEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawEnabled will whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) YawEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamYawEnabled will whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamYawEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetYawEnabled will whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetYawEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollEnabled will whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) RollEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRollEnabled will whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamRollEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRollEnabled will whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetRollEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AuthorityLimiter will the authority limiter for the control surface, which
// controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) AuthorityLimiter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAuthorityLimiter will the authority limiter for the control surface,
// which controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamAuthorityLimiter() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAuthorityLimiter will the authority limiter for the control surface, which
// controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetAuthorityLimiter(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Inverted will whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) Inverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInverted will whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamInverted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetInverted will whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Deployed will whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceArea will surface area of the control surface in <math>m^2</math>.
//
// Allowed game scenes: any.
func (s *ControlSurface) SurfaceArea() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_SurfaceArea",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceArea will surface area of the control surface in
// <math>m^2</math>.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamSurfaceArea() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_SurfaceArea",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableTorque will the available torque, in Newton meters, that can be
// produced by this control surface, in the positive and negative pitch, roll
// and yaw axes of the vessel. These axes correspond to the coordinate axes of
// the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ControlSurface) AvailableTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableTorque will the available torque, in Newton meters, that can
// be produced by this control surface, in the positive and negative pitch, roll
// and yaw axes of the vessel. These axes correspond to the coordinate axes of
// the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ControlSurface) StreamAvailableTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ControlSurface_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Decouple will fires the decoupler. Returns the new vessel created when the
// decoupler fires. Throws an exception if the decoupler has already fired.
//
// Allowed game scenes: any.
func (s *Decoupler) Decouple() (Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "Decoupler_Decouple",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecouple will fires the decoupler. Returns the new vessel created when
// the decoupler fires. Throws an exception if the decoupler has already fired.
//
// Allowed game scenes: any.
func (s *Decoupler) StreamDecouple() (*client.Stream[Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Decoupler_Decouple",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this decoupler.
//
// Allowed game scenes: any.
func (s *Decoupler) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this decoupler.
//
// Allowed game scenes: any.
func (s *Decoupler) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Decoupled will whether the decoupler has fired.
//
// Allowed game scenes: any.
func (s *Decoupler) Decoupled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Decoupled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecoupled will whether the decoupler has fired.
//
// Allowed game scenes: any.
func (s *Decoupler) StreamDecoupled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Decoupled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Staged will whether the decoupler is enabled in the staging sequence.
//
// Allowed game scenes: any.
func (s *Decoupler) Staged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Staged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStaged will whether the decoupler is enabled in the staging sequence.
//
// Allowed game scenes: any.
func (s *Decoupler) StreamStaged() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Staged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Impulse will the impulse that the decoupler imparts when it is fired, in
// Newton seconds.
//
// Allowed game scenes: any.
func (s *Decoupler) Impulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Impulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamImpulse will the impulse that the decoupler imparts when it is fired,
// in Newton seconds.
//
// Allowed game scenes: any.
func (s *Decoupler) StreamImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Decoupler_get_Impulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Undock will undocks the docking port and returns the new <see
// cref="T:SpaceCenter.Vessel" /> that is created. This method can be called for
// either docking port in a docked pair. Throws an exception if the docking port
// is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) Undock() (Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Undock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUndock will undocks the docking port and returns the new <see
// cref="T:SpaceCenter.Vessel" /> that is created. This method can be called for
// either docking port in a docked pair. Throws an exception if the docking port
// is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamUndock() (*client.Stream[Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Undock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Position will the position of the docking port, in the given reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Position(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position of the docking port, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction that docking port points in, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Direction(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction that docking port points in, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rotation will the rotation of the docking port, in the given reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Rotation(referenceFrame ReferenceFrame) (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will the rotation of the docking port, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamRotation(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the current state of the docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) State() (DockingPortState, error) {
	var err error
	var argBytes []byte
	var vv DockingPortState
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamState() (*client.Stream[DockingPortState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) DockingPortState {
		var value DockingPortState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DockedPart will the part that this docking port is docked to. Returns nil if
// this docking port is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) DockedPart() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_DockedPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDockedPart will the part that this docking port is docked to. Returns
// nil if this docking port is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamDockedPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_DockedPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReengageDistance will the distance a docking port must move away when it
// undocks before it becomes ready to dock with another port, in meters.
//
// Allowed game scenes: any.
func (s *DockingPort) ReengageDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_ReengageDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReengageDistance will the distance a docking port must move away when
// it undocks before it becomes ready to dock with another port, in meters.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamReengageDistance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_ReengageDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasShield will whether the docking port has a shield.
//
// Allowed game scenes: any.
func (s *DockingPort) HasShield() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_HasShield",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasShield will whether the docking port has a shield.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamHasShield() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_HasShield",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Shielded will the state of the docking ports shield, if it has one.  Returns
// true if the docking port has a shield, and the shield is closed. Otherwise
// returns false. When set to true, the shield is closed, and when set to false
// the shield is opened. If the docking port does not have a shield, setting
// this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) Shielded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamShielded will the state of the docking ports shield, if it has one.
// Returns true if the docking port has a shield, and the shield is closed.
// Otherwise returns false. When set to true, the shield is closed, and when set
// to false the shield is opened. If the docking port does not have a shield,
// setting this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) StreamShielded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetShielded will the state of the docking ports shield, if it has one.
// Returns true if the docking port has a shield, and the shield is closed.
// Otherwise returns false. When set to true, the shield is closed, and when set
// to false the shield is opened. If the docking port does not have a shield,
// setting this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) SetShielded(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_set_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame will the reference frame that is fixed relative to this
// docking port, and oriented with the port. <list
// type="bullet"><item><description>The origin is at the position of the docking
// port. </description></item><item><description>The axes rotate with the
// docking port.</description></item><item><description>The x-axis points out to
// the right side of the docking port.
// </description></item><item><description>The y-axis points in the direction
// the docking port is facing. </description></item><item><description>The
// z-axis points out of the bottom off the docking port.
// </description></item></list>
//
// Allowed game scenes: any.
func (s *DockingPort) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame that is fixed relative to this
// docking port, and oriented with the port. <list
// type="bullet"><item><description>The origin is at the position of the docking
// port. </description></item><item><description>The axes rotate with the
// docking port.</description></item><item><description>The x-axis points out to
// the right side of the docking port.
// </description></item><item><description>The y-axis points in the direction
// the docking port is facing. </description></item><item><description>The
// z-axis points out of the bottom off the docking port.
// </description></item></list>
//
// Allowed game scenes: any.
func (s *DockingPort) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "DockingPort_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ToggleMode will toggle the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) ToggleMode() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_ToggleMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this engine.
//
// Allowed game scenes: any.
func (s *Engine) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this engine.
//
// Allowed game scenes: any.
func (s *Engine) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the engine is active. Setting this attribute may have no
// effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" /> and <see
// cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the engine is active. Setting this attribute may
// have no effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" />
// and <see cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActive will whether the engine is active. Setting this attribute may have
// no effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" /> and
// <see cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrust will the current amount of thrust being produced by the engine, in
// Newtons.
//
// Allowed game scenes: any.
func (s *Engine) Thrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrust will the current amount of thrust being produced by the engine,
// in Newtons.
//
// Allowed game scenes: any.
func (s *Engine) StreamThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableThrust will the amount of thrust, in Newtons, that would be produced
// by the engine when activated and with its throttle set to 100%. Returns zero
// if the engine does not have any fuel. Takes the engine's current <see
// cref="M:SpaceCenter.Engine.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *Engine) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableThrust will the amount of thrust, in Newtons, that would be
// produced by the engine when activated and with its throttle set to 100%.
// Returns zero if the engine does not have any fuel. Takes the engine's current
// <see cref="M:SpaceCenter.Engine.ThrustLimit" /> and atmospheric conditions
// into account.
//
// Allowed game scenes: any.
func (s *Engine) StreamAvailableThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxThrust will the amount of thrust, in Newtons, that would be produced by
// the engine when activated and fueled, with its throttle and throttle limiter
// set to 100%.
//
// Allowed game scenes: any.
func (s *Engine) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxThrust will the amount of thrust, in Newtons, that would be produced
// by the engine when activated and fueled, with its throttle and throttle
// limiter set to 100%.
//
// Allowed game scenes: any.
func (s *Engine) StreamMaxThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxVacuumThrust will the maximum amount of thrust that can be produced by the
// engine in a vacuum, in Newtons. This is the amount of thrust produced by the
// engine when activated, <see cref="M:SpaceCenter.Engine.ThrustLimit" /> is set
// to 100%, the main vessel's throttle is set to 100% and the engine is in a
// vacuum.
//
// Allowed game scenes: any.
func (s *Engine) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxVacuumThrust will the maximum amount of thrust that can be produced
// by the engine in a vacuum, in Newtons. This is the amount of thrust produced
// by the engine when activated, <see cref="M:SpaceCenter.Engine.ThrustLimit" />
// is set to 100%, the main vessel's throttle is set to 100% and the engine is
// in a vacuum.
//
// Allowed game scenes: any.
func (s *Engine) StreamMaxVacuumThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustLimit will the thrust limiter of the engine. A value between 0 and 1.
// Setting this attribute may have no effect, for example the thrust limit for a
// solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) ThrustLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustLimit will the thrust limiter of the engine. A value between 0
// and 1. Setting this attribute may have no effect, for example the thrust
// limit for a solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) StreamThrustLimit() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetThrustLimit will the thrust limiter of the engine. A value between 0 and
// 1. Setting this attribute may have no effect, for example the thrust limit
// for a solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) SetThrustLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrusters will the components of the engine that generate thrust.
//
// Allowed game scenes: any.
func (s *Engine) Thrusters() ([]Thruster, error) {
	var err error
	var argBytes []byte
	var vv []Thruster
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrusters will the components of the engine that generate thrust.
//
// Allowed game scenes: any.
func (s *Engine) StreamThrusters() (*client.Stream[[]Thruster], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Thruster {
		var value []Thruster
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SpecificImpulse will the current specific impulse of the engine, in seconds.
// Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpecificImpulse will the current specific impulse of the engine, in
// seconds. Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) StreamSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// VacuumSpecificImpulse will the vacuum specific impulse of the engine, in
// seconds.
//
// Allowed game scenes: any.
func (s *Engine) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVacuumSpecificImpulse will the vacuum specific impulse of the engine,
// in seconds.
//
// Allowed game scenes: any.
func (s *Engine) StreamVacuumSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse will the specific impulse of the engine at sea
// level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *Engine) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamKerbinSeaLevelSpecificImpulse will the specific impulse of the engine
// at sea level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *Engine) StreamKerbinSeaLevelSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PropellantNames will the names of the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) PropellantNames() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Engine_get_PropellantNames",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPropellantNames will the names of the propellants that the engine
// consumes.
//
// Allowed game scenes: any.
func (s *Engine) StreamPropellantNames() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_PropellantNames",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Propellants will the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) Propellants() ([]Propellant, error) {
	var err error
	var argBytes []byte
	var vv []Propellant
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPropellants will the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) StreamPropellants() (*client.Stream[[]Propellant], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Propellant {
		var value []Propellant
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PropellantRatios will the ratio of resources that the engine consumes. A
// dictionary mapping resource names to the ratio at which they are consumed by
// the engine.
//
// Allowed game scenes: any.
func (s *Engine) PropellantRatios() (map[string]float32, error) {
	var err error
	var argBytes []byte
	var vv map[string]float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPropellantRatios will the ratio of resources that the engine consumes.
// A dictionary mapping resource names to the ratio at which they are consumed
// by the engine.
//
// Allowed game scenes: any.
func (s *Engine) StreamPropellantRatios() (*client.Stream[map[string]float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]float32 {
		var value map[string]float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasFuel will whether the engine has any fuel available.
//
// Allowed game scenes: any.
func (s *Engine) HasFuel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasFuel will whether the engine has any fuel available.
//
// Allowed game scenes: any.
func (s *Engine) StreamHasFuel() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Throttle will the current throttle setting for the engine. A value between 0
// and 1. This is not necessarily the same as the vessel's main throttle
// setting, as some engines take time to adjust their throttle (such as jet
// engines).
//
// Allowed game scenes: any.
func (s *Engine) Throttle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrottle will the current throttle setting for the engine. A value
// between 0 and 1. This is not necessarily the same as the vessel's main
// throttle setting, as some engines take time to adjust their throttle (such as
// jet engines).
//
// Allowed game scenes: any.
func (s *Engine) StreamThrottle() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrottleLocked will whether the <see cref="M:SpaceCenter.Control.Throttle" />
// affects the engine. For example, this is true for liquid fueled rockets, and
// false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) ThrottleLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_ThrottleLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrottleLocked will whether the <see
// cref="M:SpaceCenter.Control.Throttle" /> affects the engine. For example,
// this is true for liquid fueled rockets, and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) StreamThrottleLocked() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_ThrottleLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanRestart will whether the engine can be restarted once shutdown. If the
// engine cannot be shutdown, returns false. For example, this is true for
// liquid fueled rockets and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanRestart() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_CanRestart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanRestart will whether the engine can be restarted once shutdown. If
// the engine cannot be shutdown, returns false. For example, this is true for
// liquid fueled rockets and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) StreamCanRestart() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_CanRestart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CanShutdown will whether the engine can be shutdown once activated. For
// example, this is true for liquid fueled rockets and false for solid rocket
// boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanShutdown() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_CanShutdown",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCanShutdown will whether the engine can be shutdown once activated. For
// example, this is true for liquid fueled rockets and false for solid rocket
// boosters.
//
// Allowed game scenes: any.
func (s *Engine) StreamCanShutdown() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_CanShutdown",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasModes will whether the engine has multiple modes of operation.
//
// Allowed game scenes: any.
func (s *Engine) HasModes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_HasModes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasModes will whether the engine has multiple modes of operation.
//
// Allowed game scenes: any.
func (s *Engine) StreamHasModes() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_HasModes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Mode will the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) Mode() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMode will the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) StreamMode() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMode will the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) SetMode(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Modes will the available modes for the engine. A dictionary mapping mode
// names to <see cref="T:SpaceCenter.Engine" /> objects.
//
// Allowed game scenes: any.
func (s *Engine) Modes() (map[string]Engine, error) {
	var err error
	var argBytes []byte
	var vv map[string]Engine
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Modes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamModes will the available modes for the engine. A dictionary mapping
// mode names to <see cref="T:SpaceCenter.Engine" /> objects.
//
// Allowed game scenes: any.
func (s *Engine) StreamModes() (*client.Stream[map[string]Engine], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Modes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]Engine {
		var value map[string]Engine
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AutoModeSwitch will whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) AutoModeSwitch() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAutoModeSwitch will whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) StreamAutoModeSwitch() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAutoModeSwitch will whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) SetAutoModeSwitch(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Gimballed will whether the engine is gimballed.
//
// Allowed game scenes: any.
func (s *Engine) Gimballed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimballed will whether the engine is gimballed.
//
// Allowed game scenes: any.
func (s *Engine) StreamGimballed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GimbalRange will the range over which the gimbal can move, in degrees.
// Returns 0 if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalRange() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalRange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimbalRange will the range over which the gimbal can move, in degrees.
// Returns 0 if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) StreamGimbalRange() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalRange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GimbalLocked will whether the engines gimbal is locked in place. Setting this
// attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimbalLocked will whether the engines gimbal is locked in place.
// Setting this attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) StreamGimbalLocked() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetGimbalLocked will whether the engines gimbal is locked in place. Setting
// this attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) SetGimbalLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// GimbalLimit will the gimbal limiter of the engine. A value between 0 and 1.
// Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimbalLimit will the gimbal limiter of the engine. A value between 0
// and 1. Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) StreamGimbalLimit() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetGimbalLimit will the gimbal limiter of the engine. A value between 0 and
// 1. Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) SetGimbalLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_set_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableTorque will the available torque, in Newton meters, that can be
// produced by this engine, in the positive and negative pitch, roll and yaw
// axes of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the engine is
// inactive, or not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) AvailableTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableTorque will the available torque, in Newton meters, that can
// be produced by this engine, in the positive and negative pitch, roll and yaw
// axes of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the engine is
// inactive, or not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) StreamAvailableTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Engine_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Run will run the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Run() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_Run",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Transmit will transmit all experimental data contained by this part.
//
// Allowed game scenes: any.
func (s *Experiment) Transmit() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_Transmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Dump will dump the experimental data contained by the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Dump() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_Dump",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Reset will reset the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Reset() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_Reset",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will internal name of the experiment, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>.
//
// Allowed game scenes: any.
func (s *Experiment) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will internal name of the experiment, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>.
//
// Allowed game scenes: any.
func (s *Experiment) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Title will title of the experiment, as shown on the in-game UI.
//
// Allowed game scenes: any.
func (s *Experiment) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTitle will title of the experiment, as shown on the in-game UI.
//
// Allowed game scenes: any.
func (s *Experiment) StreamTitle() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Inoperable will whether the experiment is inoperable.
//
// Allowed game scenes: any.
func (s *Experiment) Inoperable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Inoperable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInoperable will whether the experiment is inoperable.
//
// Allowed game scenes: any.
func (s *Experiment) StreamInoperable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Inoperable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the experiment has been deployed.
//
// Allowed game scenes: any.
func (s *Experiment) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the experiment has been deployed.
//
// Allowed game scenes: any.
func (s *Experiment) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rerunnable will whether the experiment can be re-run.
//
// Allowed game scenes: any.
func (s *Experiment) Rerunnable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Rerunnable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRerunnable will whether the experiment can be re-run.
//
// Allowed game scenes: any.
func (s *Experiment) StreamRerunnable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Rerunnable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasData will whether the experiment contains data.
//
// Allowed game scenes: any.
func (s *Experiment) HasData() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_HasData",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasData will whether the experiment contains data.
//
// Allowed game scenes: any.
func (s *Experiment) StreamHasData() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_HasData",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Data will the data contained in this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Data() ([]ScienceData, error) {
	var err error
	var argBytes []byte
	var vv []ScienceData
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Data",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamData will the data contained in this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) StreamData() (*client.Stream[[]ScienceData], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Data",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ScienceData {
		var value []ScienceData
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Available will determines if the experiment is available given the current
// conditions.
//
// Allowed game scenes: any.
func (s *Experiment) Available() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Available",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailable will determines if the experiment is available given the
// current conditions.
//
// Allowed game scenes: any.
func (s *Experiment) StreamAvailable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Available",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Biome will the name of the biome the experiment is currently in.
//
// Allowed game scenes: any.
func (s *Experiment) Biome() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBiome will the name of the biome the experiment is currently in.
//
// Allowed game scenes: any.
func (s *Experiment) StreamBiome() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScienceSubject will containing information on the corresponding specific
// science result for the current conditions. Returns nil if the experiment is
// unavailable.
//
// Allowed game scenes: any.
func (s *Experiment) ScienceSubject() (ScienceSubject, error) {
	var err error
	var argBytes []byte
	var vv ScienceSubject
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_ScienceSubject",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScienceSubject will containing information on the corresponding
// specific science result for the current conditions. Returns nil if the
// experiment is unavailable.
//
// Allowed game scenes: any.
func (s *Experiment) StreamScienceSubject() (*client.Stream[ScienceSubject], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Experiment_get_ScienceSubject",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ScienceSubject {
		var value ScienceSubject
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Jettison will jettison the fairing. Has no effect if it has already been
// jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) Jettison() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Fairing_Jettison",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this fairing.
//
// Allowed game scenes: any.
func (s *Fairing) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Fairing_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this fairing.
//
// Allowed game scenes: any.
func (s *Fairing) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Fairing_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Jettisoned will whether the fairing has been jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) Jettisoned() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Fairing_get_Jettisoned",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamJettisoned will whether the fairing has been jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) StreamJettisoned() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Fairing_get_Jettisoned",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Remove will remove the force.
//
// Allowed game scenes: any.
func (s *Force) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part that this force is applied to.
//
// Allowed game scenes: any.
func (s *Force) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Force_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part that this force is applied to.
//
// Allowed game scenes: any.
func (s *Force) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ForceVector will the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) ForceVector() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Force_get_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamForceVector will the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) StreamForceVector() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_get_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetForceVector will the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) SetForceVector(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_set_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position will the position at which the force acts, in reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) Position() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Force_get_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position at which the force acts, in reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) StreamPosition() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_get_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPosition will the position at which the force acts, in reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) SetPosition(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_set_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame will the reference frame of the force vector and position.
//
// Allowed game scenes: any.
func (s *Force) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Force_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame of the force vector and
// position.
//
// Allowed game scenes: any.
func (s *Force) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReferenceFrame will the reference frame of the force vector and position.
//
// Allowed game scenes: any.
func (s *Force) SetReferenceFrame(value ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Force_set_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this intake.
//
// Allowed game scenes: any.
func (s *Intake) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this intake.
//
// Allowed game scenes: any.
func (s *Intake) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Open will whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) Open() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOpen will whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) StreamOpen() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetOpen will whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) SetOpen(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_set_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Speed will speed of the flow into the intake, in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Intake) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeed will speed of the flow into the intake, in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Intake) StreamSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Flow will the rate of flow into the intake, in units of resource per second.
//
// Allowed game scenes: any.
func (s *Intake) Flow() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Flow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFlow will the rate of flow into the intake, in units of resource per
// second.
//
// Allowed game scenes: any.
func (s *Intake) StreamFlow() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Flow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Area will the area of the intake's opening, in square meters.
//
// Allowed game scenes: any.
func (s *Intake) Area() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Area",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamArea will the area of the intake's opening, in square meters.
//
// Allowed game scenes: any.
func (s *Intake) StreamArea() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Intake_get_Area",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Release will releases the docking clamp. Has no effect if the clamp has
// already been released.
//
// Allowed game scenes: any.
func (s *LaunchClamp) Release() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchClamp_Release",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this launch clamp.
//
// Allowed game scenes: any.
func (s *LaunchClamp) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "LaunchClamp_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this launch clamp.
//
// Allowed game scenes: any.
func (s *LaunchClamp) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "LaunchClamp_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this landing leg.
//
// Allowed game scenes: any.
func (s *Leg) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this landing leg.
//
// Allowed game scenes: any.
func (s *Leg) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the current state of the landing leg.
//
// Allowed game scenes: any.
func (s *Leg) State() (LegState, error) {
	var err error
	var argBytes []byte
	var vv LegState
	request := &api.ProcedureCall{
		Procedure: "Leg_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the landing leg.
//
// Allowed game scenes: any.
func (s *Leg) StreamState() (*client.Stream[LegState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) LegState {
		var value LegState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployable will whether the leg is deployable.
//
// Allowed game scenes: any.
func (s *Leg) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployable will whether the leg is deployable.
//
// Allowed game scenes: any.
func (s *Leg) StreamDeployable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsGrounded will returns whether the leg is touching the ground.
//
// Allowed game scenes: any.
func (s *Leg) IsGrounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Leg_get_IsGrounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsGrounded will returns whether the leg is touching the ground.
//
// Allowed game scenes: any.
func (s *Leg) StreamIsGrounded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Leg_get_IsGrounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this light.
//
// Allowed game scenes: any.
func (s *Light) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Light_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this light.
//
// Allowed game scenes: any.
func (s *Light) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Light_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActive will whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color will the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) Color() (api.Tuple3[float32, float32, float32], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float32, float32, float32]
	request := &api.ProcedureCall{
		Procedure: "Light_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColor will the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) StreamColor() (*client.Stream[api.Tuple3[float32, float32, float32]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float32, float32, float32] {
		var value api.Tuple3[float32, float32, float32]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetColor will the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) SetColor(value api.Tuple3[float32, float32, float32]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_set_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PowerUsage will the current power usage, in units of charge per second.
//
// Allowed game scenes: any.
func (s *Light) PowerUsage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Light_get_PowerUsage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPowerUsage will the current power usage, in units of charge per second.
//
// Allowed game scenes: any.
func (s *Light) StreamPowerUsage() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Light_get_PowerUsage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasField will returns true if the module has a field with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasField(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Module_HasField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasField will returns true if the module has a field with the given
// name.
//
// Allowed game scenes: any.
func (s *Module) StreamHasField(name string) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_HasField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GetField will returns the value of a field.
//
// Allowed game scenes: any.
func (s *Module) GetField(name string) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Module_GetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetField will returns the value of a field.
//
// Allowed game scenes: any.
func (s *Module) StreamGetField(name string) (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_GetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetFieldInt will set the value of a field to the given integer number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldInt(name string, value int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_SetFieldInt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldFloat will set the value of a field to the given floating point
// number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldFloat(name string, value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_SetFieldFloat",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldString will set the value of a field to the given string.
//
// Allowed game scenes: any.
func (s *Module) SetFieldString(name string, value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_SetFieldString",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResetField will set the value of a field to its original value.
//
// Allowed game scenes: any.
func (s *Module) ResetField(name string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_ResetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasEvent will true if the module has an event with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasEvent(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Module_HasEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasEvent will true if the module has an event with the given name.
//
// Allowed game scenes: any.
func (s *Module) StreamHasEvent(name string) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_HasEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TriggerEvent will trigger the named event. Equivalent to clicking the button
// in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) TriggerEvent(name string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_TriggerEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasAction will true if the part has an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasAction(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Module_HasAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasAction will true if the part has an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) StreamHasAction(name string) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_HasAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAction will set the value of an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) SetAction(name string, value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_SetAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name will name of the PartModule. For example, "ModuleEngines".
//
// Allowed game scenes: any.
func (s *Module) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Module_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will name of the PartModule. For example, "ModuleEngines".
//
// Allowed game scenes: any.
func (s *Module) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part that contains this module.
//
// Allowed game scenes: any.
func (s *Module) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Module_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part that contains this module.
//
// Allowed game scenes: any.
func (s *Module) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Fields will the modules field names and their associated values, as a
// dictionary. These are the values visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) Fields() (map[string]string, error) {
	var err error
	var argBytes []byte
	var vv map[string]string
	request := &api.ProcedureCall{
		Procedure: "Module_get_Fields",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFields will the modules field names and their associated values, as a
// dictionary. These are the values visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) StreamFields() (*client.Stream[map[string]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_get_Fields",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]string {
		var value map[string]string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Events will a list of the names of all of the modules events. Events are the
// clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) Events() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Module_get_Events",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEvents will a list of the names of all of the modules events. Events
// are the clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) StreamEvents() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_get_Events",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Actions will a list of all the names of the modules actions. These are the
// parts actions that can be assigned to action groups in the in-game editor.
//
// Allowed game scenes: any.
func (s *Module) Actions() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Module_get_Actions",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActions will a list of all the names of the modules actions. These are
// the parts actions that can be assigned to action groups in the in-game
// editor.
//
// Allowed game scenes: any.
func (s *Module) StreamActions() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Module_get_Actions",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deploy will deploys the parachute. This has no effect if the parachute has
// already been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Deploy() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_Deploy",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Arm will deploys the parachute. This has no effect if the parachute has
// already been armed or deployed. Only applicable to RealChutes parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) Arm() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_Arm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part object for this parachute.
//
// Allowed game scenes: any.
func (s *Parachute) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this parachute.
//
// Allowed game scenes: any.
func (s *Parachute) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the parachute has been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the parachute has been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Armed will whether the parachute has been armed or deployed. Only applicable
// to RealChutes parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) Armed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Armed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamArmed will whether the parachute has been armed or deployed. Only
// applicable to RealChutes parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) StreamArmed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_Armed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the current state of the parachute.
//
// Allowed game scenes: any.
func (s *Parachute) State() (ParachuteState, error) {
	var err error
	var argBytes []byte
	var vv ParachuteState
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the parachute.
//
// Allowed game scenes: any.
func (s *Parachute) StreamState() (*client.Stream[ParachuteState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ParachuteState {
		var value ParachuteState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DeployAltitude will the altitude at which the parachute will full deploy, in
// meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployAltitude() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployAltitude will the altitude at which the parachute will full
// deploy, in meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) StreamDeployAltitude() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployAltitude will the altitude at which the parachute will full deploy,
// in meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) SetDeployAltitude(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_set_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DeployMinPressure will the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployMinPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployMinPressure will the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) StreamDeployMinPressure() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_get_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployMinPressure will the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) SetDeployMinPressure(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parachute_set_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position will the position of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Position(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) StreamPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CenterOfMass will the position of the parts center of mass in the given
// reference frame. If the part is physicsless, this is equivalent to <see
// cref="M:SpaceCenter.Part.Position" />.
//
// Allowed game scenes: any.
func (s *Part) CenterOfMass(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCenterOfMass will the position of the parts center of mass in the given
// reference frame. If the part is physicsless, this is equivalent to <see
// cref="M:SpaceCenter.Part.Position" />.
//
// Allowed game scenes: any.
func (s *Part) StreamCenterOfMass(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BoundingBox will the axis-aligned bounding box of the part in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Part) BoundingBox(referenceFrame ReferenceFrame) (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Part_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBoundingBox will the axis-aligned bounding box of the part in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Part) StreamBoundingBox(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction the part points in, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Part) Direction(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction the part points in, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Part) StreamDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Velocity will the linear velocity of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Velocity(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVelocity will the linear velocity of the part in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Part) StreamVelocity(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rotation will the rotation of the part, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Rotation(referenceFrame ReferenceFrame) (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will the rotation of the part, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) StreamRotation(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddForce will exert a constant force on the part, acting at the given
// position.
//
// Allowed game scenes: any.
func (s *Part) AddForce(force api.Tuple3[float64, float64, float64], position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (Force, error) {
	var err error
	var argBytes []byte
	var vv Force
	request := &api.ProcedureCall{
		Procedure: "Part_AddForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(force)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddForce will exert a constant force on the part, acting at the given
// position.
//
// Allowed game scenes: any.
func (s *Part) StreamAddForce(force api.Tuple3[float64, float64, float64], position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) (*client.Stream[Force], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_AddForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(force)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Force {
		var value Force
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InstantaneousForce will exert an instantaneous force on the part, acting at
// the given position.
//
// Allowed game scenes: any.
func (s *Part) InstantaneousForce(force api.Tuple3[float64, float64, float64], position api.Tuple3[float64, float64, float64], referenceFrame ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_InstantaneousForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(force)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name will internal name of the part, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>. For example "Mark1-2Pod".
//
// Allowed game scenes: any.
func (s *Part) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Part_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will internal name of the part, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>. For example "Mark1-2Pod".
//
// Allowed game scenes: any.
func (s *Part) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Title will title of the part, as shown when the part is right clicked
// in-game. For example "Mk1-2 Command Pod".
//
// Allowed game scenes: any.
func (s *Part) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Part_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTitle will title of the part, as shown when the part is right clicked
// in-game. For example "Mk1-2 Command Pod".
//
// Allowed game scenes: any.
func (s *Part) StreamTitle() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Tag will the name tag for the part. Can be set to a custom string using the
// in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) Tag() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Part_get_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTag will the name tag for the part. Can be set to a custom string using
// the in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) StreamTag() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTag will the name tag for the part. Can be set to a custom string using
// the in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) SetTag(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_set_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Highlighted will whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) Highlighted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHighlighted will whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) StreamHighlighted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetHighlighted will whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) SetHighlighted(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_set_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HighlightColor will the color used to highlight the part, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Part) HighlightColor() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_get_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHighlightColor will the color used to highlight the part, as an RGB
// triple.
//
// Allowed game scenes: any.
func (s *Part) StreamHighlightColor() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetHighlightColor will the color used to highlight the part, as an RGB
// triple.
//
// Allowed game scenes: any.
func (s *Part) SetHighlightColor(value api.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_set_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Cost will the cost of the part, in units of funds.
//
// Allowed game scenes: any.
func (s *Part) Cost() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_Cost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCost will the cost of the part, in units of funds.
//
// Allowed game scenes: any.
func (s *Part) StreamCost() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Cost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Vessel will the vessel that contains this part.
//
// Allowed game scenes: any.
func (s *Part) Vessel() (Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &api.ProcedureCall{
		Procedure: "Part_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVessel will the vessel that contains this part.
//
// Allowed game scenes: any.
func (s *Part) StreamVessel() (*client.Stream[Vessel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Vessel {
		var value Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parent will the parts parent. Returns nil if the part does not have a parent.
// This, in combination with <see cref="M:SpaceCenter.Part.Children" />, can be
// used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) Parent() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Part_get_Parent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParent will the parts parent. Returns nil if the part does not have a
// parent. This, in combination with <see cref="M:SpaceCenter.Part.Children" />,
// can be used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) StreamParent() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Parent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Children will the parts children. Returns an empty list if the part has no
// children. This, in combination with <see cref="M:SpaceCenter.Part.Parent" />,
// can be used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) Children() ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Part_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamChildren will the parts children. Returns an empty list if the part has
// no children. This, in combination with <see cref="M:SpaceCenter.Part.Parent"
// />, can be used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) StreamChildren() (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AxiallyAttached will whether the part is axially attached to its parent, i.e.
// on the top or bottom of its parent. If the part has no parent, returns false.
//
// Allowed game scenes: any.
func (s *Part) AxiallyAttached() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_AxiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAxiallyAttached will whether the part is axially attached to its
// parent, i.e. on the top or bottom of its parent. If the part has no parent,
// returns false.
//
// Allowed game scenes: any.
func (s *Part) StreamAxiallyAttached() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_AxiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RadiallyAttached will whether the part is radially attached to its parent,
// i.e. on the side of its parent. If the part has no parent, returns false.
//
// Allowed game scenes: any.
func (s *Part) RadiallyAttached() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_RadiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiallyAttached will whether the part is radially attached to its
// parent, i.e. on the side of its parent. If the part has no parent, returns
// false.
//
// Allowed game scenes: any.
func (s *Part) StreamRadiallyAttached() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_RadiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Stage will the stage in which this part will be activated. Returns -1 if the
// part is not activated by staging.
//
// Allowed game scenes: any.
func (s *Part) Stage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Part_get_Stage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStage will the stage in which this part will be activated. Returns -1
// if the part is not activated by staging.
//
// Allowed game scenes: any.
func (s *Part) StreamStage() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Stage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DecoupleStage will the stage in which this part will be decoupled. Returns -1
// if the part is never decoupled from the vessel.
//
// Allowed game scenes: any.
func (s *Part) DecoupleStage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Part_get_DecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecoupleStage will the stage in which this part will be decoupled.
// Returns -1 if the part is never decoupled from the vessel.
//
// Allowed game scenes: any.
func (s *Part) StreamDecoupleStage() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_DecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Massless will whether the part is <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Massless_part">massless</a>.
//
// Allowed game scenes: any.
func (s *Part) Massless() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_Massless",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMassless will whether the part is <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Massless_part">massless</a>.
//
// Allowed game scenes: any.
func (s *Part) StreamMassless() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Massless",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Mass will the current mass of the part, including resources it contains, in
// kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) Mass() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMass will the current mass of the part, including resources it
// contains, in kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) StreamMass() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DryMass will the mass of the part, not including any resources it contains,
// in kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) DryMass() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDryMass will the mass of the part, not including any resources it
// contains, in kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) StreamDryMass() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Shielded will whether the part is shielded from the exterior of the vessel,
// for example by a fairing.
//
// Allowed game scenes: any.
func (s *Part) Shielded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamShielded will whether the part is shielded from the exterior of the
// vessel, for example by a fairing.
//
// Allowed game scenes: any.
func (s *Part) StreamShielded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DynamicPressure will the dynamic pressure acting on the part, in Pascals.
//
// Allowed game scenes: any.
func (s *Part) DynamicPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDynamicPressure will the dynamic pressure acting on the part, in
// Pascals.
//
// Allowed game scenes: any.
func (s *Part) StreamDynamicPressure() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ImpactTolerance will the impact tolerance of the part, in meters per second.
//
// Allowed game scenes: any.
func (s *Part) ImpactTolerance() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_ImpactTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamImpactTolerance will the impact tolerance of the part, in meters per
// second.
//
// Allowed game scenes: any.
func (s *Part) StreamImpactTolerance() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ImpactTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Temperature will temperature of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) Temperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_Temperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTemperature will temperature of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamTemperature() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Temperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SkinTemperature will temperature of the skin of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) SkinTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_SkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSkinTemperature will temperature of the skin of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamSkinTemperature() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_SkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxTemperature will maximum temperature that the part can survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_MaxTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxTemperature will maximum temperature that the part can survive, in
// Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamMaxTemperature() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_MaxTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxSkinTemperature will maximum temperature that the skin of the part can
// survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxSkinTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_MaxSkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxSkinTemperature will maximum temperature that the skin of the part
// can survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamMaxSkinTemperature() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_MaxSkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalMass will a measure of how much energy it takes to increase the
// internal temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalMass will a measure of how much energy it takes to increase the
// internal temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalSkinMass will a measure of how much energy it takes to increase the
// skin temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalSkinMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalSkinMass will a measure of how much energy it takes to increase
// the skin temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalSkinMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalSkinMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalResourceMass will a measure of how much energy it takes to increase
// the temperature of the resources contained in the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalResourceMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalResourceMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalResourceMass will a measure of how much energy it takes to
// increase the temperature of the resources contained in the part, in Joules
// per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalResourceMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalResourceMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalInternalFlux will the rate at which heat energy is begin generated by
// the part. For example, some engines generate heat by combusting fuel.
// Measured in energy per unit time, or power, in Watts. A positive value means
// the part is gaining heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalInternalFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalInternalFlux will the rate at which heat energy is begin
// generated by the part. For example, some engines generate heat by combusting
// fuel. Measured in energy per unit time, or power, in Watts. A positive value
// means the part is gaining heat energy, and negative means it is losing heat
// energy.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalInternalFlux() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalConductionFlux will the rate at which heat energy is conducting into
// or out of the part via contact with other parts. Measured in energy per unit
// time, or power, in Watts. A positive value means the part is gaining heat
// energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConductionFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalConductionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalConductionFlux will the rate at which heat energy is conducting
// into or out of the part via contact with other parts. Measured in energy per
// unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalConductionFlux() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalConductionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalConvectionFlux will the rate at which heat energy is convecting into
// or out of the part from the surrounding atmosphere. Measured in energy per
// unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConvectionFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalConvectionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalConvectionFlux will the rate at which heat energy is convecting
// into or out of the part from the surrounding atmosphere. Measured in energy
// per unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalConvectionFlux() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalConvectionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalRadiationFlux will the rate at which heat energy is radiating into or
// out of the part from the surrounding environment. Measured in energy per unit
// time, or power, in Watts. A positive value means the part is gaining heat
// energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalRadiationFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalRadiationFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalRadiationFlux will the rate at which heat energy is radiating
// into or out of the part from the surrounding environment. Measured in energy
// per unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalRadiationFlux() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalRadiationFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalSkinToInternalFlux will the rate at which heat energy is transferring
// between the part's skin and its internals. Measured in energy per unit time,
// or power, in Watts. A positive value means the part's internals are gaining
// heat energy, and negative means its skin is gaining heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinToInternalFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalSkinToInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalSkinToInternalFlux will the rate at which heat energy is
// transferring between the part's skin and its internals. Measured in energy
// per unit time, or power, in Watts. A positive value means the part's
// internals are gaining heat energy, and negative means its skin is gaining
// heat energy.
//
// Allowed game scenes: any.
func (s *Part) StreamThermalSkinToInternalFlux() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ThermalSkinToInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Resources will a <see cref="T:SpaceCenter.Resources" /> object for the part.
//
// Allowed game scenes: any.
func (s *Part) Resources() (Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &api.ProcedureCall{
		Procedure: "Part_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResources will a <see cref="T:SpaceCenter.Resources" /> object for the
// part.
//
// Allowed game scenes: any.
func (s *Part) StreamResources() (*client.Stream[Resources], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Resources {
		var value Resources
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Crossfeed will whether this part is crossfeed capable.
//
// Allowed game scenes: any.
func (s *Part) Crossfeed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_Crossfeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCrossfeed will whether this part is crossfeed capable.
//
// Allowed game scenes: any.
func (s *Part) StreamCrossfeed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Crossfeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsFuelLine will whether this part is a fuel line.
//
// Allowed game scenes: any.
func (s *Part) IsFuelLine() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Part_get_IsFuelLine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsFuelLine will whether this part is a fuel line.
//
// Allowed game scenes: any.
func (s *Part) StreamIsFuelLine() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_IsFuelLine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FuelLinesFrom will the parts that are connected to this part via fuel lines,
// where the direction of the fuel line is into this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesFrom() ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Part_get_FuelLinesFrom",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFuelLinesFrom will the parts that are connected to this part via fuel
// lines, where the direction of the fuel line is into this part.
//
// Allowed game scenes: any.
func (s *Part) StreamFuelLinesFrom() (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_FuelLinesFrom",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FuelLinesTo will the parts that are connected to this part via fuel lines,
// where the direction of the fuel line is out of this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesTo() ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Part_get_FuelLinesTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFuelLinesTo will the parts that are connected to this part via fuel
// lines, where the direction of the fuel line is out of this part.
//
// Allowed game scenes: any.
func (s *Part) StreamFuelLinesTo() (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_FuelLinesTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Modules will the modules for this part.
//
// Allowed game scenes: any.
func (s *Part) Modules() ([]Module, error) {
	var err error
	var argBytes []byte
	var vv []Module
	request := &api.ProcedureCall{
		Procedure: "Part_get_Modules",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamModules will the modules for this part.
//
// Allowed game scenes: any.
func (s *Part) StreamModules() (*client.Stream[[]Module], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Modules",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Module {
		var value []Module
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Antenna will a <see cref="T:SpaceCenter.Antenna" /> if the part is an
// antenna, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Antenna() (Antenna, error) {
	var err error
	var argBytes []byte
	var vv Antenna
	request := &api.ProcedureCall{
		Procedure: "Part_get_Antenna",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntenna will a <see cref="T:SpaceCenter.Antenna" /> if the part is an
// antenna, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamAntenna() (*client.Stream[Antenna], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Antenna",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Antenna {
		var value Antenna
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CargoBay will a <see cref="T:SpaceCenter.CargoBay" /> if the part is a cargo
// bay, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) CargoBay() (CargoBay, error) {
	var err error
	var argBytes []byte
	var vv CargoBay
	request := &api.ProcedureCall{
		Procedure: "Part_get_CargoBay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCargoBay will a <see cref="T:SpaceCenter.CargoBay" /> if the part is a
// cargo bay, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamCargoBay() (*client.Stream[CargoBay], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_CargoBay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CargoBay {
		var value CargoBay
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ControlSurface will a <see cref="T:SpaceCenter.ControlSurface" /> if the part
// is an aerodynamic control surface, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ControlSurface() (ControlSurface, error) {
	var err error
	var argBytes []byte
	var vv ControlSurface
	request := &api.ProcedureCall{
		Procedure: "Part_get_ControlSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamControlSurface will a <see cref="T:SpaceCenter.ControlSurface" /> if
// the part is an aerodynamic control surface, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamControlSurface() (*client.Stream[ControlSurface], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ControlSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ControlSurface {
		var value ControlSurface
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Decoupler will a <see cref="T:SpaceCenter.Decoupler" /> if the part is a
// decoupler, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Decoupler() (Decoupler, error) {
	var err error
	var argBytes []byte
	var vv Decoupler
	request := &api.ProcedureCall{
		Procedure: "Part_get_Decoupler",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecoupler will a <see cref="T:SpaceCenter.Decoupler" /> if the part is
// a decoupler, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamDecoupler() (*client.Stream[Decoupler], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Decoupler",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Decoupler {
		var value Decoupler
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DockingPort will a <see cref="T:SpaceCenter.DockingPort" /> if the part is a
// docking port, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) DockingPort() (DockingPort, error) {
	var err error
	var argBytes []byte
	var vv DockingPort
	request := &api.ProcedureCall{
		Procedure: "Part_get_DockingPort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDockingPort will a <see cref="T:SpaceCenter.DockingPort" /> if the part
// is a docking port, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamDockingPort() (*client.Stream[DockingPort], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_DockingPort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) DockingPort {
		var value DockingPort
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Engine will an <see cref="T:SpaceCenter.Engine" /> if the part is an engine,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Engine() (Engine, error) {
	var err error
	var argBytes []byte
	var vv Engine
	request := &api.ProcedureCall{
		Procedure: "Part_get_Engine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEngine will an <see cref="T:SpaceCenter.Engine" /> if the part is an
// engine, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamEngine() (*client.Stream[Engine], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Engine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Engine {
		var value Engine
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Experiment will an <see cref="T:SpaceCenter.Experiment" /> if the part
// contains a single science experiment, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Experiment() (Experiment, error) {
	var err error
	var argBytes []byte
	var vv Experiment
	request := &api.ProcedureCall{
		Procedure: "Part_get_Experiment",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExperiment will an <see cref="T:SpaceCenter.Experiment" /> if the part
// contains a single science experiment, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamExperiment() (*client.Stream[Experiment], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Experiment",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Experiment {
		var value Experiment
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Experiments will a list of <see cref="T:SpaceCenter.Experiment" /> objects
// that the part contains.
//
// Allowed game scenes: any.
func (s *Part) Experiments() ([]Experiment, error) {
	var err error
	var argBytes []byte
	var vv []Experiment
	request := &api.ProcedureCall{
		Procedure: "Part_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExperiments will a list of <see cref="T:SpaceCenter.Experiment" />
// objects that the part contains.
//
// Allowed game scenes: any.
func (s *Part) StreamExperiments() (*client.Stream[[]Experiment], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Experiment {
		var value []Experiment
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Fairing will a <see cref="T:SpaceCenter.Fairing" /> if the part is a fairing,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Fairing() (Fairing, error) {
	var err error
	var argBytes []byte
	var vv Fairing
	request := &api.ProcedureCall{
		Procedure: "Part_get_Fairing",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFairing will a <see cref="T:SpaceCenter.Fairing" /> if the part is a
// fairing, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamFairing() (*client.Stream[Fairing], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Fairing",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Fairing {
		var value Fairing
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Intake will an <see cref="T:SpaceCenter.Intake" /> if the part is an intake,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Intake() (Intake, error) {
	var err error
	var argBytes []byte
	var vv Intake
	request := &api.ProcedureCall{
		Procedure: "Part_get_Intake",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIntake will an <see cref="T:SpaceCenter.Intake" /> if the part is an
// intake, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamIntake() (*client.Stream[Intake], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Intake",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Intake {
		var value Intake
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Leg will a <see cref="T:SpaceCenter.Leg" /> if the part is a landing leg,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Leg() (Leg, error) {
	var err error
	var argBytes []byte
	var vv Leg
	request := &api.ProcedureCall{
		Procedure: "Part_get_Leg",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLeg will a <see cref="T:SpaceCenter.Leg" /> if the part is a landing
// leg, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamLeg() (*client.Stream[Leg], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Leg",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Leg {
		var value Leg
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LaunchClamp will a <see cref="T:SpaceCenter.LaunchClamp" /> if the part is a
// launch clamp, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) LaunchClamp() (LaunchClamp, error) {
	var err error
	var argBytes []byte
	var vv LaunchClamp
	request := &api.ProcedureCall{
		Procedure: "Part_get_LaunchClamp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLaunchClamp will a <see cref="T:SpaceCenter.LaunchClamp" /> if the part
// is a launch clamp, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamLaunchClamp() (*client.Stream[LaunchClamp], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_LaunchClamp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) LaunchClamp {
		var value LaunchClamp
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Light will a <see cref="T:SpaceCenter.Light" /> if the part is a light,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Light() (Light, error) {
	var err error
	var argBytes []byte
	var vv Light
	request := &api.ProcedureCall{
		Procedure: "Part_get_Light",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLight will a <see cref="T:SpaceCenter.Light" /> if the part is a light,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamLight() (*client.Stream[Light], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Light",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Light {
		var value Light
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parachute will a <see cref="T:SpaceCenter.Parachute" /> if the part is a
// parachute, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Parachute() (Parachute, error) {
	var err error
	var argBytes []byte
	var vv Parachute
	request := &api.ProcedureCall{
		Procedure: "Part_get_Parachute",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParachute will a <see cref="T:SpaceCenter.Parachute" /> if the part is
// a parachute, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamParachute() (*client.Stream[Parachute], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Parachute",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Parachute {
		var value Parachute
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Radiator will a <see cref="T:SpaceCenter.Radiator" /> if the part is a
// radiator, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Radiator() (Radiator, error) {
	var err error
	var argBytes []byte
	var vv Radiator
	request := &api.ProcedureCall{
		Procedure: "Part_get_Radiator",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiator will a <see cref="T:SpaceCenter.Radiator" /> if the part is a
// radiator, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamRadiator() (*client.Stream[Radiator], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Radiator",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Radiator {
		var value Radiator
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RCS will a <see cref="T:SpaceCenter.RCS" /> if the part is an RCS
// block/thruster, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RCS() (RCS, error) {
	var err error
	var argBytes []byte
	var vv RCS
	request := &api.ProcedureCall{
		Procedure: "Part_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRCS will a <see cref="T:SpaceCenter.RCS" /> if the part is an RCS
// block/thruster, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamRCS() (*client.Stream[RCS], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) RCS {
		var value RCS
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReactionWheel will a <see cref="T:SpaceCenter.ReactionWheel" /> if the part
// is a reaction wheel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ReactionWheel() (ReactionWheel, error) {
	var err error
	var argBytes []byte
	var vv ReactionWheel
	request := &api.ProcedureCall{
		Procedure: "Part_get_ReactionWheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReactionWheel will a <see cref="T:SpaceCenter.ReactionWheel" /> if the
// part is a reaction wheel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamReactionWheel() (*client.Stream[ReactionWheel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ReactionWheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReactionWheel {
		var value ReactionWheel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ResourceConverter will a <see cref="T:SpaceCenter.ResourceConverter" /> if
// the part is a resource converter, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ResourceConverter() (ResourceConverter, error) {
	var err error
	var argBytes []byte
	var vv ResourceConverter
	request := &api.ProcedureCall{
		Procedure: "Part_get_ResourceConverter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceConverter will a <see cref="T:SpaceCenter.ResourceConverter" />
// if the part is a resource converter, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamResourceConverter() (*client.Stream[ResourceConverter], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ResourceConverter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceConverter {
		var value ResourceConverter
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ResourceHarvester will a <see cref="T:SpaceCenter.ResourceHarvester" /> if
// the part is a resource harvester, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ResourceHarvester() (ResourceHarvester, error) {
	var err error
	var argBytes []byte
	var vv ResourceHarvester
	request := &api.ProcedureCall{
		Procedure: "Part_get_ResourceHarvester",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceHarvester will a <see cref="T:SpaceCenter.ResourceHarvester" />
// if the part is a resource harvester, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamResourceHarvester() (*client.Stream[ResourceHarvester], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ResourceHarvester",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceHarvester {
		var value ResourceHarvester
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RoboticController will a <see cref="T:SpaceCenter.RoboticController" /> if
// the part is a robotic controller, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticController() (RoboticController, error) {
	var err error
	var argBytes []byte
	var vv RoboticController
	request := &api.ProcedureCall{
		Procedure: "Part_get_RoboticController",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRoboticController will a <see cref="T:SpaceCenter.RoboticController" />
// if the part is a robotic controller, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamRoboticController() (*client.Stream[RoboticController], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_RoboticController",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) RoboticController {
		var value RoboticController
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Sensor will a <see cref="T:SpaceCenter.Sensor" /> if the part is a sensor,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Sensor() (Sensor, error) {
	var err error
	var argBytes []byte
	var vv Sensor
	request := &api.ProcedureCall{
		Procedure: "Part_get_Sensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSensor will a <see cref="T:SpaceCenter.Sensor" /> if the part is a
// sensor, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamSensor() (*client.Stream[Sensor], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Sensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Sensor {
		var value Sensor
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SolarPanel will a <see cref="T:SpaceCenter.SolarPanel" /> if the part is a
// solar panel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) SolarPanel() (SolarPanel, error) {
	var err error
	var argBytes []byte
	var vv SolarPanel
	request := &api.ProcedureCall{
		Procedure: "Part_get_SolarPanel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSolarPanel will a <see cref="T:SpaceCenter.SolarPanel" /> if the part
// is a solar panel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamSolarPanel() (*client.Stream[SolarPanel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_SolarPanel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) SolarPanel {
		var value SolarPanel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Wheel will a <see cref="T:SpaceCenter.Wheel" /> if the part is a wheel,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Wheel() (Wheel, error) {
	var err error
	var argBytes []byte
	var vv Wheel
	request := &api.ProcedureCall{
		Procedure: "Part_get_Wheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWheel will a <see cref="T:SpaceCenter.Wheel" /> if the part is a wheel,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) StreamWheel() (*client.Stream[Wheel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_Wheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Wheel {
		var value Wheel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MomentOfInertia will the moment of inertia of the part in <math>kg.m^2</math>
// around its center of mass in the parts reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Part) MomentOfInertia() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Part_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMomentOfInertia will the moment of inertia of the part in
// <math>kg.m^2</math> around its center of mass in the parts reference frame
// (<see cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Part) StreamMomentOfInertia() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InertiaTensor will the inertia tensor of the part in the parts reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix
// as a list of elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Part) InertiaTensor() ([]float64, error) {
	var err error
	var argBytes []byte
	var vv []float64
	request := &api.ProcedureCall{
		Procedure: "Part_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInertiaTensor will the inertia tensor of the part in the parts
// reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />). Returns the
// 3x3 matrix as a list of elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Part) StreamInertiaTensor() (*client.Stream[[]float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []float64 {
		var value []float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferenceFrame will the reference frame that is fixed relative to this part,
// and centered on a fixed position within the part, defined by the parts model.
// <list type="bullet"><item><description>The origin is at the position of the
// part, as returned by <see cref="M:SpaceCenter.Part.Position"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Part_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame that is fixed relative to this
// part, and centered on a fixed position within the part, defined by the parts
// model. <list type="bullet"><item><description>The origin is at the position
// of the part, as returned by <see cref="M:SpaceCenter.Part.Position"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CenterOfMassReferenceFrame will the reference frame that is fixed relative to
// this part, and centered on its center of mass. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// part, as returned by <see cref="M:SpaceCenter.Part.CenterOfMass"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) CenterOfMassReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Part_get_CenterOfMassReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCenterOfMassReferenceFrame will the reference frame that is fixed
// relative to this part, and centered on its center of mass. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// part, as returned by <see cref="M:SpaceCenter.Part.CenterOfMass"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) StreamCenterOfMassReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Part_get_CenterOfMassReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WithName will a list of parts whose <see cref="M:SpaceCenter.Part.Name" /> is
// <paramref name="name" />.
//
// Allowed game scenes: any.
func (s *Parts) WithName(name string) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_WithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWithName will a list of parts whose <see cref="M:SpaceCenter.Part.Name"
// /> is <paramref name="name" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamWithName(name string) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_WithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WithTitle will a list of all parts whose <see cref="M:SpaceCenter.Part.Title"
// /> is <paramref name="title" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTitle(title string) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_WithTitle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWithTitle will a list of all parts whose <see
// cref="M:SpaceCenter.Part.Title" /> is <paramref name="title" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamWithTitle(title string) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_WithTitle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WithTag will a list of all parts whose <see cref="M:SpaceCenter.Part.Tag" />
// is <paramref name="tag" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTag(tag string) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_WithTag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(tag)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWithTag will a list of all parts whose <see
// cref="M:SpaceCenter.Part.Tag" /> is <paramref name="tag" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamWithTag(tag string) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_WithTag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(tag)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WithModule will a list of all parts that contain a <see
// cref="T:SpaceCenter.Module" /> whose <see cref="M:SpaceCenter.Module.Name" />
// is <paramref name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) WithModule(moduleName string) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_WithModule",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWithModule will a list of all parts that contain a <see
// cref="T:SpaceCenter.Module" /> whose <see cref="M:SpaceCenter.Module.Name" />
// is <paramref name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamWithModule(moduleName string) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_WithModule",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InStage will a list of all parts that are activated in the given <paramref
// name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InStage(stage int32) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_InStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInStage will a list of all parts that are activated in the given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamInStage(stage int32) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_InStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InDecoupleStage will a list of all parts that are decoupled in the given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InDecoupleStage(stage int32) ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_InDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInDecoupleStage will a list of all parts that are decoupled in the
// given <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamInDecoupleStage(stage int32) (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_InDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ModulesWithName will a list of modules (combined across all parts in the
// vessel) whose <see cref="M:SpaceCenter.Module.Name" /> is <paramref
// name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) ModulesWithName(moduleName string) ([]Module, error) {
	var err error
	var argBytes []byte
	var vv []Module
	request := &api.ProcedureCall{
		Procedure: "Parts_ModulesWithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamModulesWithName will a list of modules (combined across all parts in
// the vessel) whose <see cref="M:SpaceCenter.Module.Name" /> is <paramref
// name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) StreamModulesWithName(moduleName string) (*client.Stream[[]Module], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_ModulesWithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Module {
		var value []Module
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// All will a list of all of the vessels parts.
//
// Allowed game scenes: any.
func (s *Parts) All() ([]Part, error) {
	var err error
	var argBytes []byte
	var vv []Part
	request := &api.ProcedureCall{
		Procedure: "Parts_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAll will a list of all of the vessels parts.
//
// Allowed game scenes: any.
func (s *Parts) StreamAll() (*client.Stream[[]Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Part {
		var value []Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Root will the vessels root part.
//
// Allowed game scenes: any.
func (s *Parts) Root() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Root",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRoot will the vessels root part.
//
// Allowed game scenes: any.
func (s *Parts) StreamRoot() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Root",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Controlling will the part from which the vessel is controlled.
//
// Allowed game scenes: any.
func (s *Parts) Controlling() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Controlling",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamControlling will the part from which the vessel is controlled.
//
// Allowed game scenes: any.
func (s *Parts) StreamControlling() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Controlling",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetControlling will the part from which the vessel is controlled.
//
// Allowed game scenes: any.
func (s *Parts) SetControlling(value Part) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_set_Controlling",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Antennas will a list of all antennas in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Antennas() ([]Antenna, error) {
	var err error
	var argBytes []byte
	var vv []Antenna
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAntennas will a list of all antennas in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamAntennas() (*client.Stream[[]Antenna], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Antenna {
		var value []Antenna
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ControlSurfaces will a list of all control surfaces in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ControlSurfaces() ([]ControlSurface, error) {
	var err error
	var argBytes []byte
	var vv []ControlSurface
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ControlSurfaces",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamControlSurfaces will a list of all control surfaces in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamControlSurfaces() (*client.Stream[[]ControlSurface], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ControlSurfaces",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ControlSurface {
		var value []ControlSurface
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CargoBays will a list of all cargo bays in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) CargoBays() ([]CargoBay, error) {
	var err error
	var argBytes []byte
	var vv []CargoBay
	request := &api.ProcedureCall{
		Procedure: "Parts_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCargoBays will a list of all cargo bays in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamCargoBays() (*client.Stream[[]CargoBay], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []CargoBay {
		var value []CargoBay
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Decouplers will a list of all decouplers in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Decouplers() ([]Decoupler, error) {
	var err error
	var argBytes []byte
	var vv []Decoupler
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Decouplers",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDecouplers will a list of all decouplers in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamDecouplers() (*client.Stream[[]Decoupler], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Decouplers",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Decoupler {
		var value []Decoupler
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DockingPorts will a list of all docking ports in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) DockingPorts() ([]DockingPort, error) {
	var err error
	var argBytes []byte
	var vv []DockingPort
	request := &api.ProcedureCall{
		Procedure: "Parts_get_DockingPorts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDockingPorts will a list of all docking ports in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamDockingPorts() (*client.Stream[[]DockingPort], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_DockingPorts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []DockingPort {
		var value []DockingPort
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Engines will a list of all engines in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Engines() ([]Engine, error) {
	var err error
	var argBytes []byte
	var vv []Engine
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Engines",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEngines will a list of all engines in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamEngines() (*client.Stream[[]Engine], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Engines",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Engine {
		var value []Engine
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Experiments will a list of all science experiments in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Experiments() ([]Experiment, error) {
	var err error
	var argBytes []byte
	var vv []Experiment
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExperiments will a list of all science experiments in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamExperiments() (*client.Stream[[]Experiment], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Experiment {
		var value []Experiment
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Fairings will a list of all fairings in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Fairings() ([]Fairing, error) {
	var err error
	var argBytes []byte
	var vv []Fairing
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Fairings",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFairings will a list of all fairings in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamFairings() (*client.Stream[[]Fairing], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Fairings",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Fairing {
		var value []Fairing
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Intakes will a list of all intakes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Intakes() ([]Intake, error) {
	var err error
	var argBytes []byte
	var vv []Intake
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIntakes will a list of all intakes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamIntakes() (*client.Stream[[]Intake], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Intake {
		var value []Intake
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Legs will a list of all landing legs attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Legs() ([]Leg, error) {
	var err error
	var argBytes []byte
	var vv []Leg
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLegs will a list of all landing legs attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamLegs() (*client.Stream[[]Leg], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Leg {
		var value []Leg
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LaunchClamps will a list of all launch clamps attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) LaunchClamps() ([]LaunchClamp, error) {
	var err error
	var argBytes []byte
	var vv []LaunchClamp
	request := &api.ProcedureCall{
		Procedure: "Parts_get_LaunchClamps",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLaunchClamps will a list of all launch clamps attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamLaunchClamps() (*client.Stream[[]LaunchClamp], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_LaunchClamps",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []LaunchClamp {
		var value []LaunchClamp
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Lights will a list of all lights in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Lights() ([]Light, error) {
	var err error
	var argBytes []byte
	var vv []Light
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLights will a list of all lights in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamLights() (*client.Stream[[]Light], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Light {
		var value []Light
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parachutes will a list of all parachutes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Parachutes() ([]Parachute, error) {
	var err error
	var argBytes []byte
	var vv []Parachute
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParachutes will a list of all parachutes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamParachutes() (*client.Stream[[]Parachute], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Parachute {
		var value []Parachute
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Radiators will a list of all radiators in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Radiators() ([]Radiator, error) {
	var err error
	var argBytes []byte
	var vv []Radiator
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadiators will a list of all radiators in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamRadiators() (*client.Stream[[]Radiator], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Radiator {
		var value []Radiator
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RCS will a list of all RCS blocks/thrusters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RCS() ([]RCS, error) {
	var err error
	var argBytes []byte
	var vv []RCS
	request := &api.ProcedureCall{
		Procedure: "Parts_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRCS will a list of all RCS blocks/thrusters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamRCS() (*client.Stream[[]RCS], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []RCS {
		var value []RCS
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReactionWheels will a list of all reaction wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ReactionWheels() ([]ReactionWheel, error) {
	var err error
	var argBytes []byte
	var vv []ReactionWheel
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReactionWheels will a list of all reaction wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamReactionWheels() (*client.Stream[[]ReactionWheel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ReactionWheel {
		var value []ReactionWheel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ResourceConverters will a list of all resource converters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceConverters() ([]ResourceConverter, error) {
	var err error
	var argBytes []byte
	var vv []ResourceConverter
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ResourceConverters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceConverters will a list of all resource converters in the
// vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamResourceConverters() (*client.Stream[[]ResourceConverter], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ResourceConverters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ResourceConverter {
		var value []ResourceConverter
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ResourceHarvesters will a list of all resource harvesters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceHarvesters() ([]ResourceHarvester, error) {
	var err error
	var argBytes []byte
	var vv []ResourceHarvester
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourceHarvesters will a list of all resource harvesters in the
// vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamResourceHarvesters() (*client.Stream[[]ResourceHarvester], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ResourceHarvester {
		var value []ResourceHarvester
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Sensors will a list of all sensors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Sensors() ([]Sensor, error) {
	var err error
	var argBytes []byte
	var vv []Sensor
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Sensors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSensors will a list of all sensors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamSensors() (*client.Stream[[]Sensor], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Sensors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Sensor {
		var value []Sensor
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SolarPanels will a list of all solar panels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) SolarPanels() ([]SolarPanel, error) {
	var err error
	var argBytes []byte
	var vv []SolarPanel
	request := &api.ProcedureCall{
		Procedure: "Parts_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSolarPanels will a list of all solar panels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamSolarPanels() (*client.Stream[[]SolarPanel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []SolarPanel {
		var value []SolarPanel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Wheels will a list of all wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Wheels() ([]Wheel, error) {
	var err error
	var argBytes []byte
	var vv []Wheel
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWheels will a list of all wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) StreamWheels() (*client.Stream[[]Wheel], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Parts_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Wheel {
		var value []Wheel
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the name of the propellant.
//
// Allowed game scenes: any.
func (s *Propellant) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the propellant.
//
// Allowed game scenes: any.
func (s *Propellant) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CurrentAmount will the current amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentAmount() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_CurrentAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCurrentAmount will the current amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) StreamCurrentAmount() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_CurrentAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CurrentRequirement will the required amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentRequirement() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_CurrentRequirement",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCurrentRequirement will the required amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) StreamCurrentRequirement() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_CurrentRequirement",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TotalResourceAvailable will the total amount of the underlying resource
// currently reachable given resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceAvailable() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceAvailable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTotalResourceAvailable will the total amount of the underlying resource
// currently reachable given resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) StreamTotalResourceAvailable() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceAvailable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TotalResourceCapacity will the total vehicle capacity for the underlying
// propellant resource, restricted by resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceCapacity() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTotalResourceCapacity will the total vehicle capacity for the
// underlying propellant resource, restricted by resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) StreamTotalResourceCapacity() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IgnoreForIsp will if this propellant should be ignored when calculating
// required mass flow given specific impulse.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForIsp() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForIsp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIgnoreForIsp will if this propellant should be ignored when calculating
// required mass flow given specific impulse.
//
// Allowed game scenes: any.
func (s *Propellant) StreamIgnoreForIsp() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForIsp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IgnoreForThrustCurve will if this propellant should be ignored for thrust
// curve calculations.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForThrustCurve() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForThrustCurve",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIgnoreForThrustCurve will if this propellant should be ignored for
// thrust curve calculations.
//
// Allowed game scenes: any.
func (s *Propellant) StreamIgnoreForThrustCurve() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForThrustCurve",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DrawStackGauge will if this propellant has a stack gauge or not.
//
// Allowed game scenes: any.
func (s *Propellant) DrawStackGauge() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_DrawStackGauge",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDrawStackGauge will if this propellant has a stack gauge or not.
//
// Allowed game scenes: any.
func (s *Propellant) StreamDrawStackGauge() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_DrawStackGauge",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsDeprived will if this propellant is deprived.
//
// Allowed game scenes: any.
func (s *Propellant) IsDeprived() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IsDeprived",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsDeprived will if this propellant is deprived.
//
// Allowed game scenes: any.
func (s *Propellant) StreamIsDeprived() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_IsDeprived",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Ratio will the propellant ratio.
//
// Allowed game scenes: any.
func (s *Propellant) Ratio() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_Ratio",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRatio will the propellant ratio.
//
// Allowed game scenes: any.
func (s *Propellant) StreamRatio() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Propellant_get_Ratio",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this RCS.
//
// Allowed game scenes: any.
func (s *RCS) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this RCS.
//
// Allowed game scenes: any.
func (s *RCS) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the RCS thrusters are active. An RCS thruster is inactive
// if the RCS action group is disabled (<see cref="M:SpaceCenter.Control.RCS"
// />), the RCS thruster itself is not enabled (<see
// cref="M:SpaceCenter.RCS.Enabled" />) or it is covered by a fairing (<see
// cref="M:SpaceCenter.Part.Shielded" />).
//
// Allowed game scenes: any.
func (s *RCS) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the RCS thrusters are active. An RCS thruster is
// inactive if the RCS action group is disabled (<see
// cref="M:SpaceCenter.Control.RCS" />), the RCS thruster itself is not enabled
// (<see cref="M:SpaceCenter.RCS.Enabled" />) or it is covered by a fairing
// (<see cref="M:SpaceCenter.Part.Shielded" />).
//
// Allowed game scenes: any.
func (s *RCS) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Enabled will whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnabled will whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) StreamEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetEnabled will whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PitchEnabled will whether the RCS thruster will fire when pitch control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) PitchEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPitchEnabled will whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamPitchEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPitchEnabled will whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) SetPitchEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawEnabled will whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) YawEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamYawEnabled will whether the RCS thruster will fire when yaw control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamYawEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetYawEnabled will whether the RCS thruster will fire when yaw control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) SetYawEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollEnabled will whether the RCS thruster will fire when roll control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) RollEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRollEnabled will whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamRollEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRollEnabled will whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) SetRollEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ForwardEnabled will whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) ForwardEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamForwardEnabled will whether the RCS thruster will fire when pitch
// control input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamForwardEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetForwardEnabled will whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) SetForwardEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// UpEnabled will whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) UpEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamUpEnabled will whether the RCS thruster will fire when yaw control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamUpEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetUpEnabled will whether the RCS thruster will fire when yaw control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) SetUpEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RightEnabled will whether the RCS thruster will fire when roll control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) RightEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRightEnabled will whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) StreamRightEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetRightEnabled will whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) SetRightEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableTorque will the available torque, in Newton meters, that can be
// produced by this RCS, in the positive and negative pitch, roll and yaw axes
// of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disable.
//
// Allowed game scenes: any.
func (s *RCS) AvailableTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "RCS_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableTorque will the available torque, in Newton meters, that can
// be produced by this RCS, in the positive and negative pitch, roll and yaw
// axes of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disable.
//
// Allowed game scenes: any.
func (s *RCS) StreamAvailableTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableThrust will the amount of thrust, in Newtons, that would be produced
// by the thruster when activated. Returns zero if the thruster does not have
// any fuel. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableThrust will the amount of thrust, in Newtons, that would be
// produced by the thruster when activated. Returns zero if the thruster does
// not have any fuel. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) StreamAvailableThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxThrust will the maximum amount of thrust that can be produced by the RCS
// thrusters when active, in Newtons. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxThrust will the maximum amount of thrust that can be produced by the
// RCS thrusters when active, in Newtons. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) StreamMaxThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxVacuumThrust will the maximum amount of thrust that can be produced by the
// RCS thrusters when active in a vacuum, in Newtons.
//
// Allowed game scenes: any.
func (s *RCS) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxVacuumThrust will the maximum amount of thrust that can be produced
// by the RCS thrusters when active in a vacuum, in Newtons.
//
// Allowed game scenes: any.
func (s *RCS) StreamMaxVacuumThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustLimit will the thrust limiter of the thruster. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *RCS) ThrustLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustLimit will the thrust limiter of the thruster. A value between 0
// and 1.
//
// Allowed game scenes: any.
func (s *RCS) StreamThrustLimit() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetThrustLimit will the thrust limiter of the thruster. A value between 0 and
// 1.
//
// Allowed game scenes: any.
func (s *RCS) SetThrustLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_set_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrusters will a list of thrusters, one of each nozzel in the RCS part.
//
// Allowed game scenes: any.
func (s *RCS) Thrusters() ([]Thruster, error) {
	var err error
	var argBytes []byte
	var vv []Thruster
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrusters will a list of thrusters, one of each nozzel in the RCS part.
//
// Allowed game scenes: any.
func (s *RCS) StreamThrusters() (*client.Stream[[]Thruster], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Thruster {
		var value []Thruster
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SpecificImpulse will the current specific impulse of the RCS, in seconds.
// Returns zero if the RCS is not active.
//
// Allowed game scenes: any.
func (s *RCS) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpecificImpulse will the current specific impulse of the RCS, in
// seconds. Returns zero if the RCS is not active.
//
// Allowed game scenes: any.
func (s *RCS) StreamSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// VacuumSpecificImpulse will the vacuum specific impulse of the RCS, in
// seconds.
//
// Allowed game scenes: any.
func (s *RCS) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVacuumSpecificImpulse will the vacuum specific impulse of the RCS, in
// seconds.
//
// Allowed game scenes: any.
func (s *RCS) StreamVacuumSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse will the specific impulse of the RCS at sea
// level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *RCS) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamKerbinSeaLevelSpecificImpulse will the specific impulse of the RCS at
// sea level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *RCS) StreamKerbinSeaLevelSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Propellants will the names of resources that the RCS consumes.
//
// Allowed game scenes: any.
func (s *RCS) Propellants() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPropellants will the names of resources that the RCS consumes.
//
// Allowed game scenes: any.
func (s *RCS) StreamPropellants() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// PropellantRatios will the ratios of resources that the RCS consumes. A
// dictionary mapping resource names to the ratios at which they are consumed by
// the RCS.
//
// Allowed game scenes: any.
func (s *RCS) PropellantRatios() (map[string]float32, error) {
	var err error
	var argBytes []byte
	var vv map[string]float32
	request := &api.ProcedureCall{
		Procedure: "RCS_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPropellantRatios will the ratios of resources that the RCS consumes. A
// dictionary mapping resource names to the ratios at which they are consumed by
// the RCS.
//
// Allowed game scenes: any.
func (s *RCS) StreamPropellantRatios() (*client.Stream[map[string]float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]float32 {
		var value map[string]float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasFuel will whether the RCS has fuel available.
//
// Allowed game scenes: any.
func (s *RCS) HasFuel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RCS_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasFuel will whether the RCS has fuel available.
//
// Allowed game scenes: any.
func (s *RCS) StreamHasFuel() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RCS_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this radiator.
//
// Allowed game scenes: any.
func (s *Radiator) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this radiator.
//
// Allowed game scenes: any.
func (s *Radiator) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployable will whether the radiator is deployable.
//
// Allowed game scenes: any.
func (s *Radiator) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployable will whether the radiator is deployable.
//
// Allowed game scenes: any.
func (s *Radiator) StreamDeployable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will for a deployable radiator, true if the radiator is extended. If
// the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will for a deployable radiator, true if the radiator is
// extended. If the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will for a deployable radiator, true if the radiator is extended.
// If the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Radiator_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State will the current state of the radiator.
//
// Allowed game scenes: any.
func (s *Radiator) State() (RadiatorState, error) {
	var err error
	var argBytes []byte
	var vv RadiatorState
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the radiator.
//
// Allowed game scenes: any.
func (s *Radiator) StreamState() (*client.Stream[RadiatorState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Radiator_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) RadiatorState {
		var value RadiatorState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this reaction wheel.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this reaction wheel.
//
// Allowed game scenes: any.
func (s *ReactionWheel) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActive will whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Broken will whether the reaction wheel is broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Broken() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBroken will whether the reaction wheel is broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) StreamBroken() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableTorque will the available torque, in Newton meters, that can be
// produced by this reaction wheel, in the positive and negative pitch, roll and
// yaw axes of the vessel. These axes correspond to the coordinate axes of the
// <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the
// reaction wheel is inactive or broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) AvailableTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableTorque will the available torque, in Newton meters, that can
// be produced by this reaction wheel, in the positive and negative pitch, roll
// and yaw axes of the vessel. These axes correspond to the coordinate axes of
// the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the
// reaction wheel is inactive or broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) StreamAvailableTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxTorque will the maximum torque, in Newton meters, that can be produced by
// this reaction wheel, when it is active, in the positive and negative pitch,
// roll and yaw axes of the vessel. These axes correspond to the coordinate axes
// of the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ReactionWheel) MaxTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_MaxTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxTorque will the maximum torque, in Newton meters, that can be
// produced by this reaction wheel, when it is active, in the positive and
// negative pitch, roll and yaw axes of the vessel. These axes correspond to the
// coordinate axes of the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ReactionWheel) StreamMaxTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReactionWheel_get_MaxTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will true if the specified converter is active.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Active(index int32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will true if the specified converter is active.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamActive(index int32) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the name of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Name(index int32) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamName(index int32) (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Start will start the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Start(index int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop will stop the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Stop(index int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Stop",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State will the state of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) State(index int32) (ResourceConverterState, error) {
	var err error
	var argBytes []byte
	var vv ResourceConverterState
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the state of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamState(index int32) (*client.Stream[ResourceConverterState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceConverterState {
		var value ResourceConverterState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StatusInfo will status information for the specified converter. This is the
// full status message shown in the in-game UI.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StatusInfo(index int32) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_StatusInfo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStatusInfo will status information for the specified converter. This is
// the full status message shown in the in-game UI.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamStatusInfo(index int32) (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_StatusInfo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Inputs will list of the names of resources consumed by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Inputs(index int32) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Inputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInputs will list of the names of resources consumed by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamInputs(index int32) (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Inputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Outputs will list of the names of resources produced by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Outputs(index int32) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Outputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOutputs will list of the names of resources produced by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamOutputs(index int32) (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_Outputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Count will the number of converters in the part.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Count() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_Count",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCount will the number of converters in the part.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamCount() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_Count",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalEfficiency will the thermal efficiency of the converter, as a
// percentage of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceConverter) ThermalEfficiency() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalEfficiency will the thermal efficiency of the converter, as a
// percentage of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamThermalEfficiency() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CoreTemperature will the core temperature of the converter, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) CoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCoreTemperature will the core temperature of the converter, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamCoreTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OptimumCoreTemperature will the core temperature at which the converter will
// operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) OptimumCoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOptimumCoreTemperature will the core temperature at which the converter
// will operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StreamOptimumCoreTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceConverter_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the state of the harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) State() (ResourceHarvesterState, error) {
	var err error
	var argBytes []byte
	var vv ResourceHarvesterState
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the state of the harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamState() (*client.Stream[ResourceHarvesterState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceHarvesterState {
		var value ResourceHarvesterState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Active will whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActive will whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ExtractionRate will the rate at which the drill is extracting ore, in units
// per second.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ExtractionRate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_ExtractionRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExtractionRate will the rate at which the drill is extracting ore, in
// units per second.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamExtractionRate() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_ExtractionRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThermalEfficiency will the thermal efficiency of the drill, as a percentage
// of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ThermalEfficiency() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThermalEfficiency will the thermal efficiency of the drill, as a
// percentage of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamThermalEfficiency() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CoreTemperature will the core temperature of the drill, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) CoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCoreTemperature will the core temperature of the drill, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamCoreTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OptimumCoreTemperature will the core temperature at which the drill will
// operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) OptimumCoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOptimumCoreTemperature will the core temperature at which the drill
// will operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StreamOptimumCoreTemperature() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceHarvester_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasPart will whether the controller any axisfield from the part
//
// Allowed game scenes: any.
func (s *RoboticController) HasPart(part Part) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RoboticController_HasPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasPart will whether the controller any axisfield from the part
//
// Allowed game scenes: any.
func (s *RoboticController) StreamHasPart(part Part) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RoboticController_HasPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ListAxes will list the axes for the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) ListAxes() ([][]string, error) {
	var err error
	var argBytes []byte
	var vv [][]string
	request := &api.ProcedureCall{
		Procedure: "RoboticController_ListAxes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamListAxes will list the axes for the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) StreamListAxes() (*client.Stream[[][]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RoboticController_ListAxes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) [][]string {
		var value [][]string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddKey will add key frame value for controller axis.
//
// Allowed game scenes: any.
func (s *RoboticController) AddKey(part string, field string, time float32, value float32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RoboticController_AddKey",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(field)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddKey will add key frame value for controller axis.
//
// Allowed game scenes: any.
func (s *RoboticController) StreamAddKey(part string, field string, time float32, value float32) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RoboticController_AddKey",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(field)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ClearAxis will clear axis.
//
// Allowed game scenes: any.
func (s *RoboticController) ClearAxis(part string, field string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "RoboticController_ClearAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(field)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamClearAxis will clear axis.
//
// Allowed game scenes: any.
func (s *RoboticController) StreamClearAxis(part string, field string) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RoboticController_ClearAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(field)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this antenna.
//
// Allowed game scenes: any.
func (s *RoboticController) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "RoboticController_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this antenna.
//
// Allowed game scenes: any.
func (s *RoboticController) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RoboticController_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DataAmount will data amount.
//
// Allowed game scenes: any.
func (s *ScienceData) DataAmount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_DataAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDataAmount will data amount.
//
// Allowed game scenes: any.
func (s *ScienceData) StreamDataAmount() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_DataAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScienceValue will science value.
//
// Allowed game scenes: any.
func (s *ScienceData) ScienceValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_ScienceValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScienceValue will science value.
//
// Allowed game scenes: any.
func (s *ScienceData) StreamScienceValue() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_ScienceValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TransmitValue will transmit value.
//
// Allowed game scenes: any.
func (s *ScienceData) TransmitValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_TransmitValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTransmitValue will transmit value.
//
// Allowed game scenes: any.
func (s *ScienceData) StreamTransmitValue() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceData_get_TransmitValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Science will amount of science already earned from this subject, not updated
// until after transmission/recovery.
//
// Allowed game scenes: any.
func (s *ScienceSubject) Science() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_Science",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScience will amount of science already earned from this subject, not
// updated until after transmission/recovery.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamScience() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_Science",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScienceCap will total science allowable for this subject.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScienceCap() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_ScienceCap",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScienceCap will total science allowable for this subject.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamScienceCap() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_ScienceCap",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsComplete will whether the experiment has been completed.
//
// Allowed game scenes: any.
func (s *ScienceSubject) IsComplete() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_IsComplete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsComplete will whether the experiment has been completed.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamIsComplete() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_IsComplete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DataScale will multiply science value by this to determine data amount in
// mits.
//
// Allowed game scenes: any.
func (s *ScienceSubject) DataScale() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_DataScale",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDataScale will multiply science value by this to determine data amount
// in mits.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamDataScale() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_DataScale",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ScientificValue will diminishing value multiplier for decreasing the science
// value returned from repeated experiments.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScientificValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_ScientificValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamScientificValue will diminishing value multiplier for decreasing the
// science value returned from repeated experiments.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamScientificValue() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_ScientificValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SubjectValue will multiplier for specific Celestial Body/Experiment Situation
// combination.
//
// Allowed game scenes: any.
func (s *ScienceSubject) SubjectValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_SubjectValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSubjectValue will multiplier for specific Celestial Body/Experiment
// Situation combination.
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamSubjectValue() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_SubjectValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Title will title of science subject, displayed in science archives
//
// Allowed game scenes: any.
func (s *ScienceSubject) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTitle will title of science subject, displayed in science archives
//
// Allowed game scenes: any.
func (s *ScienceSubject) StreamTitle() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ScienceSubject_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this sensor.
//
// Allowed game scenes: any.
func (s *Sensor) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this sensor.
//
// Allowed game scenes: any.
func (s *Sensor) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Active will whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamActive will whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) StreamActive() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetActive will whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Sensor_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Value will the current value of the sensor.
//
// Allowed game scenes: any.
func (s *Sensor) Value() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Value",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamValue will the current value of the sensor.
//
// Allowed game scenes: any.
func (s *Sensor) StreamValue() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Sensor_get_Value",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployable will whether the solar panel is deployable.
//
// Allowed game scenes: any.
func (s *SolarPanel) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployable will whether the solar panel is deployable.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamDeployable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State will the current state of the solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) State() (SolarPanelState, error) {
	var err error
	var argBytes []byte
	var vv SolarPanelState
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamState() (*client.Stream[SolarPanelState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) SolarPanelState {
		var value SolarPanelState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// EnergyFlow will the current amount of energy being generated by the solar
// panel, in units of charge per second.
//
// Allowed game scenes: any.
func (s *SolarPanel) EnergyFlow() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_EnergyFlow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnergyFlow will the current amount of energy being generated by the
// solar panel, in units of charge per second.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamEnergyFlow() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_EnergyFlow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SunExposure will the current amount of sunlight that is incident on the solar
// panel, as a percentage. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *SolarPanel) SunExposure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_SunExposure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSunExposure will the current amount of sunlight that is incident on the
// solar panel, as a percentage. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *SolarPanel) StreamSunExposure() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SolarPanel_get_SunExposure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustPosition will the position at which the thruster generates thrust, in
// the given reference frame. For gimballed engines, this takes into account the
// current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustPosition(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_ThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustPosition will the position at which the thruster generates
// thrust, in the given reference frame. For gimballed engines, this takes into
// account the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) StreamThrustPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_ThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustDirection will the direction of the force generated by the thruster, in
// the given reference frame. This is opposite to the direction in which the
// thruster expels propellant. For gimballed engines, this takes into account
// the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustDirection(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_ThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustDirection will the direction of the force generated by the
// thruster, in the given reference frame. This is opposite to the direction in
// which the thruster expels propellant. For gimballed engines, this takes into
// account the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) StreamThrustDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_ThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InitialThrustPosition will the position at which the thruster generates
// thrust, when the engine is in its initial position (no gimballing), in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustPosition(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_InitialThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInitialThrustPosition will the position at which the thruster generates
// thrust, when the engine is in its initial position (no gimballing), in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Thruster) StreamInitialThrustPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_InitialThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InitialThrustDirection will the direction of the force generated by the
// thruster, when the engine is in its initial position (no gimballing), in the
// given reference frame. This is opposite to the direction in which the
// thruster expels propellant.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustDirection(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_InitialThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInitialThrustDirection will the direction of the force generated by the
// thruster, when the engine is in its initial position (no gimballing), in the
// given reference frame. This is opposite to the direction in which the
// thruster expels propellant.
//
// Allowed game scenes: any.
func (s *Thruster) StreamInitialThrustDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_InitialThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GimbalPosition will position around which the gimbal pivots.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalPosition(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_GimbalPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimbalPosition will position around which the gimbal pivots.
//
// Allowed game scenes: any.
func (s *Thruster) StreamGimbalPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_GimbalPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the <see cref="T:SpaceCenter.Part" /> that contains this thruster.
//
// Allowed game scenes: any.
func (s *Thruster) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the <see cref="T:SpaceCenter.Part" /> that contains this
// thruster.
//
// Allowed game scenes: any.
func (s *Thruster) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ThrustReferenceFrame will a reference frame that is fixed relative to the
// thruster and orientated with its thrust direction (<see
// cref="M:SpaceCenter.Thruster.ThrustDirection" />). For gimballed engines,
// this takes into account the current rotation of the gimbal. <list
// type="bullet"><item><description> The origin is at the position of thrust for
// this thruster (<see cref="M:SpaceCenter.Thruster.ThrustPosition"
// />).</description></item><item><description> The axes rotate with the thrust
// direction. This is the direction in which the thruster expels propellant,
// including any gimballing. </description></item><item><description>The y-axis
// points along the thrust direction.</description></item><item><description>The
// x-axis and z-axis are perpendicular to the thrust direction.
// </description></item></list>
//
// Allowed game scenes: any.
func (s *Thruster) ThrustReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_ThrustReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrustReferenceFrame will a reference frame that is fixed relative to
// the thruster and orientated with its thrust direction (<see
// cref="M:SpaceCenter.Thruster.ThrustDirection" />). For gimballed engines,
// this takes into account the current rotation of the gimbal. <list
// type="bullet"><item><description> The origin is at the position of thrust for
// this thruster (<see cref="M:SpaceCenter.Thruster.ThrustPosition"
// />).</description></item><item><description> The axes rotate with the thrust
// direction. This is the direction in which the thruster expels propellant,
// including any gimballing. </description></item><item><description>The y-axis
// points along the thrust direction.</description></item><item><description>The
// x-axis and z-axis are perpendicular to the thrust direction.
// </description></item></list>
//
// Allowed game scenes: any.
func (s *Thruster) StreamThrustReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_ThrustReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Gimballed will whether the thruster is gimballed.
//
// Allowed game scenes: any.
func (s *Thruster) Gimballed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimballed will whether the thruster is gimballed.
//
// Allowed game scenes: any.
func (s *Thruster) StreamGimballed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GimbalAngle will the current gimbal angle in the pitch, roll and yaw axes, in
// degrees.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalAngle() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_GimbalAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGimbalAngle will the current gimbal angle in the pitch, roll and yaw
// axes, in degrees.
//
// Allowed game scenes: any.
func (s *Thruster) StreamGimbalAngle() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Thruster_get_GimbalAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part object for this wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part object for this wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// State will the current state of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) State() (WheelState, error) {
	var err error
	var argBytes []byte
	var vv WheelState
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamState will the current state of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamState() (*client.Stream[WheelState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) WheelState {
		var value WheelState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Radius will radius of the wheel, in meters.
//
// Allowed game scenes: any.
func (s *Wheel) Radius() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRadius will radius of the wheel, in meters.
//
// Allowed game scenes: any.
func (s *Wheel) StreamRadius() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Grounded will whether the wheel is touching the ground.
//
// Allowed game scenes: any.
func (s *Wheel) Grounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGrounded will whether the wheel is touching the ground.
//
// Allowed game scenes: any.
func (s *Wheel) StreamGrounded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasBrakes will whether the wheel has brakes.
//
// Allowed game scenes: any.
func (s *Wheel) HasBrakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_HasBrakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasBrakes will whether the wheel has brakes.
//
// Allowed game scenes: any.
func (s *Wheel) StreamHasBrakes() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_HasBrakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Brakes will the braking force, as a percentage of maximum, when the brakes
// are applied.
//
// Allowed game scenes: any.
func (s *Wheel) Brakes() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBrakes will the braking force, as a percentage of maximum, when the
// brakes are applied.
//
// Allowed game scenes: any.
func (s *Wheel) StreamBrakes() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetBrakes will the braking force, as a percentage of maximum, when the brakes
// are applied.
//
// Allowed game scenes: any.
func (s *Wheel) SetBrakes(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AutoFrictionControl will whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) AutoFrictionControl() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAutoFrictionControl will whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) StreamAutoFrictionControl() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAutoFrictionControl will whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetAutoFrictionControl(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ManualFrictionControl will manual friction control value. Only has an effect
// if automatic friction control is disabled. A value between 0 and 5 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) ManualFrictionControl() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamManualFrictionControl will manual friction control value. Only has an
// effect if automatic friction control is disabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) StreamManualFrictionControl() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetManualFrictionControl will manual friction control value. Only has an
// effect if automatic friction control is disabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetManualFrictionControl(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Deployable will whether the wheel is deployable.
//
// Allowed game scenes: any.
func (s *Wheel) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployable will whether the wheel is deployable.
//
// Allowed game scenes: any.
func (s *Wheel) StreamDeployable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deployed will whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeployed will whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) StreamDeployed() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDeployed will whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Powered will whether the wheel is powered by a motor.
//
// Allowed game scenes: any.
func (s *Wheel) Powered() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Powered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPowered will whether the wheel is powered by a motor.
//
// Allowed game scenes: any.
func (s *Wheel) StreamPowered() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Powered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MotorEnabled will whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) MotorEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMotorEnabled will whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) StreamMotorEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMotorEnabled will whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetMotorEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorInverted will whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMotorInverted will whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) StreamMotorInverted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMotorInverted will whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SetMotorInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorState will whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorState() (MotorState, error) {
	var err error
	var argBytes []byte
	var vv MotorState
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorState",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMotorState will whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) StreamMotorState() (*client.Stream[MotorState], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorState",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) MotorState {
		var value MotorState
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MotorOutput will the output of the motor. This is the torque currently being
// generated, in Newton meters.
//
// Allowed game scenes: any.
func (s *Wheel) MotorOutput() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorOutput",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMotorOutput will the output of the motor. This is the torque currently
// being generated, in Newton meters.
//
// Allowed game scenes: any.
func (s *Wheel) StreamMotorOutput() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_MotorOutput",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// TractionControlEnabled will whether automatic traction control is enabled. A
// wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControlEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTractionControlEnabled will whether automatic traction control is
// enabled. A wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) StreamTractionControlEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTractionControlEnabled will whether automatic traction control is enabled.
// A wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) SetTractionControlEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TractionControl will setting for the traction control. Only takes effect if
// the wheel has automatic traction control enabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControl() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamTractionControl will setting for the traction control. Only takes
// effect if the wheel has automatic traction control enabled. A value between 0
// and 5 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) StreamTractionControl() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetTractionControl will setting for the traction control. Only takes effect
// if the wheel has automatic traction control enabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetTractionControl(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DriveLimiter will manual setting for the motor limiter. Only takes effect if
// the wheel has automatic traction control disabled. A value between 0 and 100
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) DriveLimiter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDriveLimiter will manual setting for the motor limiter. Only takes
// effect if the wheel has automatic traction control disabled. A value between
// 0 and 100 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) StreamDriveLimiter() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetDriveLimiter will manual setting for the motor limiter. Only takes effect
// if the wheel has automatic traction control disabled. A value between 0 and
// 100 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetDriveLimiter(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Steerable will whether the wheel has steering.
//
// Allowed game scenes: any.
func (s *Wheel) Steerable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Steerable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSteerable will whether the wheel has steering.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSteerable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Steerable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SteeringEnabled will whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSteeringEnabled will whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSteeringEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSteeringEnabled will whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SteeringInverted will whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSteeringInverted will whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSteeringInverted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSteeringInverted will whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_set_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasSuspension will whether the wheel has suspension.
//
// Allowed game scenes: any.
func (s *Wheel) HasSuspension() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_HasSuspension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasSuspension will whether the wheel has suspension.
//
// Allowed game scenes: any.
func (s *Wheel) StreamHasSuspension() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_HasSuspension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SuspensionSpringStrength will suspension spring strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionSpringStrength() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SuspensionSpringStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSuspensionSpringStrength will suspension spring strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSuspensionSpringStrength() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SuspensionSpringStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SuspensionDamperStrength will suspension damper strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionDamperStrength() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SuspensionDamperStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSuspensionDamperStrength will suspension damper strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSuspensionDamperStrength() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_SuspensionDamperStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Broken will whether the wheel is broken.
//
// Allowed game scenes: any.
func (s *Wheel) Broken() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBroken will whether the wheel is broken.
//
// Allowed game scenes: any.
func (s *Wheel) StreamBroken() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Repairable will whether the wheel is repairable.
//
// Allowed game scenes: any.
func (s *Wheel) Repairable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Repairable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRepairable will whether the wheel is repairable.
//
// Allowed game scenes: any.
func (s *Wheel) StreamRepairable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Repairable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Stress will current stress on the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Stress() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Stress",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStress will current stress on the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamStress() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Stress",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StressTolerance will stress tolerance of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StressTolerance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_StressTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStressTolerance will stress tolerance of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamStressTolerance() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_StressTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StressPercentage will current stress on the wheel as a percentage of its
// stress tolerance.
//
// Allowed game scenes: any.
func (s *Wheel) StressPercentage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_StressPercentage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStressPercentage will current stress on the wheel as a percentage of
// its stress tolerance.
//
// Allowed game scenes: any.
func (s *Wheel) StreamStressPercentage() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_StressPercentage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Deflection will current deflection of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Deflection() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deflection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDeflection will current deflection of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamDeflection() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Deflection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Slip will current slip of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Slip() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Slip",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSlip will current slip of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StreamSlip() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Wheel_get_Slip",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateRelative will create a relative reference frame. This is a custom
// reference frame whose components offset the components of a parent reference
// frame.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) CreateRelative(position api.Tuple3[float64, float64, float64], rotation api.Tuple4[float64, float64, float64, float64], velocity api.Tuple3[float64, float64, float64], angularVelocity api.Tuple3[float64, float64, float64]) (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateRelative",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateRelative will create a relative reference frame. This is a custom
// reference frame whose components offset the components of a parent reference
// frame.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) StreamCreateRelative(position api.Tuple3[float64, float64, float64], rotation api.Tuple4[float64, float64, float64, float64], velocity api.Tuple3[float64, float64, float64], angularVelocity api.Tuple3[float64, float64, float64]) (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateRelative",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateHybrid will create a hybrid reference frame. This is a custom reference
// frame whose components inherited from other reference frames.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) CreateHybrid(rotation ReferenceFrame, velocity ReferenceFrame, angularVelocity ReferenceFrame) (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateHybrid",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateHybrid will create a hybrid reference frame. This is a custom
// reference frame whose components inherited from other reference frames.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) StreamCreateHybrid(rotation ReferenceFrame, velocity ReferenceFrame, angularVelocity ReferenceFrame) (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateHybrid",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the name of the resource.
//
// Allowed game scenes: any.
func (s *Resource) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the resource.
//
// Allowed game scenes: any.
func (s *Resource) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Part will the part containing the resource.
//
// Allowed game scenes: any.
func (s *Resource) Part() (Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part containing the resource.
//
// Allowed game scenes: any.
func (s *Resource) StreamPart() (*client.Stream[Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Part {
		var value Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Max will the total amount of the resource that can be stored in the part.
//
// Allowed game scenes: any.
func (s *Resource) Max() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMax will the total amount of the resource that can be stored in the
// part.
//
// Allowed game scenes: any.
func (s *Resource) StreamMax() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Amount will the amount of the resource that is currently stored in the part.
//
// Allowed game scenes: any.
func (s *Resource) Amount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAmount will the amount of the resource that is currently stored in the
// part.
//
// Allowed game scenes: any.
func (s *Resource) StreamAmount() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Density will the density of the resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resource) Density() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDensity will the density of the resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resource) StreamDensity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FlowMode will the flow mode of the resource.
//
// Allowed game scenes: any.
func (s *Resource) FlowMode() (ResourceFlowMode, error) {
	var err error
	var argBytes []byte
	var vv ResourceFlowMode
	request := &api.ProcedureCall{
		Procedure: "Resource_get_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFlowMode will the flow mode of the resource.
//
// Allowed game scenes: any.
func (s *Resource) StreamFlowMode() (*client.Stream[ResourceFlowMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceFlowMode {
		var value ResourceFlowMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Enabled will whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnabled will whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) StreamEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetEnabled will whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resource_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Start will start transferring a resource transfer between a pair of parts.
// The transfer will move at most <paramref name="maxAmount" /> units of the
// resource, depending on how much of the resource is available in the source
// part and how much storage is available in the destination part. Use <see
// cref="M:SpaceCenter.ResourceTransfer.Complete" /> to check if the transfer is
// complete. Use <see cref="M:SpaceCenter.ResourceTransfer.Amount" /> to see how
// much of the resource has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Start(toPart Part, resource string, maxAmount float32) (ResourceTransfer, error) {
	var err error
	var argBytes []byte
	var vv ResourceTransfer
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_static_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(toPart)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxAmount)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamStart will start transferring a resource transfer between a pair of
// parts. The transfer will move at most <paramref name="maxAmount" /> units of
// the resource, depending on how much of the resource is available in the
// source part and how much storage is available in the destination part. Use
// <see cref="M:SpaceCenter.ResourceTransfer.Complete" /> to check if the
// transfer is complete. Use <see cref="M:SpaceCenter.ResourceTransfer.Amount"
// /> to see how much of the resource has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) StreamStart(toPart Part, resource string, maxAmount float32) (*client.Stream[ResourceTransfer], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_static_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(toPart)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxAmount)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceTransfer {
		var value ResourceTransfer
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Complete will whether the transfer has completed.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Complete() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_get_Complete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamComplete will whether the transfer has completed.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) StreamComplete() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_get_Complete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Amount will the amount of the resource that has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Amount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAmount will the amount of the resource that has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) StreamAmount() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ResourceTransfer_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// WithResource will all the individual resources with the given name that can
// be stored.
//
// Allowed game scenes: any.
func (s *Resources) WithResource(name string) ([]Resource, error) {
	var err error
	var argBytes []byte
	var vv []Resource
	request := &api.ProcedureCall{
		Procedure: "Resources_WithResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWithResource will all the individual resources with the given name that
// can be stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamWithResource(name string) (*client.Stream[[]Resource], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_WithResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Resource {
		var value []Resource
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasResource will check whether the named resource can be stored.
//
// Allowed game scenes: any.
func (s *Resources) HasResource(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Resources_HasResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasResource will check whether the named resource can be stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamHasResource(name string) (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_HasResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Max will returns the amount of a resource that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) Max(name string) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resources_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMax will returns the amount of a resource that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamMax(name string) (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Amount will returns the amount of a resource that is currently stored.
//
// Allowed game scenes: any.
func (s *Resources) Amount(name string) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resources_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAmount will returns the amount of a resource that is currently stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamAmount(name string) (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Density will returns the density of a resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resources) Density() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Resources_static_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDensity will returns the density of a resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resources) StreamDensity() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_static_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// FlowMode will returns the flow mode of a resource.
//
// Allowed game scenes: any.
func (s *Resources) FlowMode() (ResourceFlowMode, error) {
	var err error
	var argBytes []byte
	var vv ResourceFlowMode
	request := &api.ProcedureCall{
		Procedure: "Resources_static_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFlowMode will returns the flow mode of a resource.
//
// Allowed game scenes: any.
func (s *Resources) StreamFlowMode() (*client.Stream[ResourceFlowMode], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_static_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ResourceFlowMode {
		var value ResourceFlowMode
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// All will all the individual resources that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) All() ([]Resource, error) {
	var err error
	var argBytes []byte
	var vv []Resource
	request := &api.ProcedureCall{
		Procedure: "Resources_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAll will all the individual resources that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamAll() (*client.Stream[[]Resource], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Resource {
		var value []Resource
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Names will a list of resource names that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) Names() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "Resources_get_Names",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNames will a list of resource names that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) StreamNames() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_get_Names",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Enabled will whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Resources_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEnabled will whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) StreamEnabled() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetEnabled will whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Resources_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Recover will recover the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Recover() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Recover",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Flight will returns a <see cref="T:SpaceCenter.Flight" /> object that can be
// used to get flight telemetry for the vessel, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *Vessel) Flight(referenceFrame ReferenceFrame) (Flight, error) {
	var err error
	var argBytes []byte
	var vv Flight
	request := &api.ProcedureCall{
		Procedure: "Vessel_Flight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFlight will returns a <see cref="T:SpaceCenter.Flight" /> object that
// can be used to get flight telemetry for the vessel, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamFlight(referenceFrame ReferenceFrame) (*client.Stream[Flight], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Flight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Flight {
		var value Flight
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ResourcesInDecoupleStage will returns a <see cref="T:SpaceCenter.Resources"
// /> object, that can used to get information about resources stored in a given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Vessel) ResourcesInDecoupleStage(stage int32, cumulative bool) (Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &api.ProcedureCall{
		Procedure: "Vessel_ResourcesInDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(cumulative)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResourcesInDecoupleStage will returns a <see
// cref="T:SpaceCenter.Resources" /> object, that can used to get information
// about resources stored in a given <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Vessel) StreamResourcesInDecoupleStage(stage int32, cumulative bool) (*client.Stream[Resources], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_ResourcesInDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(cumulative)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Resources {
		var value Resources
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Position will the position of the center of mass of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Position(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position of the center of mass of the vessel, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamPosition(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// BoundingBox will the axis-aligned bounding box of the vessel in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) BoundingBox(referenceFrame ReferenceFrame) (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBoundingBox will the axis-aligned bounding box of the vessel in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamBoundingBox(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Velocity will the velocity of the center of mass of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Velocity(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVelocity will the velocity of the center of mass of the vessel, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamVelocity(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Rotation will the rotation of the vessel, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Rotation(referenceFrame ReferenceFrame) (api.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple4[float64, float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRotation will the rotation of the vessel, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamRotation(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple4[float64, float64, float64, float64] {
		var value api.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Direction will the direction in which the vessel is pointing, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Direction(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDirection will the direction in which the vessel is pointing, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamDirection(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AngularVelocity will the angular velocity of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) AngularVelocity(referenceFrame ReferenceFrame) (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAngularVelocity will the angular velocity of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAngularVelocity(referenceFrame ReferenceFrame) (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Name will the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetName will the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type will the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Type() (VesselType, error) {
	var err error
	var argBytes []byte
	var vv VesselType
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamType will the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamType() (*client.Stream[VesselType], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) VesselType {
		var value VesselType
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetType will the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) SetType(value VesselType) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_set_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Situation will the situation the vessel is in.
//
// Allowed game scenes: any.
func (s *Vessel) Situation() (VesselSituation, error) {
	var err error
	var argBytes []byte
	var vv VesselSituation
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Situation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSituation will the situation the vessel is in.
//
// Allowed game scenes: any.
func (s *Vessel) StreamSituation() (*client.Stream[VesselSituation], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Situation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) VesselSituation {
		var value VesselSituation
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Recoverable will whether the vessel is recoverable.
//
// Allowed game scenes: any.
func (s *Vessel) Recoverable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Recoverable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRecoverable will whether the vessel is recoverable.
//
// Allowed game scenes: any.
func (s *Vessel) StreamRecoverable() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Recoverable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MET will the mission elapsed time in seconds.
//
// Allowed game scenes: any.
func (s *Vessel) MET() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MET",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMET will the mission elapsed time in seconds.
//
// Allowed game scenes: any.
func (s *Vessel) StreamMET() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MET",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Biome will the name of the biome the vessel is currently in.
//
// Allowed game scenes: any.
func (s *Vessel) Biome() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBiome will the name of the biome the vessel is currently in.
//
// Allowed game scenes: any.
func (s *Vessel) StreamBiome() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Orbit will the current orbit of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Orbit() (Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbit will the current orbit of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamOrbit() (*client.Stream[Orbit], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Orbit {
		var value Orbit
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Control will returns a <see cref="T:SpaceCenter.Control" /> object that can
// be used to manipulate the vessel's control inputs. For example, its
// pitch/yaw/roll controls, RCS and thrust.
//
// Allowed game scenes: any.
func (s *Vessel) Control() (Control, error) {
	var err error
	var argBytes []byte
	var vv Control
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Control",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamControl will returns a <see cref="T:SpaceCenter.Control" /> object that
// can be used to manipulate the vessel's control inputs. For example, its
// pitch/yaw/roll controls, RCS and thrust.
//
// Allowed game scenes: any.
func (s *Vessel) StreamControl() (*client.Stream[Control], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Control",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Control {
		var value Control
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Comms will returns a <see cref="T:SpaceCenter.Comms" /> object that can be
// used to interact with CommNet for this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Comms() (Comms, error) {
	var err error
	var argBytes []byte
	var vv Comms
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Comms",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamComms will returns a <see cref="T:SpaceCenter.Comms" /> object that can
// be used to interact with CommNet for this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamComms() (*client.Stream[Comms], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Comms",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Comms {
		var value Comms
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AutoPilot will an <see cref="T:SpaceCenter.AutoPilot" /> object, that can be
// used to perform simple auto-piloting of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AutoPilot() (AutoPilot, error) {
	var err error
	var argBytes []byte
	var vv AutoPilot
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AutoPilot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAutoPilot will an <see cref="T:SpaceCenter.AutoPilot" /> object, that
// can be used to perform simple auto-piloting of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAutoPilot() (*client.Stream[AutoPilot], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AutoPilot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) AutoPilot {
		var value AutoPilot
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CrewCapacity will the number of crew that can occupy the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCapacity() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_CrewCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCrewCapacity will the number of crew that can occupy the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamCrewCapacity() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_CrewCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CrewCount will the number of crew that are occupying the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCount() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_CrewCount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCrewCount will the number of crew that are occupying the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamCrewCount() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_CrewCount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Crew will the crew in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Crew() ([]CrewMember, error) {
	var err error
	var argBytes []byte
	var vv []CrewMember
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Crew",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCrew will the crew in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamCrew() (*client.Stream[[]CrewMember], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Crew",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []CrewMember {
		var value []CrewMember
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Resources will a <see cref="T:SpaceCenter.Resources" /> object, that can used
// to get information about resources stored in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Resources() (Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamResources will a <see cref="T:SpaceCenter.Resources" /> object, that
// can used to get information about resources stored in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamResources() (*client.Stream[Resources], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Resources {
		var value Resources
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parts will a <see cref="T:SpaceCenter.Parts" /> object, that can used to
// interact with the parts that make up this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Parts() (Parts, error) {
	var err error
	var argBytes []byte
	var vv Parts
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Parts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParts will a <see cref="T:SpaceCenter.Parts" /> object, that can used
// to interact with the parts that make up this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamParts() (*client.Stream[Parts], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Parts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Parts {
		var value Parts
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Mass will the total mass of the vessel, including resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) Mass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMass will the total mass of the vessel, including resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) StreamMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// DryMass will the total mass of the vessel, excluding resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) DryMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDryMass will the total mass of the vessel, excluding resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) StreamDryMass() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Thrust will the total thrust currently being produced by the vessel's
// engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.Thrust" /> for every engine in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Thrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamThrust will the total thrust currently being produced by the vessel's
// engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.Thrust" /> for every engine in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableThrust will gets the total available thrust that can be produced by
// the vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.AvailableThrust" /> for every active engine in the
// vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableThrust will gets the total available thrust that can be
// produced by the vessel's active engines, in Newtons. This is computed by
// summing <see cref="M:SpaceCenter.Engine.AvailableThrust" /> for every active
// engine in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxThrust will the total maximum thrust that can be produced by the vessel's
// active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrust" /> for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxThrust will the total maximum thrust that can be produced by the
// vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrust" /> for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) StreamMaxThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxVacuumThrust will the total maximum thrust that can be produced by the
// vessel's active engines when the vessel is in a vacuum, in Newtons. This is
// computed by summing <see cref="M:SpaceCenter.Engine.MaxVacuumThrust" /> for
// every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxVacuumThrust will the total maximum thrust that can be produced by
// the vessel's active engines when the vessel is in a vacuum, in Newtons. This
// is computed by summing <see cref="M:SpaceCenter.Engine.MaxVacuumThrust" />
// for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) StreamMaxVacuumThrust() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SpecificImpulse will the combined specific impulse of all active engines, in
// seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpecificImpulse will the combined specific impulse of all active
// engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) StreamSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// VacuumSpecificImpulse will the combined vacuum specific impulse of all active
// engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamVacuumSpecificImpulse will the combined vacuum specific impulse of all
// active engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) StreamVacuumSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse will the combined specific impulse of all
// active engines at sea level on Kerbin, in seconds. This is computed using the
// formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamKerbinSeaLevelSpecificImpulse will the combined specific impulse of all
// active engines at sea level on Kerbin, in seconds. This is computed using the
// formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) StreamKerbinSeaLevelSpecificImpulse() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MomentOfInertia will the moment of inertia of the vessel around its center of
// mass in <math>kg.m^2</math>. The inertia values in the returned 3-tuple are
// around the pitch, roll and yaw directions respectively. This corresponds to
// the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Vessel) MomentOfInertia() (api.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple3[float64, float64, float64]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMomentOfInertia will the moment of inertia of the vessel around its
// center of mass in <math>kg.m^2</math>. The inertia values in the returned
// 3-tuple are around the pitch, roll and yaw directions respectively. This
// corresponds to the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Vessel) StreamMomentOfInertia() (*client.Stream[api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple3[float64, float64, float64] {
		var value api.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// InertiaTensor will the inertia tensor of the vessel around its center of
// mass, in the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix as a list of
// elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Vessel) InertiaTensor() ([]float64, error) {
	var err error
	var argBytes []byte
	var vv []float64
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInertiaTensor will the inertia tensor of the vessel around its center
// of mass, in the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix as a list of
// elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Vessel) StreamInertiaTensor() (*client.Stream[[]float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []float64 {
		var value []float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableTorque will the maximum torque that the vessel generates. Includes
// contributions from reaction wheels, RCS, gimballed engines and aerodynamic
// control surfaces. Returns the torques in <math>N.m</math> around each of the
// coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableTorque will the maximum torque that the vessel generates.
// Includes contributions from reaction wheels, RCS, gimballed engines and
// aerodynamic control surfaces. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableReactionWheelTorque will the maximum torque that the currently
// active and powered reaction wheels can generate. Returns the torques in
// <math>N.m</math> around each of the coordinate axes of the vessels reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These axes are
// equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableReactionWheelTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableReactionWheelTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableReactionWheelTorque will the maximum torque that the currently
// active and powered reaction wheels can generate. Returns the torques in
// <math>N.m</math> around each of the coordinate axes of the vessels reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These axes are
// equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableReactionWheelTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableReactionWheelTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableRCSTorque will the maximum torque that the currently active RCS
// thrusters can generate. Returns the torques in <math>N.m</math> around each
// of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableRCSTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableRCSTorque will the maximum torque that the currently active
// RCS thrusters can generate. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableRCSTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableEngineTorque will the maximum torque that the currently active and
// gimballed engines can generate. Returns the torques in <math>N.m</math>
// around each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableEngineTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableEngineTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableEngineTorque will the maximum torque that the currently active
// and gimballed engines can generate. Returns the torques in <math>N.m</math>
// around each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableEngineTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableEngineTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableControlSurfaceTorque will the maximum torque that the aerodynamic
// control surfaces can generate. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableControlSurfaceTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableControlSurfaceTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableControlSurfaceTorque will the maximum torque that the
// aerodynamic control surfaces can generate. Returns the torques in
// <math>N.m</math> around each of the coordinate axes of the vessels reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These axes are
// equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableControlSurfaceTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableControlSurfaceTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AvailableOtherTorque will the maximum torque that parts (excluding reaction
// wheels, gimballed engines, RCS and control surfaces) can generate. Returns
// the torques in <math>N.m</math> around each of the coordinate axes of the
// vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These
// axes are equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableOtherTorque() (api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableOtherTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailableOtherTorque will the maximum torque that parts (excluding
// reaction wheels, gimballed engines, RCS and control surfaces) can generate.
// Returns the torques in <math>N.m</math> around each of the coordinate axes of
// the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
// These axes are equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) StreamAvailableOtherTorque() (*client.Stream[api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_AvailableOtherTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]] {
		var value api.Tuple2[api.Tuple3[float64, float64, float64], api.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ReferenceFrame will the reference frame that is fixed relative to the vessel,
// and orientated with the vessel. <list type="bullet"><item><description>The
// origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel.</description></item><item><description>The x-axis points out to the
// right of the vessel.</description></item><item><description>The y-axis points
// in the forward direction of the
// vessel.</description></item><item><description>The z-axis points out of the
// bottom off the vessel.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) ReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReferenceFrame will the reference frame that is fixed relative to the
// vessel, and orientated with the vessel. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel.</description></item><item><description>The x-axis points out to the
// right of the vessel.</description></item><item><description>The y-axis points
// in the forward direction of the
// vessel.</description></item><item><description>The z-axis points out of the
// bottom off the vessel.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) StreamReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrbitalReferenceFrame will the reference frame that is fixed relative to the
// vessel, and orientated with the vessels orbital prograde/normal/radial
// directions. <list type="bullet"><item><description>The origin is at the
// center of mass of the vessel.</description></item><item><description>The axes
// rotate with the orbital prograde/normal/radial
// directions.</description></item><item><description>The x-axis points in the
// orbital anti-radial direction.</description></item><item><description>The
// y-axis points in the orbital prograde
// direction.</description></item><item><description>The z-axis points in the
// orbital normal direction.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) OrbitalReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrbitalReferenceFrame will the reference frame that is fixed relative
// to the vessel, and orientated with the vessels orbital prograde/normal/radial
// directions. <list type="bullet"><item><description>The origin is at the
// center of mass of the vessel.</description></item><item><description>The axes
// rotate with the orbital prograde/normal/radial
// directions.</description></item><item><description>The x-axis points in the
// orbital anti-radial direction.</description></item><item><description>The
// y-axis points in the orbital prograde
// direction.</description></item><item><description>The z-axis points in the
// orbital normal direction.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) StreamOrbitalReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SurfaceReferenceFrame will the reference frame that is fixed relative to the
// vessel, and orientated with the surface of the body being orbited. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the north
// and up directions on the surface of the
// body.</description></item><item><description>The x-axis points in the <a
// href="https://en.wikipedia.org/wiki/Zenith">zenith</a> direction (upwards,
// normal to the body being orbited, from the center of the body towards the
// center of mass of the vessel).</description></item><item><description>The
// y-axis points northwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (north,
// and tangential to the surface of the body -- the direction in which a compass
// would point when on the surface).</description></item><item><description>The
// z-axis points eastwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (east,
// and tangential to the surface of the body -- east on a compass when on the
// surface).</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) SurfaceReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SurfaceReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceReferenceFrame will the reference frame that is fixed relative
// to the vessel, and orientated with the surface of the body being orbited.
// <list type="bullet"><item><description>The origin is at the center of mass of
// the vessel.</description></item><item><description>The axes rotate with the
// north and up directions on the surface of the
// body.</description></item><item><description>The x-axis points in the <a
// href="https://en.wikipedia.org/wiki/Zenith">zenith</a> direction (upwards,
// normal to the body being orbited, from the center of the body towards the
// center of mass of the vessel).</description></item><item><description>The
// y-axis points northwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (north,
// and tangential to the surface of the body -- the direction in which a compass
// would point when on the surface).</description></item><item><description>The
// z-axis points eastwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (east,
// and tangential to the surface of the body -- east on a compass when on the
// surface).</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) StreamSurfaceReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SurfaceReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SurfaceVelocityReferenceFrame will the reference frame that is fixed relative
// to the vessel, and orientated with the velocity vector of the vessel relative
// to the surface of the body being orbited. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel's velocity vector.</description></item><item><description>The y-axis
// points in the direction of the vessel's velocity vector, relative to the
// surface of the body being orbited.</description></item><item><description>The
// z-axis is in the plane of the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical
// horizon</a>.</description></item><item><description>The x-axis is orthogonal
// to the other two axes.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) SurfaceVelocityReferenceFrame() (ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SurfaceVelocityReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceVelocityReferenceFrame will the reference frame that is fixed
// relative to the vessel, and orientated with the velocity vector of the vessel
// relative to the surface of the body being orbited. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel's velocity vector.</description></item><item><description>The y-axis
// points in the direction of the vessel's velocity vector, relative to the
// surface of the body being orbited.</description></item><item><description>The
// z-axis is in the plane of the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical
// horizon</a>.</description></item><item><description>The x-axis is orthogonal
// to the other two axes.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) StreamSurfaceVelocityReferenceFrame() (*client.Stream[ReferenceFrame], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Vessel_get_SurfaceVelocityReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ReferenceFrame {
		var value ReferenceFrame
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Remove will removes the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Remove() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Body will the celestial body the waypoint is attached to.
//
// Allowed game scenes: any.
func (s *Waypoint) Body() (CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBody will the celestial body the waypoint is attached to.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamBody() (*client.Stream[CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) CelestialBody {
		var value CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetBody will the celestial body the waypoint is attached to.
//
// Allowed game scenes: any.
func (s *Waypoint) SetBody(value CelestialBody) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name will the name of the waypoint as it appears on the map and the contract.
//
// Allowed game scenes: any.
func (s *Waypoint) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the waypoint as it appears on the map and the
// contract.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetName will the name of the waypoint as it appears on the map and the
// contract.
//
// Allowed game scenes: any.
func (s *Waypoint) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color will the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.Colors" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) Color() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColor will the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.Colors" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamColor() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetColor will the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.Colors" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) SetColor(value int32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Icon will the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Icon() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIcon will the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamIcon() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetIcon will the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetIcon(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Latitude will the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Latitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLatitude will the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamLatitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetLatitude will the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetLatitude(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Longitude will the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Longitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLongitude will the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamLongitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetLongitude will the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetLongitude(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MeanAltitude will the altitude of the waypoint above sea level, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) MeanAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMeanAltitude will the altitude of the waypoint above sea level, in
// meters.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamMeanAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMeanAltitude will the altitude of the waypoint above sea level, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SetMeanAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceAltitude will the altitude of the waypoint above the surface of the
// body or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SurfaceAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSurfaceAltitude will the altitude of the waypoint above the surface of
// the body or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamSurfaceAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSurfaceAltitude will the altitude of the waypoint above the surface of the
// body or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SetSurfaceAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// BedrockAltitude will the altitude of the waypoint above the surface of the
// body, in meters. When over water, this is the altitude above the sea floor.
//
// Allowed game scenes: any.
func (s *Waypoint) BedrockAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBedrockAltitude will the altitude of the waypoint above the surface of
// the body, in meters. When over water, this is the altitude above the sea
// floor.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamBedrockAltitude() (*client.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetBedrockAltitude will the altitude of the waypoint above the surface of the
// body, in meters. When over water, this is the altitude above the sea floor.
//
// Allowed game scenes: any.
func (s *Waypoint) SetBedrockAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_set_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// NearSurface will true if the waypoint is near to the surface of a body.
//
// Allowed game scenes: any.
func (s *Waypoint) NearSurface() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_NearSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNearSurface will true if the waypoint is near to the surface of a body.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamNearSurface() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_NearSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Grounded will true if the waypoint is attached to the ground.
//
// Allowed game scenes: any.
func (s *Waypoint) Grounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGrounded will true if the waypoint is attached to the ground.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamGrounded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Index will the integer index of this waypoint within its cluster of sibling
// waypoints. In other words, when you have a cluster of waypoints called
// "Somewhere Alpha", "Somewhere Beta" and "Somewhere Gamma", the alpha site has
// index 0, the beta site has index 1 and the gamma site has index 2. When <see
// cref="M:SpaceCenter.Waypoint.Clustered" /> is false, this is zero.
//
// Allowed game scenes: any.
func (s *Waypoint) Index() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Index",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIndex will the integer index of this waypoint within its cluster of
// sibling waypoints. In other words, when you have a cluster of waypoints
// called "Somewhere Alpha", "Somewhere Beta" and "Somewhere Gamma", the alpha
// site has index 0, the beta site has index 1 and the gamma site has index 2.
// When <see cref="M:SpaceCenter.Waypoint.Clustered" /> is false, this is zero.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamIndex() (*client.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Index",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Clustered will true if this waypoint is part of a set of clustered waypoints
// with greek letter names appended (Alpha, Beta, Gamma, etc). If true, there is
// a one-to-one correspondence with the greek letter name and the <see
// cref="M:SpaceCenter.Waypoint.Index" />.
//
// Allowed game scenes: any.
func (s *Waypoint) Clustered() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Clustered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamClustered will true if this waypoint is part of a set of clustered
// waypoints with greek letter names appended (Alpha, Beta, Gamma, etc). If
// true, there is a one-to-one correspondence with the greek letter name and the
// <see cref="M:SpaceCenter.Waypoint.Index" />.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamClustered() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Clustered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// HasContract will whether the waypoint belongs to a contract.
//
// Allowed game scenes: any.
func (s *Waypoint) HasContract() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_HasContract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamHasContract will whether the waypoint belongs to a contract.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamHasContract() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_HasContract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Contract will the associated contract.
//
// Allowed game scenes: any.
func (s *Waypoint) Contract() (Contract, error) {
	var err error
	var argBytes []byte
	var vv Contract
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Contract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamContract will the associated contract.
//
// Allowed game scenes: any.
func (s *Waypoint) StreamContract() (*client.Stream[Contract], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Waypoint_get_Contract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Contract {
		var value Contract
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddWaypoint will creates a waypoint at the given position at ground level,
// and returns a <see cref="T:SpaceCenter.Waypoint" /> object that can be used
// to modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) AddWaypoint(latitude float64, longitude float64, body CelestialBody, name string) (Waypoint, error) {
	var err error
	var argBytes []byte
	var vv Waypoint
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_AddWaypoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddWaypoint will creates a waypoint at the given position at ground
// level, and returns a <see cref="T:SpaceCenter.Waypoint" /> object that can be
// used to modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) StreamAddWaypoint(latitude float64, longitude float64, body CelestialBody, name string) (*client.Stream[Waypoint], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_AddWaypoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Waypoint {
		var value Waypoint
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddWaypointAtAltitude will creates a waypoint at the given position and
// altitude, and returns a <see cref="T:SpaceCenter.Waypoint" /> object that can
// be used to modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) AddWaypointAtAltitude(latitude float64, longitude float64, altitude float64, body CelestialBody, name string) (Waypoint, error) {
	var err error
	var argBytes []byte
	var vv Waypoint
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_AddWaypointAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x5),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddWaypointAtAltitude will creates a waypoint at the given position and
// altitude, and returns a <see cref="T:SpaceCenter.Waypoint" /> object that can
// be used to modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) StreamAddWaypointAtAltitude(latitude float64, longitude float64, altitude float64, body CelestialBody, name string) (*client.Stream[Waypoint], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_AddWaypointAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x5),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Waypoint {
		var value Waypoint
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Waypoints will a list of all existing waypoints.
//
// Allowed game scenes: any.
func (s *WaypointManager) Waypoints() ([]Waypoint, error) {
	var err error
	var argBytes []byte
	var vv []Waypoint
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Waypoints",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWaypoints will a list of all existing waypoints.
//
// Allowed game scenes: any.
func (s *WaypointManager) StreamWaypoints() (*client.Stream[[]Waypoint], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Waypoints",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Waypoint {
		var value []Waypoint
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Icons will returns all available icons (from
// "GameData/Squad/Contracts/Icons/").
//
// Allowed game scenes: any.
func (s *WaypointManager) Icons() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Icons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIcons will returns all available icons (from
// "GameData/Squad/Contracts/Icons/").
//
// Allowed game scenes: any.
func (s *WaypointManager) StreamIcons() (*client.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Icons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Colors will an example map of known color - seed pairs. Any other integers
// may be used as seed.
//
// Allowed game scenes: any.
func (s *WaypointManager) Colors() (map[string]int32, error) {
	var err error
	var argBytes []byte
	var vv map[string]int32
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Colors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamColors will an example map of known color - seed pairs. Any other
// integers may be used as seed.
//
// Allowed game scenes: any.
func (s *WaypointManager) StreamColors() (*client.Stream[map[string]int32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "WaypointManager_get_Colors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) map[string]int32 {
		var value map[string]int32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

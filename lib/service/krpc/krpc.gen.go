package krpc

import (
	api "github.com/atburke/krpc-go/api"
	client "github.com/atburke/krpc-go/lib/client"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// ErrArgument means a method was invoked where at least one of the passed
// arguments does not meet the parameter specification of the method.
type ErrArgument struct {
	msg string
}

// NewErrArgument creates a new ErrArgument.
func NewErrArgument(msg string) *ErrArgument {
	return &ErrArgument{msg: msg}
}

// Error returns a human-readable error.
func (err ErrArgument) Error() string {
	return err.msg
}

// ErrArgumentNull means a null reference was passed to a method that does not
// accept it as a valid argument.
type ErrArgumentNull struct {
	msg string
}

// NewErrArgumentNull creates a new ErrArgumentNull.
func NewErrArgumentNull(msg string) *ErrArgumentNull {
	return &ErrArgumentNull{msg: msg}
}

// Error returns a human-readable error.
func (err ErrArgumentNull) Error() string {
	return err.msg
}

// ErrArgumentOutOfRange means the value of an argument is outside the allowable
// range of values as defined by the invoked method.
type ErrArgumentOutOfRange struct {
	msg string
}

// NewErrArgumentOutOfRange creates a new ErrArgumentOutOfRange.
func NewErrArgumentOutOfRange(msg string) *ErrArgumentOutOfRange {
	return &ErrArgumentOutOfRange{msg: msg}
}

// Error returns a human-readable error.
func (err ErrArgumentOutOfRange) Error() string {
	return err.msg
}

// ErrInvalidOperation means a method call was made to a method that is invalid
// given the current state of the object.
type ErrInvalidOperation struct {
	msg string
}

// NewErrInvalidOperation creates a new ErrInvalidOperation.
func NewErrInvalidOperation(msg string) *ErrInvalidOperation {
	return &ErrInvalidOperation{msg: msg}
}

// Error returns a human-readable error.
func (err ErrInvalidOperation) Error() string {
	return err.msg
}

// GameScene is the game scene. See <see cref="M:KRPC.CurrentGameScene" />.
type GameScene int32

const (
	// The game scene showing the Kerbal Space Center buildings.
	GameScene_SpaceCenter GameScene = 0
	// The game scene showing a vessel in flight (or on the launchpad/runway).
	GameScene_Flight GameScene = 1
	// The tracking station.
	GameScene_TrackingStation GameScene = 2
	// The Vehicle Assembly Building.
	GameScene_EditorVAB GameScene = 3
	// The Space Plane Hangar.
	GameScene_EditorSPH GameScene = 4
)

// Expression - a server side expression.
type Expression struct {
	service.BaseClass
}

// NewExpression creates a new Expression.
func NewExpression(id uint64, client *client.KRPCClient) *Expression {
	c := &Expression{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// Type - a server side expression.
type Type struct {
	service.BaseClass
}

// NewType creates a new Type.
func NewType(id uint64, client *client.KRPCClient) *Type {
	c := &Type{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// KRPC - main kRPC service, used by clients to interact with basic server
// functionality.
type KRPC struct {
	Client *client.KRPCClient
}

// NewKRPC creates a new KRPC.
func NewKRPC(client *client.KRPCClient) *KRPC {
	return &KRPC{Client: client}
}

// GetClientID will returns the identifier for the current client.
//
// Allowed game scenes: any.
func (s *KRPC) GetClientID() ([]byte, error) {
	var err error
	var vv []byte
	request := &api.ProcedureCall{
		Procedure: "GetClientID",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetClientID will returns the identifier for the current client.
//
// Allowed game scenes: any.
func (s *KRPC) StreamGetClientID() (*client.Stream[[]byte], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "GetClientID",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []byte {
		var value []byte
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GetClientName will returns the name of the current client. This is an empty
// string if the client has no name.
//
// Allowed game scenes: any.
func (s *KRPC) GetClientName() (string, error) {
	var err error
	var vv string
	request := &api.ProcedureCall{
		Procedure: "GetClientName",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetClientName will returns the name of the current client. This is an
// empty string if the client has no name.
//
// Allowed game scenes: any.
func (s *KRPC) StreamGetClientName() (*client.Stream[string], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "GetClientName",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GetStatus will returns some information about the server, such as the
// version.
//
// Allowed game scenes: any.
func (s *KRPC) GetStatus() (api.Status, error) {
	var err error
	var vv api.Status
	request := &api.ProcedureCall{
		Procedure: "GetStatus",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetStatus will returns some information about the server, such as the
// version.
//
// Allowed game scenes: any.
func (s *KRPC) StreamGetStatus() (*client.Stream[api.Status], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "GetStatus",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Status {
		var value api.Status
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GetServices will returns information on all services, procedures, classes,
// properties etc. provided by the server. Can be used by client libraries to
// automatically create functionality such as stubs.
//
// Allowed game scenes: any.
func (s *KRPC) GetServices() (api.Services, error) {
	var err error
	var vv api.Services
	request := &api.ProcedureCall{
		Procedure: "GetServices",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGetServices will returns information on all services, procedures,
// classes, properties etc. provided by the server. Can be used by client
// libraries to automatically create functionality such as stubs.
//
// Allowed game scenes: any.
func (s *KRPC) StreamGetServices() (*client.Stream[api.Services], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "GetServices",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Services {
		var value api.Services
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AddStream will add a streaming request and return its identifier.
//
// Allowed game scenes: any.
func (s *KRPC) AddStream(call api.ProcedureCall, start bool) (api.Stream, error) {
	var err error
	var argBytes []byte
	var vv api.Stream
	request := &api.ProcedureCall{
		Procedure: "AddStream",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(call)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(start)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAddStream will add a streaming request and return its identifier.
//
// Allowed game scenes: any.
func (s *KRPC) StreamAddStream(call api.ProcedureCall, start bool) (*client.Stream[api.Stream], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddStream",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(call)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(start)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) api.Stream {
		var value api.Stream
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// StartStream will start a previously added streaming request.
//
// Allowed game scenes: any.
func (s *KRPC) StartStream(id uint64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "StartStream",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetStreamRate will set the update rate for a stream in Hz.
//
// Allowed game scenes: any.
func (s *KRPC) SetStreamRate(id uint64, rate float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "SetStreamRate",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rate)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RemoveStream will remove a streaming request.
//
// Allowed game scenes: any.
func (s *KRPC) RemoveStream(id uint64) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "RemoveStream",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AddEvent will create an event from a server side expression.
//
// Allowed game scenes: any.
func (s *KRPC) AddEvent(expression Expression) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "AddEvent",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(expression)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Clients will a list of RPC clients that are currently connected to the
// server. Each entry in the list is a clients identifier, name and address.
//
// Allowed game scenes: any.
func (s *KRPC) Clients() ([]api.Tuple3[[]byte, string, string], error) {
	var err error
	var vv []api.Tuple3[[]byte, string, string]
	request := &api.ProcedureCall{
		Procedure: "get_Clients",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamClients will a list of RPC clients that are currently connected to the
// server. Each entry in the list is a clients identifier, name and address.
//
// Allowed game scenes: any.
func (s *KRPC) StreamClients() (*client.Stream[[]api.Tuple3[[]byte, string, string]], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Clients",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []api.Tuple3[[]byte, string, string] {
		var value []api.Tuple3[[]byte, string, string]
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CurrentGameScene will get the current game scene.
//
// Allowed game scenes: any.
func (s *KRPC) CurrentGameScene() (GameScene, error) {
	var err error
	var vv GameScene
	request := &api.ProcedureCall{
		Procedure: "get_CurrentGameScene",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCurrentGameScene will get the current game scene.
//
// Allowed game scenes: any.
func (s *KRPC) StreamCurrentGameScene() (*client.Stream[GameScene], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_CurrentGameScene",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) GameScene {
		var value GameScene
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Paused will whether the game is paused.
//
// Allowed game scenes: any.
func (s *KRPC) Paused() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_Paused",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPaused will whether the game is paused.
//
// Allowed game scenes: any.
func (s *KRPC) StreamPaused() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Paused",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetPaused will whether the game is paused.
//
// Allowed game scenes: any.
func (s *KRPC) SetPaused(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "set_Paused",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ConstantDouble will a constant value of double precision floating point type.
//
// Allowed game scenes: any.
func (s *Expression) ConstantDouble() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantDouble",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConstantDouble will a constant value of double precision floating point
// type.
//
// Allowed game scenes: any.
func (s *Expression) StreamConstantDouble() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantDouble",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ConstantFloat will a constant value of single precision floating point type.
//
// Allowed game scenes: any.
func (s *Expression) ConstantFloat() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantFloat",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConstantFloat will a constant value of single precision floating point
// type.
//
// Allowed game scenes: any.
func (s *Expression) StreamConstantFloat() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantFloat",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ConstantInt will a constant value of integer type.
//
// Allowed game scenes: any.
func (s *Expression) ConstantInt() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantInt",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConstantInt will a constant value of integer type.
//
// Allowed game scenes: any.
func (s *Expression) StreamConstantInt() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantInt",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ConstantBool will a constant value of boolean type.
//
// Allowed game scenes: any.
func (s *Expression) ConstantBool() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantBool",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConstantBool will a constant value of boolean type.
//
// Allowed game scenes: any.
func (s *Expression) StreamConstantBool() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantBool",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ConstantString will a constant value of string type.
//
// Allowed game scenes: any.
func (s *Expression) ConstantString() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantString",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConstantString will a constant value of string type.
//
// Allowed game scenes: any.
func (s *Expression) StreamConstantString() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ConstantString",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Call will an RPC call.
//
// Allowed game scenes: any.
func (s *Expression) Call() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Call",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCall will an RPC call.
//
// Allowed game scenes: any.
func (s *Expression) StreamCall() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Call",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Equal will equality comparison.
//
// Allowed game scenes: any.
func (s *Expression) Equal(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Equal",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamEqual will equality comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamEqual(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Equal",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// NotEqual will inequality comparison.
//
// Allowed game scenes: any.
func (s *Expression) NotEqual(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_NotEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNotEqual will inequality comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamNotEqual(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_NotEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GreaterThan will greater than numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) GreaterThan(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_GreaterThan",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGreaterThan will greater than numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamGreaterThan(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_GreaterThan",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// GreaterThanOrEqual will greater than or equal numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) GreaterThanOrEqual(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_GreaterThanOrEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGreaterThanOrEqual will greater than or equal numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamGreaterThanOrEqual(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_GreaterThanOrEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LessThan will less than numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) LessThan(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LessThan",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLessThan will less than numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamLessThan(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LessThan",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LessThanOrEqual will less than or equal numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) LessThanOrEqual(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LessThanOrEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLessThanOrEqual will less than or equal numerical comparison.
//
// Allowed game scenes: any.
func (s *Expression) StreamLessThanOrEqual(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LessThanOrEqual",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// And will boolean and operator.
//
// Allowed game scenes: any.
func (s *Expression) And(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_And",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAnd will boolean and operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamAnd(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_And",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Or will boolean or operator.
//
// Allowed game scenes: any.
func (s *Expression) Or(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Or",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOr will boolean or operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamOr(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Or",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ExclusiveOr will boolean exclusive-or operator.
//
// Allowed game scenes: any.
func (s *Expression) ExclusiveOr(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ExclusiveOr",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExclusiveOr will boolean exclusive-or operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamExclusiveOr(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ExclusiveOr",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Not will boolean negation operator.
//
// Allowed game scenes: any.
func (s *Expression) Not() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Not",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamNot will boolean negation operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamNot() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Not",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Add will numerical addition.
//
// Allowed game scenes: any.
func (s *Expression) Add(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Add",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAdd will numerical addition.
//
// Allowed game scenes: any.
func (s *Expression) StreamAdd(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Add",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Subtract will numerical subtraction.
//
// Allowed game scenes: any.
func (s *Expression) Subtract(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Subtract",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSubtract will numerical subtraction.
//
// Allowed game scenes: any.
func (s *Expression) StreamSubtract(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Subtract",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Multiply will numerical multiplication.
//
// Allowed game scenes: any.
func (s *Expression) Multiply(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Multiply",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMultiply will numerical multiplication.
//
// Allowed game scenes: any.
func (s *Expression) StreamMultiply(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Multiply",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Divide will numerical division.
//
// Allowed game scenes: any.
func (s *Expression) Divide(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Divide",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDivide will numerical division.
//
// Allowed game scenes: any.
func (s *Expression) StreamDivide(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Divide",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Modulo will numerical modulo operator.
//
// Allowed game scenes: any.
func (s *Expression) Modulo(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Modulo",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamModulo will numerical modulo operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamModulo(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Modulo",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Power will numerical power operator.
//
// Allowed game scenes: any.
func (s *Expression) Power(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Power",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPower will numerical power operator.
//
// Allowed game scenes: any.
func (s *Expression) StreamPower(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Power",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// LeftShift will bitwise left shift.
//
// Allowed game scenes: any.
func (s *Expression) LeftShift(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LeftShift",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamLeftShift will bitwise left shift.
//
// Allowed game scenes: any.
func (s *Expression) StreamLeftShift(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_LeftShift",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// RightShift will bitwise right shift.
//
// Allowed game scenes: any.
func (s *Expression) RightShift(arg1 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_RightShift",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamRightShift will bitwise right shift.
//
// Allowed game scenes: any.
func (s *Expression) StreamRightShift(arg1 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_RightShift",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg1)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Cast will perform a cast to the given type.
//
// Allowed game scenes: any.
func (s *Expression) Cast(t Type) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Cast",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCast will perform a cast to the given type.
//
// Allowed game scenes: any.
func (s *Expression) StreamCast(t Type) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Cast",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parameter will a named parameter of type double.
//
// Allowed game scenes: any.
func (s *Expression) Parameter(t Type) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Parameter",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParameter will a named parameter of type double.
//
// Allowed game scenes: any.
func (s *Expression) StreamParameter(t Type) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Parameter",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Function will a function.
//
// Allowed game scenes: any.
func (s *Expression) Function(body Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Function",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFunction will a function.
//
// Allowed game scenes: any.
func (s *Expression) StreamFunction(body Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Function",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Invoke will a function call.
//
// Allowed game scenes: any.
func (s *Expression) Invoke(args map[string]Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Invoke",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(args)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInvoke will a function call.
//
// Allowed game scenes: any.
func (s *Expression) StreamInvoke(args map[string]Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Invoke",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(args)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateTuple will construct a tuple.
//
// Allowed game scenes: any.
func (s *Expression) CreateTuple() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateTuple",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateTuple will construct a tuple.
//
// Allowed game scenes: any.
func (s *Expression) StreamCreateTuple() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateTuple",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateList will construct a list.
//
// Allowed game scenes: any.
func (s *Expression) CreateList() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateList",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateList will construct a list.
//
// Allowed game scenes: any.
func (s *Expression) StreamCreateList() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateList",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateSet will construct a set.
//
// Allowed game scenes: any.
func (s *Expression) CreateSet() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateSet",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateSet will construct a set.
//
// Allowed game scenes: any.
func (s *Expression) StreamCreateSet() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateSet",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// CreateDictionary will construct a dictionary, from a list of corresponding
// keys and values.
//
// Allowed game scenes: any.
func (s *Expression) CreateDictionary(values []Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateDictionary",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(values)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCreateDictionary will construct a dictionary, from a list of
// corresponding keys and values.
//
// Allowed game scenes: any.
func (s *Expression) StreamCreateDictionary(values []Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_CreateDictionary",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(values)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ToList will convert a collection to a list.
//
// Allowed game scenes: any.
func (s *Expression) ToList() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ToList",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamToList will convert a collection to a list.
//
// Allowed game scenes: any.
func (s *Expression) StreamToList() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ToList",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ToSet will convert a collection to a set.
//
// Allowed game scenes: any.
func (s *Expression) ToSet() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ToSet",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamToSet will convert a collection to a set.
//
// Allowed game scenes: any.
func (s *Expression) StreamToSet() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_ToSet",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Get will access an element in a tuple, list or dictionary.
//
// Allowed game scenes: any.
func (s *Expression) Get(index Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Get",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamGet will access an element in a tuple, list or dictionary.
//
// Allowed game scenes: any.
func (s *Expression) StreamGet(index Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Get",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Count will number of elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) Count() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Count",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCount will number of elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamCount() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Count",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Sum will sum all elements of a collection.
//
// Allowed game scenes: any.
func (s *Expression) Sum() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Sum",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSum will sum all elements of a collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamSum() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Sum",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Max will maximum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) Max() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Max",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMax will maximum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamMax() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Max",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Min will minimum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) Min() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Min",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMin will minimum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamMin() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Min",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Average will minimum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) Average() (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Average",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAverage will minimum of all elements in a collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamAverage() (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Average",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Select will run a function on every element in the collection.
//
// Allowed game scenes: any.
func (s *Expression) Select(f Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Select",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSelect will run a function on every element in the collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamSelect(f Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Select",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Where will run a function on every element in the collection.
//
// Allowed game scenes: any.
func (s *Expression) Where(f Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Where",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamWhere will run a function on every element in the collection.
//
// Allowed game scenes: any.
func (s *Expression) StreamWhere(f Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Where",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Contains will determine if a collection contains a value.
//
// Allowed game scenes: any.
func (s *Expression) Contains(value Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Contains",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamContains will determine if a collection contains a value.
//
// Allowed game scenes: any.
func (s *Expression) StreamContains(value Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Contains",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Aggregate will applies an accumulator function over a sequence.
//
// Allowed game scenes: any.
func (s *Expression) Aggregate(f Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Aggregate",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAggregate will applies an accumulator function over a sequence.
//
// Allowed game scenes: any.
func (s *Expression) StreamAggregate(f Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Aggregate",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// AggregateWithSeed will applies an accumulator function over a sequence, with
// a given seed.
//
// Allowed game scenes: any.
func (s *Expression) AggregateWithSeed(seed Expression, f Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_AggregateWithSeed",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(seed)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAggregateWithSeed will applies an accumulator function over a sequence,
// with a given seed.
//
// Allowed game scenes: any.
func (s *Expression) StreamAggregateWithSeed(seed Expression, f Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_AggregateWithSeed",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(seed)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(f)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Concat will concatenate two sequences.
//
// Allowed game scenes: any.
func (s *Expression) Concat(arg2 Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Concat",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg2)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConcat will concatenate two sequences.
//
// Allowed game scenes: any.
func (s *Expression) StreamConcat(arg2 Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Concat",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(arg2)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// OrderBy will order a collection using a key function.
//
// Allowed game scenes: any.
func (s *Expression) OrderBy(key Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_OrderBy",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(key)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamOrderBy will order a collection using a key function.
//
// Allowed game scenes: any.
func (s *Expression) StreamOrderBy(key Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_OrderBy",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(key)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// All will determine whether all items in a collection satisfy a boolean
// predicate.
//
// Allowed game scenes: any.
func (s *Expression) All(predicate Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_All",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(predicate)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAll will determine whether all items in a collection satisfy a boolean
// predicate.
//
// Allowed game scenes: any.
func (s *Expression) StreamAll(predicate Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_All",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(predicate)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Any will determine whether any item in a collection satisfies a boolean
// predicate.
//
// Allowed game scenes: any.
func (s *Expression) Any(predicate Expression) (Expression, error) {
	var err error
	var argBytes []byte
	var vv Expression
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Any",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(predicate)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAny will determine whether any item in a collection satisfies a boolean
// predicate.
//
// Allowed game scenes: any.
func (s *Expression) StreamAny(predicate Expression) (*client.Stream[Expression], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Expression_static_Any",
		Service:   "KRPC",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(predicate)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Expression {
		var value Expression
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Double will double type.
//
// Allowed game scenes: any.
func (s *Type) Double() (Type, error) {
	var err error
	var vv Type
	request := &api.ProcedureCall{
		Procedure: "Type_static_Double",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamDouble will double type.
//
// Allowed game scenes: any.
func (s *Type) StreamDouble() (*client.Stream[Type], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Type_static_Double",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Type {
		var value Type
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Float will float type.
//
// Allowed game scenes: any.
func (s *Type) Float() (Type, error) {
	var err error
	var vv Type
	request := &api.ProcedureCall{
		Procedure: "Type_static_Float",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamFloat will float type.
//
// Allowed game scenes: any.
func (s *Type) StreamFloat() (*client.Stream[Type], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Type_static_Float",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Type {
		var value Type
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Int will int type.
//
// Allowed game scenes: any.
func (s *Type) Int() (Type, error) {
	var err error
	var vv Type
	request := &api.ProcedureCall{
		Procedure: "Type_static_Int",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamInt will int type.
//
// Allowed game scenes: any.
func (s *Type) StreamInt() (*client.Stream[Type], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Type_static_Int",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Type {
		var value Type
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Bool will bool type.
//
// Allowed game scenes: any.
func (s *Type) Bool() (Type, error) {
	var err error
	var vv Type
	request := &api.ProcedureCall{
		Procedure: "Type_static_Bool",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamBool will bool type.
//
// Allowed game scenes: any.
func (s *Type) StreamBool() (*client.Stream[Type], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Type_static_Bool",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Type {
		var value Type
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// String will string type.
//
// Allowed game scenes: any.
func (s *Type) String() (Type, error) {
	var err error
	var vv Type
	request := &api.ProcedureCall{
		Procedure: "Type_static_String",
		Service:   "KRPC",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamString will string type.
//
// Allowed game scenes: any.
func (s *Type) StreamString() (*client.Stream[Type], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "Type_static_String",
		Service:   "KRPC",
	}
	krpc := NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Type {
		var value Type
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

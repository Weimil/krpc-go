package infernalrobotics

import (
	api "github.com/atburke/krpc-go/api"
	client "github.com/atburke/krpc-go/lib/client"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	krpc "github.com/atburke/krpc-go/lib/service/krpc"
	spacecenter "github.com/atburke/krpc-go/lib/service/spacecenter"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// Servo - represents a servo. Obtained using <see
// cref="M:InfernalRobotics.ServoGroup.Servos" />, <see
// cref="M:InfernalRobotics.ServoGroup.ServoWithName" /> or <see
// cref="M:InfernalRobotics.ServoWithName" />.
type Servo struct {
	service.BaseClass
}

// NewServo creates a new Servo.
func NewServo(id uint64, client *client.KRPCClient) *Servo {
	c := &Servo{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ServoGroup - a group of servos, obtained by calling <see
// cref="M:InfernalRobotics.ServoGroups" /> or <see
// cref="M:InfernalRobotics.ServoGroupWithName" />. Represents the "Servo
// Groups" in the InfernalRobotics UI.
type ServoGroup struct {
	service.BaseClass
}

// NewServoGroup creates a new ServoGroup.
func NewServoGroup(id uint64, client *client.KRPCClient) *ServoGroup {
	c := &ServoGroup{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// InfernalRobotics - this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/104535-112-magic-smoke-industries-infernal-robotics-202/">Infernal
// Robotics</a>.
type InfernalRobotics struct {
	Client *client.KRPCClient
}

// NewInfernalRobotics creates a new InfernalRobotics.
func NewInfernalRobotics(client *client.KRPCClient) *InfernalRobotics {
	return &InfernalRobotics{Client: client}
}

// ServoGroups will a list of all the servo groups in the given <paramref
// name="vessel" />.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoGroups(vessel spacecenter.Vessel) ([]ServoGroup, error) {
	var err error
	var argBytes []byte
	var vv []ServoGroup
	request := &api.ProcedureCall{
		Procedure: "ServoGroups",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamServoGroups will a list of all the servo groups in the given <paramref
// name="vessel" />.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) StreamServoGroups(vessel spacecenter.Vessel) (*client.Stream[[]ServoGroup], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroups",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []ServoGroup {
		var value []ServoGroup
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ServoGroupWithName will returns the servo group in the given <paramref
// name="vessel" /> with the given <paramref name="name" />, or nil if none
// exists. If multiple servo groups have the same name, only one of them is
// returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoGroupWithName(vessel spacecenter.Vessel, name string) (ServoGroup, error) {
	var err error
	var argBytes []byte
	var vv ServoGroup
	request := &api.ProcedureCall{
		Procedure: "ServoGroupWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamServoGroupWithName will returns the servo group in the given <paramref
// name="vessel" /> with the given <paramref name="name" />, or nil if none
// exists. If multiple servo groups have the same name, only one of them is
// returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) StreamServoGroupWithName(vessel spacecenter.Vessel, name string) (*client.Stream[ServoGroup], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroupWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) ServoGroup {
		var value ServoGroup
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// ServoWithName will returns the servo in the given <paramref name="vessel" />
// with the given <paramref name="name" /> or nil if none exists. If multiple
// servos have the same name, only one of them is returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoWithName(vessel spacecenter.Vessel, name string) (Servo, error) {
	var err error
	var argBytes []byte
	var vv Servo
	request := &api.ProcedureCall{
		Procedure: "ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamServoWithName will returns the servo in the given <paramref
// name="vessel" /> with the given <paramref name="name" /> or nil if none
// exists. If multiple servos have the same name, only one of them is returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) StreamServoWithName(vessel spacecenter.Vessel, name string) (*client.Stream[Servo], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Servo {
		var value Servo
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Available will whether Infernal Robotics is installed.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) Available() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_Available",
		Service:   "InfernalRobotics",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAvailable will whether Infernal Robotics is installed.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) StreamAvailable() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Available",
		Service:   "InfernalRobotics",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Ready will whether Infernal Robotics API is ready.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) Ready() (bool, error) {
	var err error
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "get_Ready",
		Service:   "InfernalRobotics",
	}
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReady will whether Infernal Robotics API is ready.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) StreamReady() (*client.Stream[bool], error) {
	var err error
	request := &api.ProcedureCall{
		Procedure: "get_Ready",
		Service:   "InfernalRobotics",
	}
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MoveRight will moves the servo to the right.
//
// Allowed game scenes: any.
func (s *Servo) MoveRight() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MoveRight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveLeft will moves the servo to the left.
//
// Allowed game scenes: any.
func (s *Servo) MoveLeft() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MoveLeft",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveCenter will moves the servo to the center.
//
// Allowed game scenes: any.
func (s *Servo) MoveCenter() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MoveCenter",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveNextPreset will moves the servo to the next preset.
//
// Allowed game scenes: any.
func (s *Servo) MoveNextPreset() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MoveNextPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MovePrevPreset will moves the servo to the previous preset.
//
// Allowed game scenes: any.
func (s *Servo) MovePrevPreset() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MovePrevPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveTo will moves the servo to <paramref name="position" /> and sets the
// speed multiplier to <paramref name="speed" />.
//
// Allowed game scenes: any.
func (s *Servo) MoveTo(position float32, speed float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_MoveTo",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(speed)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop will stops the servo.
//
// Allowed game scenes: any.
func (s *Servo) Stop() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_Stop",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name will the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetName will the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part will the part containing the servo.
//
// Allowed game scenes: any.
func (s *Servo) Part() (spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Part
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Part",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPart will the part containing the servo.
//
// Allowed game scenes: any.
func (s *Servo) StreamPart() (*client.Stream[spacecenter.Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Part",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) spacecenter.Part {
		var value spacecenter.Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetHighlight will whether the servo should be highlighted in-game.
//
// Allowed game scenes: any.
func (s *Servo) SetHighlight(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_Highlight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position will the position of the servo.
//
// Allowed game scenes: any.
func (s *Servo) Position() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Position",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamPosition will the position of the servo.
//
// Allowed game scenes: any.
func (s *Servo) StreamPosition() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Position",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MinConfigPosition will the minimum position of the servo, specified by the
// part configuration.
//
// Allowed game scenes: any.
func (s *Servo) MinConfigPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MinConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMinConfigPosition will the minimum position of the servo, specified by
// the part configuration.
//
// Allowed game scenes: any.
func (s *Servo) StreamMinConfigPosition() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MinConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MaxConfigPosition will the maximum position of the servo, specified by the
// part configuration.
//
// Allowed game scenes: any.
func (s *Servo) MaxConfigPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MaxConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxConfigPosition will the maximum position of the servo, specified by
// the part configuration.
//
// Allowed game scenes: any.
func (s *Servo) StreamMaxConfigPosition() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MaxConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MinPosition will the minimum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MinPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMinPosition will the minimum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) StreamMinPosition() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMinPosition will the minimum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SetMinPosition(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MaxPosition will the maximum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MaxPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamMaxPosition will the maximum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) StreamMaxPosition() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetMaxPosition will the maximum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SetMaxPosition(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ConfigSpeed will the speed multiplier of the servo, specified by the part
// configuration.
//
// Allowed game scenes: any.
func (s *Servo) ConfigSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_ConfigSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamConfigSpeed will the speed multiplier of the servo, specified by the
// part configuration.
//
// Allowed game scenes: any.
func (s *Servo) StreamConfigSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_ConfigSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Speed will the speed multiplier of the servo, specified by the in-game tweak
// menu.
//
// Allowed game scenes: any.
func (s *Servo) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeed will the speed multiplier of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) StreamSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSpeed will the speed multiplier of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SetSpeed(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentSpeed will the current speed at which the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) CurrentSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_CurrentSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamCurrentSpeed will the current speed at which the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) StreamCurrentSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_CurrentSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetCurrentSpeed will the current speed at which the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) SetCurrentSpeed(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_CurrentSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Acceleration will the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) Acceleration() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamAcceleration will the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) StreamAcceleration() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetAcceleration will the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) SetAcceleration(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsMoving will whether the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) IsMoving() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsMoving will whether the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) StreamIsMoving() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsFreeMoving will whether the servo is freely moving.
//
// Allowed game scenes: any.
func (s *Servo) IsFreeMoving() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsFreeMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsFreeMoving will whether the servo is freely moving.
//
// Allowed game scenes: any.
func (s *Servo) StreamIsFreeMoving() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsFreeMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// IsLocked will whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) IsLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsLocked will whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) StreamIsLocked() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetIsLocked will whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) SetIsLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsAxisInverted will whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) IsAxisInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamIsAxisInverted will whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) StreamIsAxisInverted() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_get_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetIsAxisInverted will whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) SetIsAxisInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "Servo_set_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ServoWithName will returns the servo with the given <paramref name="name" />
// from this group, or nil if none exists.
//
// Allowed game scenes: any.
func (s *ServoGroup) ServoWithName(name string) (Servo, error) {
	var err error
	var argBytes []byte
	var vv Servo
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamServoWithName will returns the servo with the given <paramref
// name="name" /> from this group, or nil if none exists.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamServoWithName(name string) (*client.Stream[Servo], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) Servo {
		var value Servo
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// MoveRight will moves all of the servos in the group to the right.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveRight() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_MoveRight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveLeft will moves all of the servos in the group to the left.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveLeft() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_MoveLeft",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveCenter will moves all of the servos in the group to the center.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveCenter() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_MoveCenter",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveNextPreset will moves all of the servos in the group to the next preset.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveNextPreset() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_MoveNextPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MovePrevPreset will moves all of the servos in the group to the previous
// preset.
//
// Allowed game scenes: any.
func (s *ServoGroup) MovePrevPreset() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_MovePrevPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop will stops the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Stop() error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_Stop",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name will the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamName will the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamName() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetName will the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_set_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ForwardKey will the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ForwardKey() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamForwardKey will the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamForwardKey() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetForwardKey will the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetForwardKey(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_set_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReverseKey will the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ReverseKey() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamReverseKey will the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamReverseKey() (*client.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetReverseKey will the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetReverseKey(value string) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_set_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Speed will the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamSpeed will the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamSpeed() (*client.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetSpeed will the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetSpeed(value float32) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_set_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Expanded will whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) Expanded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamExpanded will whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamExpanded() (*client.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// SetExpanded will whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetExpanded(value bool) error {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_set_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request, false)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Servos will the servos that are in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Servos() ([]Servo, error) {
	var err error
	var argBytes []byte
	var vv []Servo
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Servos",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamServos will the servos that are in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamServos() (*client.Stream[[]Servo], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Servos",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []Servo {
		var value []Servo
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}

// Parts will the parts containing the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Parts() ([]spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv []spacecenter.Part
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Parts",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request, true)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StreamParts will the parts containing the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) StreamParts() (*client.Stream[[]spacecenter.Part], error) {
	var err error
	var argBytes []byte
	request := &api.ProcedureCall{
		Procedure: "ServoGroup_get_Parts",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &api.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.NewKRPC(s.Client)
	st, err := krpc.AddStream(*request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := client.MapStream(rawStream, func(b []byte) []spacecenter.Part {
		var value []spacecenter.Part
		encode.Unmarshal(b, &value)
		return value
	})
	return stream, nil
}
